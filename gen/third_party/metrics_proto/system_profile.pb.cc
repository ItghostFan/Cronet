// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: system_profile.proto

#include "system_profile.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace metrics {
PROTOBUF_CONSTEXPR SystemProfileProto_ClonedInstallInfo::SystemProfileProto_ClonedInstallInfo(
    ::_pbi::ConstantInitialized)
  : last_timestamp_(int64_t{0})
  , cloned_from_client_id_(uint64_t{0u})
  , first_timestamp_(int64_t{0})
  , count_(0){}
struct SystemProfileProto_ClonedInstallInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProto_ClonedInstallInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProto_ClonedInstallInfoDefaultTypeInternal() {}
  union {
    SystemProfileProto_ClonedInstallInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProto_ClonedInstallInfoDefaultTypeInternal _SystemProfileProto_ClonedInstallInfo_default_instance_;
PROTOBUF_CONSTEXPR SystemProfileProto_OS_Arc::SystemProfileProto_OS_Arc(
    ::_pbi::ConstantInitialized)
  : release_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct SystemProfileProto_OS_ArcDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProto_OS_ArcDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProto_OS_ArcDefaultTypeInternal() {}
  union {
    SystemProfileProto_OS_Arc _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProto_OS_ArcDefaultTypeInternal _SystemProfileProto_OS_Arc_default_instance_;
PROTOBUF_CONSTEXPR SystemProfileProto_OS::SystemProfileProto_OS(
    ::_pbi::ConstantInitialized)
  : name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , build_fingerprint_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , build_number_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , kernel_version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , arc_(nullptr)
  , deprecated_is_jailbroken_(false)
  , dark_mode_state_(0)

  , xdg_session_type_(0)

  , xdg_current_desktop_(0)
{}
struct SystemProfileProto_OSDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProto_OSDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProto_OSDefaultTypeInternal() {}
  union {
    SystemProfileProto_OS _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProto_OSDefaultTypeInternal _SystemProfileProto_OS_default_instance_;
PROTOBUF_CONSTEXPR SystemProfileProto_Hardware_CPU::SystemProfileProto_Hardware_CPU(
    ::_pbi::ConstantInitialized)
  : vendor_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , signature_(0u)
  , num_cores_(0u)
  , is_hypervisor_(false){}
struct SystemProfileProto_Hardware_CPUDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProto_Hardware_CPUDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProto_Hardware_CPUDefaultTypeInternal() {}
  union {
    SystemProfileProto_Hardware_CPU _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProto_Hardware_CPUDefaultTypeInternal _SystemProfileProto_Hardware_CPU_default_instance_;
PROTOBUF_CONSTEXPR SystemProfileProto_Hardware_Motherboard::SystemProfileProto_Hardware_Motherboard(
    ::_pbi::ConstantInitialized)
  : manufacturer_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , model_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , bios_manufacturer_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , bios_version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , bios_type_(0)
{}
struct SystemProfileProto_Hardware_MotherboardDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProto_Hardware_MotherboardDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProto_Hardware_MotherboardDefaultTypeInternal() {}
  union {
    SystemProfileProto_Hardware_Motherboard _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProto_Hardware_MotherboardDefaultTypeInternal _SystemProfileProto_Hardware_Motherboard_default_instance_;
PROTOBUF_CONSTEXPR SystemProfileProto_Hardware_Graphics::SystemProfileProto_Hardware_Graphics(
    ::_pbi::ConstantInitialized)
  : driver_version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , gl_vendor_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , gl_renderer_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , vendor_id_(0u)
  , device_id_(0u){}
struct SystemProfileProto_Hardware_GraphicsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProto_Hardware_GraphicsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProto_Hardware_GraphicsDefaultTypeInternal() {}
  union {
    SystemProfileProto_Hardware_Graphics _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProto_Hardware_GraphicsDefaultTypeInternal _SystemProfileProto_Hardware_Graphics_default_instance_;
PROTOBUF_CONSTEXPR SystemProfileProto_Hardware_InternalStorageDevice::SystemProfileProto_Hardware_InternalStorageDevice(
    ::_pbi::ConstantInitialized)
  : model_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , product_id_(uint64_t{0u})
  , vendor_id_(0u)
  , revision_(0u)
  , firmware_version_(uint64_t{0u})
  , size_mb_(0u)
  , type_(0)

  , purpose_(0)
{}
struct SystemProfileProto_Hardware_InternalStorageDeviceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProto_Hardware_InternalStorageDeviceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProto_Hardware_InternalStorageDeviceDefaultTypeInternal() {}
  union {
    SystemProfileProto_Hardware_InternalStorageDevice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProto_Hardware_InternalStorageDeviceDefaultTypeInternal _SystemProfileProto_Hardware_InternalStorageDevice_default_instance_;
PROTOBUF_CONSTEXPR SystemProfileProto_Hardware_Drive::SystemProfileProto_Hardware_Drive(
    ::_pbi::ConstantInitialized)
  : has_seek_penalty_(false){}
struct SystemProfileProto_Hardware_DriveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProto_Hardware_DriveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProto_Hardware_DriveDefaultTypeInternal() {}
  union {
    SystemProfileProto_Hardware_Drive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProto_Hardware_DriveDefaultTypeInternal _SystemProfileProto_Hardware_Drive_default_instance_;
PROTOBUF_CONSTEXPR SystemProfileProto_Hardware::SystemProfileProto_Hardware(
    ::_pbi::ConstantInitialized)
  : internal_storage_devices_()
  , cpu_architecture_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , hardware_class_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , full_hardware_class_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , app_cpu_architecture_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , cellular_device_variant_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , tpm_rw_firmware_version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , gpu_(nullptr)
  , cpu_(nullptr)
  , app_drive_(nullptr)
  , user_data_drive_(nullptr)
  , motherboard_(nullptr)
  , system_ram_mb_(int64_t{0})
  , dll_base_(int64_t{0})
  , screen_count_(0)
  , primary_screen_width_(0)
  , primary_screen_height_(0)
  , max_dpi_x_(0)
  , max_dpi_y_(0)
  , primary_screen_scale_factor_(0)
  , internal_display_supports_touch_(false)
  , form_factor_(0)

  , tpm_firmware_version_(uint64_t{0u})
  , tpm_type_(0)
{}
struct SystemProfileProto_HardwareDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProto_HardwareDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProto_HardwareDefaultTypeInternal() {}
  union {
    SystemProfileProto_Hardware _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProto_HardwareDefaultTypeInternal _SystemProfileProto_Hardware_default_instance_;
PROTOBUF_CONSTEXPR SystemProfileProto_Network::SystemProfileProto_Network(
    ::_pbi::ConstantInitialized)
  : connection_type_(0)

  , connection_type_is_ambiguous_(false)
  , wifi_phy_layer_protocol_is_ambiguous_(false)
  , wifi_phy_layer_protocol_(0)

  , min_effective_connection_type_(0)

  , max_effective_connection_type_(0)
{}
struct SystemProfileProto_NetworkDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProto_NetworkDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProto_NetworkDefaultTypeInternal() {}
  union {
    SystemProfileProto_Network _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProto_NetworkDefaultTypeInternal _SystemProfileProto_Network_default_instance_;
PROTOBUF_CONSTEXPR SystemProfileProto_GoogleUpdate_ProductInfo::SystemProfileProto_GoogleUpdate_ProductInfo(
    ::_pbi::ConstantInitialized)
  : version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , last_update_success_timestamp_(int64_t{0})
  , last_result_(0)

  , last_error_(0)
  , last_extra_error_(0){}
struct SystemProfileProto_GoogleUpdate_ProductInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProto_GoogleUpdate_ProductInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProto_GoogleUpdate_ProductInfoDefaultTypeInternal() {}
  union {
    SystemProfileProto_GoogleUpdate_ProductInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProto_GoogleUpdate_ProductInfoDefaultTypeInternal _SystemProfileProto_GoogleUpdate_ProductInfo_default_instance_;
PROTOBUF_CONSTEXPR SystemProfileProto_GoogleUpdate::SystemProfileProto_GoogleUpdate(
    ::_pbi::ConstantInitialized)
  : google_update_status_(nullptr)
  , client_status_(nullptr)
  , last_automatic_start_timestamp_(int64_t{0})
  , last_update_check_timestamp_(int64_t{0})
  , is_system_install_(false){}
struct SystemProfileProto_GoogleUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProto_GoogleUpdateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProto_GoogleUpdateDefaultTypeInternal() {}
  union {
    SystemProfileProto_GoogleUpdate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProto_GoogleUpdateDefaultTypeInternal _SystemProfileProto_GoogleUpdate_default_instance_;
PROTOBUF_CONSTEXPR SystemProfileProto_Stability::SystemProfileProto_Stability(
    ::_pbi::ConstantInitialized)
  : incremental_uptime_sec_(int64_t{0})
  , page_load_count_(0)
  , other_user_crash_count_(0)
  , kernel_crash_count_(0)
  , unclean_system_shutdown_count_(0)
  , launch_count_(0)
  , renderer_launch_count_(0)
  , uptime_sec_(int64_t{0})
  , from_previous_run_(false)
  , crash_count_due_to_gms_core_update_(0){}
struct SystemProfileProto_StabilityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProto_StabilityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProto_StabilityDefaultTypeInternal() {}
  union {
    SystemProfileProto_Stability _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProto_StabilityDefaultTypeInternal _SystemProfileProto_Stability_default_instance_;
PROTOBUF_CONSTEXPR SystemProfileProto_FieldTrial::SystemProfileProto_FieldTrial(
    ::_pbi::ConstantInitialized)
  : name_id_(0u)
  , group_id_(0u){}
struct SystemProfileProto_FieldTrialDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProto_FieldTrialDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProto_FieldTrialDefaultTypeInternal() {}
  union {
    SystemProfileProto_FieldTrial _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProto_FieldTrialDefaultTypeInternal _SystemProfileProto_FieldTrial_default_instance_;
PROTOBUF_CONSTEXPR SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::SystemProfileProto_ExternalAudioVideoDevice_AudioDescription(
    ::_pbi::ConstantInitialized)
  : sample_frequency_hz_()
  , audio_format_(0)

  , num_channels_(0)
  , max_bit_rate_per_second_(0)
  , bit_depth_(0)
  , output_mode_(0)
{}
struct SystemProfileProto_ExternalAudioVideoDevice_AudioDescriptionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProto_ExternalAudioVideoDevice_AudioDescriptionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProto_ExternalAudioVideoDevice_AudioDescriptionDefaultTypeInternal() {}
  union {
    SystemProfileProto_ExternalAudioVideoDevice_AudioDescription _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProto_ExternalAudioVideoDevice_AudioDescriptionDefaultTypeInternal _SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_default_instance_;
PROTOBUF_CONSTEXPR SystemProfileProto_ExternalAudioVideoDevice_CECCommand::SystemProfileProto_ExternalAudioVideoDevice_CECCommand(
    ::_pbi::ConstantInitialized)
  : opcode_(0)
  , num_received_direct_(0)
  , num_received_broadcast_(0)
  , num_sent_direct_(0)
  , num_sent_broadcast_(0)
  , num_aborted_unknown_reason_(0)
  , num_aborted_unrecognized_(0){}
struct SystemProfileProto_ExternalAudioVideoDevice_CECCommandDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProto_ExternalAudioVideoDevice_CECCommandDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProto_ExternalAudioVideoDevice_CECCommandDefaultTypeInternal() {}
  union {
    SystemProfileProto_ExternalAudioVideoDevice_CECCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProto_ExternalAudioVideoDevice_CECCommandDefaultTypeInternal _SystemProfileProto_ExternalAudioVideoDevice_CECCommand_default_instance_;
PROTOBUF_CONSTEXPR SystemProfileProto_ExternalAudioVideoDevice::SystemProfileProto_ExternalAudioVideoDevice(
    ::_pbi::ConstantInitialized)
  : av_device_type_()
  , audio_description_()
  , cec_command_()
  , manufacturer_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , model_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , product_code_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , manufacture_year_(0)
  , manufacture_week_(0)
  , horizontal_resolution_(0)
  , vertical_resolution_(0)
  , position_in_setup_(0)
  , cec_version_(0)
  , frame_rate_(0)
  , color_encoding_(0)

  , bit_depth_(0)
  , tmds_(0)
  , is_in_path_to_tv_(false)
  , hdr10_support_(false)
  , dolby_vision_support_(false)
  , yuv_support_(false)
  , eotf_support_(0)
  , yuv_420_support_(false)
  , maximum_supported_hdcp_version_(0)
  , current_hdcp_version_(0){}
struct SystemProfileProto_ExternalAudioVideoDeviceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProto_ExternalAudioVideoDeviceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProto_ExternalAudioVideoDeviceDefaultTypeInternal() {}
  union {
    SystemProfileProto_ExternalAudioVideoDevice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProto_ExternalAudioVideoDeviceDefaultTypeInternal _SystemProfileProto_ExternalAudioVideoDevice_default_instance_;
PROTOBUF_CONSTEXPR SystemProfileProto_ExternalAccessPoint::SystemProfileProto_ExternalAccessPoint(
    ::_pbi::ConstantInitialized)
  : manufacturer_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , model_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , model_number_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , device_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct SystemProfileProto_ExternalAccessPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProto_ExternalAccessPointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProto_ExternalAccessPointDefaultTypeInternal() {}
  union {
    SystemProfileProto_ExternalAccessPoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProto_ExternalAccessPointDefaultTypeInternal _SystemProfileProto_ExternalAccessPoint_default_instance_;
PROTOBUF_CONSTEXPR SystemProfileProto_AntiVirusProduct::SystemProfileProto_AntiVirusProduct(
    ::_pbi::ConstantInitialized)
  : product_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , product_version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , product_name_hash_(0u)
  , product_version_hash_(0u)
  , product_state_(0)
{}
struct SystemProfileProto_AntiVirusProductDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProto_AntiVirusProductDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProto_AntiVirusProductDefaultTypeInternal() {}
  union {
    SystemProfileProto_AntiVirusProduct _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProto_AntiVirusProductDefaultTypeInternal _SystemProfileProto_AntiVirusProduct_default_instance_;
PROTOBUF_CONSTEXPR SystemProfileProto_ChromeComponent::SystemProfileProto_ChromeComponent(
    ::_pbi::ConstantInitialized)
  : version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , omaha_fingerprint_(0u)
  , cohort_hash_(0u)
  , component_id_(1)
{}
struct SystemProfileProto_ChromeComponentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProto_ChromeComponentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProto_ChromeComponentDefaultTypeInternal() {}
  union {
    SystemProfileProto_ChromeComponent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProto_ChromeComponentDefaultTypeInternal _SystemProfileProto_ChromeComponent_default_instance_;
PROTOBUF_CONSTEXPR SystemProfileProto_LinkedAndroidPhoneData::SystemProfileProto_LinkedAndroidPhoneData(
    ::_pbi::ConstantInitialized)
  : phone_model_name_hash_(0u)
  , is_smartlock_enabled_(false)
  , is_instant_tethering_enabled_(false)
  , is_messages_enabled_(false){}
struct SystemProfileProto_LinkedAndroidPhoneDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProto_LinkedAndroidPhoneDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProto_LinkedAndroidPhoneDataDefaultTypeInternal() {}
  union {
    SystemProfileProto_LinkedAndroidPhoneData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProto_LinkedAndroidPhoneDataDefaultTypeInternal _SystemProfileProto_LinkedAndroidPhoneData_default_instance_;
PROTOBUF_CONSTEXPR SystemProfileProto_DemoModeDimensions_Retailer::SystemProfileProto_DemoModeDimensions_Retailer(
    ::_pbi::ConstantInitialized)
  : retailer_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , store_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct SystemProfileProto_DemoModeDimensions_RetailerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProto_DemoModeDimensions_RetailerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProto_DemoModeDimensions_RetailerDefaultTypeInternal() {}
  union {
    SystemProfileProto_DemoModeDimensions_Retailer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProto_DemoModeDimensions_RetailerDefaultTypeInternal _SystemProfileProto_DemoModeDimensions_Retailer_default_instance_;
PROTOBUF_CONSTEXPR SystemProfileProto_DemoModeDimensions::SystemProfileProto_DemoModeDimensions(
    ::_pbi::ConstantInitialized)
  : customization_facet_()
  , _customization_facet_cached_byte_size_(0)
  , country_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , retailer_(nullptr){}
struct SystemProfileProto_DemoModeDimensionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProto_DemoModeDimensionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProto_DemoModeDimensionsDefaultTypeInternal() {}
  union {
    SystemProfileProto_DemoModeDimensions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProto_DemoModeDimensionsDefaultTypeInternal _SystemProfileProto_DemoModeDimensions_default_instance_;
PROTOBUF_CONSTEXPR SystemProfileProto::SystemProfileProto(
    ::_pbi::ConstantInitialized)
  : field_trial_()
  , external_audio_video_device_()
  , occupied_extension_bucket_()
  , antivirus_product_()
  , chrome_component_()
  , extension_install_()
  , command_line_key_hash_()
  , app_version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , application_locale_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , brand_code_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , app_package_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , variations_seed_version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , client_uuid_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , log_written_by_app_version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , os_(nullptr)
  , hardware_(nullptr)
  , stability_(nullptr)
  , google_update_(nullptr)
  , network_(nullptr)
  , external_access_point_(nullptr)
  , linked_android_phone_data_(nullptr)
  , cloned_install_info_(nullptr)
  , demo_mode_dimensions_(nullptr)
  , build_timestamp_(int64_t{0})
  , uma_enabled_date_(int64_t{0})
  , channel_(0)

  , multi_profile_user_count_(0u)
  , install_date_(int64_t{0})
  , offstore_extensions_state_(0)

  , uma_default_state_(0)

  , is_extended_stable_channel_(false)
  , is_instrumented_build_(false)
  , client_id_was_used_for_trial_assignment_(false)
  , low_entropy_source_(0)
  , old_low_entropy_source_(0)
  , installer_package_(0)

  , pseudo_low_entropy_source_(0)
  , app_package_name_allowlist_filter_(0)

  , client_side_sampling_status_(0)

  , metrics_filtering_status_(0)

  , lts_channel_(0)
{}
struct SystemProfileProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemProfileProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemProfileProtoDefaultTypeInternal() {}
  union {
    SystemProfileProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemProfileProtoDefaultTypeInternal _SystemProfileProto_default_instance_;
}  // namespace metrics
namespace metrics {
bool SystemProfileProto_OS_DarkModeState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_OS_DarkModeState_strings[5] = {};

static const char SystemProfileProto_OS_DarkModeState_names[] =
  "DARK_MODE_APP"
  "DARK_MODE_SYSTEM"
  "LIGHT_MODE_APP"
  "LIGHT_MODE_SYSTEM"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_OS_DarkModeState_entries[] = {
  { {SystemProfileProto_OS_DarkModeState_names + 0, 13}, 2 },
  { {SystemProfileProto_OS_DarkModeState_names + 13, 16}, 1 },
  { {SystemProfileProto_OS_DarkModeState_names + 29, 14}, 4 },
  { {SystemProfileProto_OS_DarkModeState_names + 43, 17}, 3 },
  { {SystemProfileProto_OS_DarkModeState_names + 60, 7}, 0 },
};

static const int SystemProfileProto_OS_DarkModeState_entries_by_number[] = {
  4, // 0 -> UNKNOWN
  1, // 1 -> DARK_MODE_SYSTEM
  0, // 2 -> DARK_MODE_APP
  3, // 3 -> LIGHT_MODE_SYSTEM
  2, // 4 -> LIGHT_MODE_APP
};

const std::string& SystemProfileProto_OS_DarkModeState_Name(
    SystemProfileProto_OS_DarkModeState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_OS_DarkModeState_entries,
          SystemProfileProto_OS_DarkModeState_entries_by_number,
          5, SystemProfileProto_OS_DarkModeState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_OS_DarkModeState_entries,
      SystemProfileProto_OS_DarkModeState_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_OS_DarkModeState_strings[idx].get();
}
bool SystemProfileProto_OS_DarkModeState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_OS_DarkModeState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_OS_DarkModeState_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_OS_DarkModeState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_OS_DarkModeState SystemProfileProto_OS::UNKNOWN;
constexpr SystemProfileProto_OS_DarkModeState SystemProfileProto_OS::DARK_MODE_SYSTEM;
constexpr SystemProfileProto_OS_DarkModeState SystemProfileProto_OS::DARK_MODE_APP;
constexpr SystemProfileProto_OS_DarkModeState SystemProfileProto_OS::LIGHT_MODE_SYSTEM;
constexpr SystemProfileProto_OS_DarkModeState SystemProfileProto_OS::LIGHT_MODE_APP;
constexpr SystemProfileProto_OS_DarkModeState SystemProfileProto_OS::DarkModeState_MIN;
constexpr SystemProfileProto_OS_DarkModeState SystemProfileProto_OS::DarkModeState_MAX;
constexpr int SystemProfileProto_OS::DarkModeState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_OS_XdgSessionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_OS_XdgSessionType_strings[7] = {};

static const char SystemProfileProto_OS_XdgSessionType_names[] =
  "MIR"
  "OTHER_SESSION_TYPE"
  "TTY"
  "UNSET"
  "UNSPECIFIED"
  "WAYLAND"
  "X11";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_OS_XdgSessionType_entries[] = {
  { {SystemProfileProto_OS_XdgSessionType_names + 0, 3}, 6 },
  { {SystemProfileProto_OS_XdgSessionType_names + 3, 18}, 1 },
  { {SystemProfileProto_OS_XdgSessionType_names + 21, 3}, 3 },
  { {SystemProfileProto_OS_XdgSessionType_names + 24, 5}, 0 },
  { {SystemProfileProto_OS_XdgSessionType_names + 29, 11}, 2 },
  { {SystemProfileProto_OS_XdgSessionType_names + 40, 7}, 5 },
  { {SystemProfileProto_OS_XdgSessionType_names + 47, 3}, 4 },
};

static const int SystemProfileProto_OS_XdgSessionType_entries_by_number[] = {
  3, // 0 -> UNSET
  1, // 1 -> OTHER_SESSION_TYPE
  4, // 2 -> UNSPECIFIED
  2, // 3 -> TTY
  6, // 4 -> X11
  5, // 5 -> WAYLAND
  0, // 6 -> MIR
};

const std::string& SystemProfileProto_OS_XdgSessionType_Name(
    SystemProfileProto_OS_XdgSessionType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_OS_XdgSessionType_entries,
          SystemProfileProto_OS_XdgSessionType_entries_by_number,
          7, SystemProfileProto_OS_XdgSessionType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_OS_XdgSessionType_entries,
      SystemProfileProto_OS_XdgSessionType_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_OS_XdgSessionType_strings[idx].get();
}
bool SystemProfileProto_OS_XdgSessionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_OS_XdgSessionType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_OS_XdgSessionType_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_OS_XdgSessionType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_OS_XdgSessionType SystemProfileProto_OS::UNSET;
constexpr SystemProfileProto_OS_XdgSessionType SystemProfileProto_OS::OTHER_SESSION_TYPE;
constexpr SystemProfileProto_OS_XdgSessionType SystemProfileProto_OS::UNSPECIFIED;
constexpr SystemProfileProto_OS_XdgSessionType SystemProfileProto_OS::TTY;
constexpr SystemProfileProto_OS_XdgSessionType SystemProfileProto_OS::X11;
constexpr SystemProfileProto_OS_XdgSessionType SystemProfileProto_OS::WAYLAND;
constexpr SystemProfileProto_OS_XdgSessionType SystemProfileProto_OS::MIR;
constexpr SystemProfileProto_OS_XdgSessionType SystemProfileProto_OS::XdgSessionType_MIN;
constexpr SystemProfileProto_OS_XdgSessionType SystemProfileProto_OS::XdgSessionType_MAX;
constexpr int SystemProfileProto_OS::XdgSessionType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_OS_XdgCurrentDesktop_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_OS_XdgCurrentDesktop_strings[10] = {};

static const char SystemProfileProto_OS_XdgCurrentDesktop_names[] =
  "CINNAMON"
  "DEEPIN"
  "GNOME"
  "KDE"
  "LXQT"
  "OTHER"
  "PANTHEON"
  "UKUI"
  "UNITY"
  "XFCE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_OS_XdgCurrentDesktop_entries[] = {
  { {SystemProfileProto_OS_XdgCurrentDesktop_names + 0, 8}, 1 },
  { {SystemProfileProto_OS_XdgCurrentDesktop_names + 8, 6}, 2 },
  { {SystemProfileProto_OS_XdgCurrentDesktop_names + 14, 5}, 3 },
  { {SystemProfileProto_OS_XdgCurrentDesktop_names + 19, 3}, 4 },
  { {SystemProfileProto_OS_XdgCurrentDesktop_names + 22, 4}, 9 },
  { {SystemProfileProto_OS_XdgCurrentDesktop_names + 26, 5}, 0 },
  { {SystemProfileProto_OS_XdgCurrentDesktop_names + 31, 8}, 5 },
  { {SystemProfileProto_OS_XdgCurrentDesktop_names + 39, 4}, 6 },
  { {SystemProfileProto_OS_XdgCurrentDesktop_names + 43, 5}, 7 },
  { {SystemProfileProto_OS_XdgCurrentDesktop_names + 48, 4}, 8 },
};

static const int SystemProfileProto_OS_XdgCurrentDesktop_entries_by_number[] = {
  5, // 0 -> OTHER
  0, // 1 -> CINNAMON
  1, // 2 -> DEEPIN
  2, // 3 -> GNOME
  3, // 4 -> KDE
  6, // 5 -> PANTHEON
  7, // 6 -> UKUI
  8, // 7 -> UNITY
  9, // 8 -> XFCE
  4, // 9 -> LXQT
};

const std::string& SystemProfileProto_OS_XdgCurrentDesktop_Name(
    SystemProfileProto_OS_XdgCurrentDesktop value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_OS_XdgCurrentDesktop_entries,
          SystemProfileProto_OS_XdgCurrentDesktop_entries_by_number,
          10, SystemProfileProto_OS_XdgCurrentDesktop_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_OS_XdgCurrentDesktop_entries,
      SystemProfileProto_OS_XdgCurrentDesktop_entries_by_number,
      10, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_OS_XdgCurrentDesktop_strings[idx].get();
}
bool SystemProfileProto_OS_XdgCurrentDesktop_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_OS_XdgCurrentDesktop* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_OS_XdgCurrentDesktop_entries, 10, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_OS_XdgCurrentDesktop>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_OS_XdgCurrentDesktop SystemProfileProto_OS::OTHER;
constexpr SystemProfileProto_OS_XdgCurrentDesktop SystemProfileProto_OS::CINNAMON;
constexpr SystemProfileProto_OS_XdgCurrentDesktop SystemProfileProto_OS::DEEPIN;
constexpr SystemProfileProto_OS_XdgCurrentDesktop SystemProfileProto_OS::GNOME;
constexpr SystemProfileProto_OS_XdgCurrentDesktop SystemProfileProto_OS::KDE;
constexpr SystemProfileProto_OS_XdgCurrentDesktop SystemProfileProto_OS::PANTHEON;
constexpr SystemProfileProto_OS_XdgCurrentDesktop SystemProfileProto_OS::UKUI;
constexpr SystemProfileProto_OS_XdgCurrentDesktop SystemProfileProto_OS::UNITY;
constexpr SystemProfileProto_OS_XdgCurrentDesktop SystemProfileProto_OS::XFCE;
constexpr SystemProfileProto_OS_XdgCurrentDesktop SystemProfileProto_OS::LXQT;
constexpr SystemProfileProto_OS_XdgCurrentDesktop SystemProfileProto_OS::XdgCurrentDesktop_MIN;
constexpr SystemProfileProto_OS_XdgCurrentDesktop SystemProfileProto_OS::XdgCurrentDesktop_MAX;
constexpr int SystemProfileProto_OS::XdgCurrentDesktop_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_Hardware_InternalStorageDevice_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_Hardware_InternalStorageDevice_Type_strings[5] = {};

static const char SystemProfileProto_Hardware_InternalStorageDevice_Type_names[] =
  "TYPE_EMMC"
  "TYPE_NVME"
  "TYPE_SD_EXPRESS_INTERNAL"
  "TYPE_UFS"
  "TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_Hardware_InternalStorageDevice_Type_entries[] = {
  { {SystemProfileProto_Hardware_InternalStorageDevice_Type_names + 0, 9}, 1 },
  { {SystemProfileProto_Hardware_InternalStorageDevice_Type_names + 9, 9}, 2 },
  { {SystemProfileProto_Hardware_InternalStorageDevice_Type_names + 18, 24}, 4 },
  { {SystemProfileProto_Hardware_InternalStorageDevice_Type_names + 42, 8}, 3 },
  { {SystemProfileProto_Hardware_InternalStorageDevice_Type_names + 50, 12}, 0 },
};

static const int SystemProfileProto_Hardware_InternalStorageDevice_Type_entries_by_number[] = {
  4, // 0 -> TYPE_UNKNOWN
  0, // 1 -> TYPE_EMMC
  1, // 2 -> TYPE_NVME
  3, // 3 -> TYPE_UFS
  2, // 4 -> TYPE_SD_EXPRESS_INTERNAL
};

const std::string& SystemProfileProto_Hardware_InternalStorageDevice_Type_Name(
    SystemProfileProto_Hardware_InternalStorageDevice_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_Hardware_InternalStorageDevice_Type_entries,
          SystemProfileProto_Hardware_InternalStorageDevice_Type_entries_by_number,
          5, SystemProfileProto_Hardware_InternalStorageDevice_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_Hardware_InternalStorageDevice_Type_entries,
      SystemProfileProto_Hardware_InternalStorageDevice_Type_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_Hardware_InternalStorageDevice_Type_strings[idx].get();
}
bool SystemProfileProto_Hardware_InternalStorageDevice_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_Hardware_InternalStorageDevice_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_Hardware_InternalStorageDevice_Type_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_Hardware_InternalStorageDevice_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_Hardware_InternalStorageDevice_Type SystemProfileProto_Hardware_InternalStorageDevice::TYPE_UNKNOWN;
constexpr SystemProfileProto_Hardware_InternalStorageDevice_Type SystemProfileProto_Hardware_InternalStorageDevice::TYPE_EMMC;
constexpr SystemProfileProto_Hardware_InternalStorageDevice_Type SystemProfileProto_Hardware_InternalStorageDevice::TYPE_NVME;
constexpr SystemProfileProto_Hardware_InternalStorageDevice_Type SystemProfileProto_Hardware_InternalStorageDevice::TYPE_UFS;
constexpr SystemProfileProto_Hardware_InternalStorageDevice_Type SystemProfileProto_Hardware_InternalStorageDevice::TYPE_SD_EXPRESS_INTERNAL;
constexpr SystemProfileProto_Hardware_InternalStorageDevice_Type SystemProfileProto_Hardware_InternalStorageDevice::Type_MIN;
constexpr SystemProfileProto_Hardware_InternalStorageDevice_Type SystemProfileProto_Hardware_InternalStorageDevice::Type_MAX;
constexpr int SystemProfileProto_Hardware_InternalStorageDevice::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_Hardware_InternalStorageDevice_Purpose_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_Hardware_InternalStorageDevice_Purpose_strings[4] = {};

static const char SystemProfileProto_Hardware_InternalStorageDevice_Purpose_names[] =
  "PURPOSE_BOOT"
  "PURPOSE_BOOT_SWAP"
  "PURPOSE_SWAP"
  "PURPOSE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_Hardware_InternalStorageDevice_Purpose_entries[] = {
  { {SystemProfileProto_Hardware_InternalStorageDevice_Purpose_names + 0, 12}, 1 },
  { {SystemProfileProto_Hardware_InternalStorageDevice_Purpose_names + 12, 17}, 3 },
  { {SystemProfileProto_Hardware_InternalStorageDevice_Purpose_names + 29, 12}, 2 },
  { {SystemProfileProto_Hardware_InternalStorageDevice_Purpose_names + 41, 15}, 0 },
};

static const int SystemProfileProto_Hardware_InternalStorageDevice_Purpose_entries_by_number[] = {
  3, // 0 -> PURPOSE_UNKNOWN
  0, // 1 -> PURPOSE_BOOT
  2, // 2 -> PURPOSE_SWAP
  1, // 3 -> PURPOSE_BOOT_SWAP
};

const std::string& SystemProfileProto_Hardware_InternalStorageDevice_Purpose_Name(
    SystemProfileProto_Hardware_InternalStorageDevice_Purpose value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_Hardware_InternalStorageDevice_Purpose_entries,
          SystemProfileProto_Hardware_InternalStorageDevice_Purpose_entries_by_number,
          4, SystemProfileProto_Hardware_InternalStorageDevice_Purpose_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_Hardware_InternalStorageDevice_Purpose_entries,
      SystemProfileProto_Hardware_InternalStorageDevice_Purpose_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_Hardware_InternalStorageDevice_Purpose_strings[idx].get();
}
bool SystemProfileProto_Hardware_InternalStorageDevice_Purpose_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_Hardware_InternalStorageDevice_Purpose* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_Hardware_InternalStorageDevice_Purpose_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_Hardware_InternalStorageDevice_Purpose>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_Hardware_InternalStorageDevice_Purpose SystemProfileProto_Hardware_InternalStorageDevice::PURPOSE_UNKNOWN;
constexpr SystemProfileProto_Hardware_InternalStorageDevice_Purpose SystemProfileProto_Hardware_InternalStorageDevice::PURPOSE_BOOT;
constexpr SystemProfileProto_Hardware_InternalStorageDevice_Purpose SystemProfileProto_Hardware_InternalStorageDevice::PURPOSE_SWAP;
constexpr SystemProfileProto_Hardware_InternalStorageDevice_Purpose SystemProfileProto_Hardware_InternalStorageDevice::PURPOSE_BOOT_SWAP;
constexpr SystemProfileProto_Hardware_InternalStorageDevice_Purpose SystemProfileProto_Hardware_InternalStorageDevice::Purpose_MIN;
constexpr SystemProfileProto_Hardware_InternalStorageDevice_Purpose SystemProfileProto_Hardware_InternalStorageDevice::Purpose_MAX;
constexpr int SystemProfileProto_Hardware_InternalStorageDevice::Purpose_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_Hardware_FormFactor_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_Hardware_FormFactor_strings[7] = {};

static const char SystemProfileProto_Hardware_FormFactor_names[] =
  "FORM_FACTOR_AUTOMOTIVE"
  "FORM_FACTOR_DESKTOP"
  "FORM_FACTOR_MEET_DEVICE"
  "FORM_FACTOR_PHONE"
  "FORM_FACTOR_TABLET"
  "FORM_FACTOR_TV"
  "FORM_FACTOR_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_Hardware_FormFactor_entries[] = {
  { {SystemProfileProto_Hardware_FormFactor_names + 0, 22}, 6 },
  { {SystemProfileProto_Hardware_FormFactor_names + 22, 19}, 1 },
  { {SystemProfileProto_Hardware_FormFactor_names + 41, 23}, 5 },
  { {SystemProfileProto_Hardware_FormFactor_names + 64, 17}, 2 },
  { {SystemProfileProto_Hardware_FormFactor_names + 81, 18}, 3 },
  { {SystemProfileProto_Hardware_FormFactor_names + 99, 14}, 4 },
  { {SystemProfileProto_Hardware_FormFactor_names + 113, 19}, 0 },
};

static const int SystemProfileProto_Hardware_FormFactor_entries_by_number[] = {
  6, // 0 -> FORM_FACTOR_UNKNOWN
  1, // 1 -> FORM_FACTOR_DESKTOP
  3, // 2 -> FORM_FACTOR_PHONE
  4, // 3 -> FORM_FACTOR_TABLET
  5, // 4 -> FORM_FACTOR_TV
  2, // 5 -> FORM_FACTOR_MEET_DEVICE
  0, // 6 -> FORM_FACTOR_AUTOMOTIVE
};

const std::string& SystemProfileProto_Hardware_FormFactor_Name(
    SystemProfileProto_Hardware_FormFactor value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_Hardware_FormFactor_entries,
          SystemProfileProto_Hardware_FormFactor_entries_by_number,
          7, SystemProfileProto_Hardware_FormFactor_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_Hardware_FormFactor_entries,
      SystemProfileProto_Hardware_FormFactor_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_Hardware_FormFactor_strings[idx].get();
}
bool SystemProfileProto_Hardware_FormFactor_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_Hardware_FormFactor* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_Hardware_FormFactor_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_Hardware_FormFactor>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_Hardware_FormFactor SystemProfileProto_Hardware::FORM_FACTOR_UNKNOWN;
constexpr SystemProfileProto_Hardware_FormFactor SystemProfileProto_Hardware::FORM_FACTOR_DESKTOP;
constexpr SystemProfileProto_Hardware_FormFactor SystemProfileProto_Hardware::FORM_FACTOR_PHONE;
constexpr SystemProfileProto_Hardware_FormFactor SystemProfileProto_Hardware::FORM_FACTOR_TABLET;
constexpr SystemProfileProto_Hardware_FormFactor SystemProfileProto_Hardware::FORM_FACTOR_TV;
constexpr SystemProfileProto_Hardware_FormFactor SystemProfileProto_Hardware::FORM_FACTOR_MEET_DEVICE;
constexpr SystemProfileProto_Hardware_FormFactor SystemProfileProto_Hardware::FORM_FACTOR_AUTOMOTIVE;
constexpr SystemProfileProto_Hardware_FormFactor SystemProfileProto_Hardware::FormFactor_MIN;
constexpr SystemProfileProto_Hardware_FormFactor SystemProfileProto_Hardware::FormFactor_MAX;
constexpr int SystemProfileProto_Hardware::FormFactor_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_Hardware_BiosType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_Hardware_BiosType_strings[3] = {};

static const char SystemProfileProto_Hardware_BiosType_names[] =
  "BIOS_TYPE_LEGACY"
  "BIOS_TYPE_UEFI"
  "BIOS_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_Hardware_BiosType_entries[] = {
  { {SystemProfileProto_Hardware_BiosType_names + 0, 16}, 1 },
  { {SystemProfileProto_Hardware_BiosType_names + 16, 14}, 2 },
  { {SystemProfileProto_Hardware_BiosType_names + 30, 17}, 0 },
};

static const int SystemProfileProto_Hardware_BiosType_entries_by_number[] = {
  2, // 0 -> BIOS_TYPE_UNKNOWN
  0, // 1 -> BIOS_TYPE_LEGACY
  1, // 2 -> BIOS_TYPE_UEFI
};

const std::string& SystemProfileProto_Hardware_BiosType_Name(
    SystemProfileProto_Hardware_BiosType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_Hardware_BiosType_entries,
          SystemProfileProto_Hardware_BiosType_entries_by_number,
          3, SystemProfileProto_Hardware_BiosType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_Hardware_BiosType_entries,
      SystemProfileProto_Hardware_BiosType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_Hardware_BiosType_strings[idx].get();
}
bool SystemProfileProto_Hardware_BiosType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_Hardware_BiosType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_Hardware_BiosType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_Hardware_BiosType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_Hardware_BiosType SystemProfileProto_Hardware::BIOS_TYPE_UNKNOWN;
constexpr SystemProfileProto_Hardware_BiosType SystemProfileProto_Hardware::BIOS_TYPE_LEGACY;
constexpr SystemProfileProto_Hardware_BiosType SystemProfileProto_Hardware::BIOS_TYPE_UEFI;
constexpr SystemProfileProto_Hardware_BiosType SystemProfileProto_Hardware::BiosType_MIN;
constexpr SystemProfileProto_Hardware_BiosType SystemProfileProto_Hardware::BiosType_MAX;
constexpr int SystemProfileProto_Hardware::BiosType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_Hardware_TpmType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_Hardware_TpmType_strings[6] = {};

static const char SystemProfileProto_Hardware_TpmType_names[] =
  "TPM_TYPE_1"
  "TPM_TYPE_CR50"
  "TPM_TYPE_GENERIC_2"
  "TPM_TYPE_RUNTIME_SELECTION"
  "TPM_TYPE_TI50"
  "TPM_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_Hardware_TpmType_entries[] = {
  { {SystemProfileProto_Hardware_TpmType_names + 0, 10}, 1 },
  { {SystemProfileProto_Hardware_TpmType_names + 10, 13}, 2 },
  { {SystemProfileProto_Hardware_TpmType_names + 23, 18}, 5 },
  { {SystemProfileProto_Hardware_TpmType_names + 41, 26}, 4 },
  { {SystemProfileProto_Hardware_TpmType_names + 67, 13}, 3 },
  { {SystemProfileProto_Hardware_TpmType_names + 80, 16}, 0 },
};

static const int SystemProfileProto_Hardware_TpmType_entries_by_number[] = {
  5, // 0 -> TPM_TYPE_UNKNOWN
  0, // 1 -> TPM_TYPE_1
  1, // 2 -> TPM_TYPE_CR50
  4, // 3 -> TPM_TYPE_TI50
  3, // 4 -> TPM_TYPE_RUNTIME_SELECTION
  2, // 5 -> TPM_TYPE_GENERIC_2
};

const std::string& SystemProfileProto_Hardware_TpmType_Name(
    SystemProfileProto_Hardware_TpmType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_Hardware_TpmType_entries,
          SystemProfileProto_Hardware_TpmType_entries_by_number,
          6, SystemProfileProto_Hardware_TpmType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_Hardware_TpmType_entries,
      SystemProfileProto_Hardware_TpmType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_Hardware_TpmType_strings[idx].get();
}
bool SystemProfileProto_Hardware_TpmType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_Hardware_TpmType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_Hardware_TpmType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_Hardware_TpmType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_Hardware_TpmType SystemProfileProto_Hardware::TPM_TYPE_UNKNOWN;
constexpr SystemProfileProto_Hardware_TpmType SystemProfileProto_Hardware::TPM_TYPE_1;
constexpr SystemProfileProto_Hardware_TpmType SystemProfileProto_Hardware::TPM_TYPE_CR50;
constexpr SystemProfileProto_Hardware_TpmType SystemProfileProto_Hardware::TPM_TYPE_TI50;
constexpr SystemProfileProto_Hardware_TpmType SystemProfileProto_Hardware::TPM_TYPE_RUNTIME_SELECTION;
constexpr SystemProfileProto_Hardware_TpmType SystemProfileProto_Hardware::TPM_TYPE_GENERIC_2;
constexpr SystemProfileProto_Hardware_TpmType SystemProfileProto_Hardware::TpmType_MIN;
constexpr SystemProfileProto_Hardware_TpmType SystemProfileProto_Hardware::TpmType_MAX;
constexpr int SystemProfileProto_Hardware::TpmType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_Network_ConnectionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_Network_ConnectionType_strings[10] = {};

static const char SystemProfileProto_Network_ConnectionType_names[] =
  "CONNECTION_2G"
  "CONNECTION_3G"
  "CONNECTION_4G"
  "CONNECTION_5G"
  "CONNECTION_AMBIGUOUS"
  "CONNECTION_BLUETOOTH"
  "CONNECTION_ETHERNET"
  "CONNECTION_NONE"
  "CONNECTION_UNKNOWN"
  "CONNECTION_WIFI";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_Network_ConnectionType_entries[] = {
  { {SystemProfileProto_Network_ConnectionType_names + 0, 13}, 3 },
  { {SystemProfileProto_Network_ConnectionType_names + 13, 13}, 4 },
  { {SystemProfileProto_Network_ConnectionType_names + 26, 13}, 5 },
  { {SystemProfileProto_Network_ConnectionType_names + 39, 13}, 9 },
  { {SystemProfileProto_Network_ConnectionType_names + 52, 20}, 8 },
  { {SystemProfileProto_Network_ConnectionType_names + 72, 20}, 6 },
  { {SystemProfileProto_Network_ConnectionType_names + 92, 19}, 1 },
  { {SystemProfileProto_Network_ConnectionType_names + 111, 15}, 7 },
  { {SystemProfileProto_Network_ConnectionType_names + 126, 18}, 0 },
  { {SystemProfileProto_Network_ConnectionType_names + 144, 15}, 2 },
};

static const int SystemProfileProto_Network_ConnectionType_entries_by_number[] = {
  8, // 0 -> CONNECTION_UNKNOWN
  6, // 1 -> CONNECTION_ETHERNET
  9, // 2 -> CONNECTION_WIFI
  0, // 3 -> CONNECTION_2G
  1, // 4 -> CONNECTION_3G
  2, // 5 -> CONNECTION_4G
  5, // 6 -> CONNECTION_BLUETOOTH
  7, // 7 -> CONNECTION_NONE
  4, // 8 -> CONNECTION_AMBIGUOUS
  3, // 9 -> CONNECTION_5G
};

const std::string& SystemProfileProto_Network_ConnectionType_Name(
    SystemProfileProto_Network_ConnectionType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_Network_ConnectionType_entries,
          SystemProfileProto_Network_ConnectionType_entries_by_number,
          10, SystemProfileProto_Network_ConnectionType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_Network_ConnectionType_entries,
      SystemProfileProto_Network_ConnectionType_entries_by_number,
      10, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_Network_ConnectionType_strings[idx].get();
}
bool SystemProfileProto_Network_ConnectionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_Network_ConnectionType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_Network_ConnectionType_entries, 10, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_Network_ConnectionType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_Network_ConnectionType SystemProfileProto_Network::CONNECTION_UNKNOWN;
constexpr SystemProfileProto_Network_ConnectionType SystemProfileProto_Network::CONNECTION_ETHERNET;
constexpr SystemProfileProto_Network_ConnectionType SystemProfileProto_Network::CONNECTION_WIFI;
constexpr SystemProfileProto_Network_ConnectionType SystemProfileProto_Network::CONNECTION_2G;
constexpr SystemProfileProto_Network_ConnectionType SystemProfileProto_Network::CONNECTION_3G;
constexpr SystemProfileProto_Network_ConnectionType SystemProfileProto_Network::CONNECTION_4G;
constexpr SystemProfileProto_Network_ConnectionType SystemProfileProto_Network::CONNECTION_BLUETOOTH;
constexpr SystemProfileProto_Network_ConnectionType SystemProfileProto_Network::CONNECTION_NONE;
constexpr SystemProfileProto_Network_ConnectionType SystemProfileProto_Network::CONNECTION_AMBIGUOUS;
constexpr SystemProfileProto_Network_ConnectionType SystemProfileProto_Network::CONNECTION_5G;
constexpr SystemProfileProto_Network_ConnectionType SystemProfileProto_Network::ConnectionType_MIN;
constexpr SystemProfileProto_Network_ConnectionType SystemProfileProto_Network::ConnectionType_MAX;
constexpr int SystemProfileProto_Network::ConnectionType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_Network_WifiPHYLayerProtocol_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_Network_WifiPHYLayerProtocol_strings[10] = {};

static const char SystemProfileProto_Network_WifiPHYLayerProtocol_names[] =
  "WIFI_PHY_LAYER_PROTOCOL_A"
  "WIFI_PHY_LAYER_PROTOCOL_AC"
  "WIFI_PHY_LAYER_PROTOCOL_AD"
  "WIFI_PHY_LAYER_PROTOCOL_ANCIENT"
  "WIFI_PHY_LAYER_PROTOCOL_AX"
  "WIFI_PHY_LAYER_PROTOCOL_B"
  "WIFI_PHY_LAYER_PROTOCOL_G"
  "WIFI_PHY_LAYER_PROTOCOL_N"
  "WIFI_PHY_LAYER_PROTOCOL_NONE"
  "WIFI_PHY_LAYER_PROTOCOL_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_Network_WifiPHYLayerProtocol_entries[] = {
  { {SystemProfileProto_Network_WifiPHYLayerProtocol_names + 0, 25}, 2 },
  { {SystemProfileProto_Network_WifiPHYLayerProtocol_names + 25, 26}, 7 },
  { {SystemProfileProto_Network_WifiPHYLayerProtocol_names + 51, 26}, 8 },
  { {SystemProfileProto_Network_WifiPHYLayerProtocol_names + 77, 31}, 1 },
  { {SystemProfileProto_Network_WifiPHYLayerProtocol_names + 108, 26}, 9 },
  { {SystemProfileProto_Network_WifiPHYLayerProtocol_names + 134, 25}, 3 },
  { {SystemProfileProto_Network_WifiPHYLayerProtocol_names + 159, 25}, 4 },
  { {SystemProfileProto_Network_WifiPHYLayerProtocol_names + 184, 25}, 5 },
  { {SystemProfileProto_Network_WifiPHYLayerProtocol_names + 209, 28}, 0 },
  { {SystemProfileProto_Network_WifiPHYLayerProtocol_names + 237, 31}, 6 },
};

static const int SystemProfileProto_Network_WifiPHYLayerProtocol_entries_by_number[] = {
  8, // 0 -> WIFI_PHY_LAYER_PROTOCOL_NONE
  3, // 1 -> WIFI_PHY_LAYER_PROTOCOL_ANCIENT
  0, // 2 -> WIFI_PHY_LAYER_PROTOCOL_A
  5, // 3 -> WIFI_PHY_LAYER_PROTOCOL_B
  6, // 4 -> WIFI_PHY_LAYER_PROTOCOL_G
  7, // 5 -> WIFI_PHY_LAYER_PROTOCOL_N
  9, // 6 -> WIFI_PHY_LAYER_PROTOCOL_UNKNOWN
  1, // 7 -> WIFI_PHY_LAYER_PROTOCOL_AC
  2, // 8 -> WIFI_PHY_LAYER_PROTOCOL_AD
  4, // 9 -> WIFI_PHY_LAYER_PROTOCOL_AX
};

const std::string& SystemProfileProto_Network_WifiPHYLayerProtocol_Name(
    SystemProfileProto_Network_WifiPHYLayerProtocol value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_Network_WifiPHYLayerProtocol_entries,
          SystemProfileProto_Network_WifiPHYLayerProtocol_entries_by_number,
          10, SystemProfileProto_Network_WifiPHYLayerProtocol_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_Network_WifiPHYLayerProtocol_entries,
      SystemProfileProto_Network_WifiPHYLayerProtocol_entries_by_number,
      10, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_Network_WifiPHYLayerProtocol_strings[idx].get();
}
bool SystemProfileProto_Network_WifiPHYLayerProtocol_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_Network_WifiPHYLayerProtocol* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_Network_WifiPHYLayerProtocol_entries, 10, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_Network_WifiPHYLayerProtocol>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_Network_WifiPHYLayerProtocol SystemProfileProto_Network::WIFI_PHY_LAYER_PROTOCOL_NONE;
constexpr SystemProfileProto_Network_WifiPHYLayerProtocol SystemProfileProto_Network::WIFI_PHY_LAYER_PROTOCOL_ANCIENT;
constexpr SystemProfileProto_Network_WifiPHYLayerProtocol SystemProfileProto_Network::WIFI_PHY_LAYER_PROTOCOL_A;
constexpr SystemProfileProto_Network_WifiPHYLayerProtocol SystemProfileProto_Network::WIFI_PHY_LAYER_PROTOCOL_B;
constexpr SystemProfileProto_Network_WifiPHYLayerProtocol SystemProfileProto_Network::WIFI_PHY_LAYER_PROTOCOL_G;
constexpr SystemProfileProto_Network_WifiPHYLayerProtocol SystemProfileProto_Network::WIFI_PHY_LAYER_PROTOCOL_N;
constexpr SystemProfileProto_Network_WifiPHYLayerProtocol SystemProfileProto_Network::WIFI_PHY_LAYER_PROTOCOL_UNKNOWN;
constexpr SystemProfileProto_Network_WifiPHYLayerProtocol SystemProfileProto_Network::WIFI_PHY_LAYER_PROTOCOL_AC;
constexpr SystemProfileProto_Network_WifiPHYLayerProtocol SystemProfileProto_Network::WIFI_PHY_LAYER_PROTOCOL_AD;
constexpr SystemProfileProto_Network_WifiPHYLayerProtocol SystemProfileProto_Network::WIFI_PHY_LAYER_PROTOCOL_AX;
constexpr SystemProfileProto_Network_WifiPHYLayerProtocol SystemProfileProto_Network::WifiPHYLayerProtocol_MIN;
constexpr SystemProfileProto_Network_WifiPHYLayerProtocol SystemProfileProto_Network::WifiPHYLayerProtocol_MAX;
constexpr int SystemProfileProto_Network::WifiPHYLayerProtocol_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_Network_EffectiveConnectionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_Network_EffectiveConnectionType_strings[7] = {};

static const char SystemProfileProto_Network_EffectiveConnectionType_names[] =
  "DEPRECATED_EFFECTIVE_CONNECTION_TYPE_AMBIGUOUS"
  "EFFECTIVE_CONNECTION_TYPE_2G"
  "EFFECTIVE_CONNECTION_TYPE_3G"
  "EFFECTIVE_CONNECTION_TYPE_4G"
  "EFFECTIVE_CONNECTION_TYPE_OFFLINE"
  "EFFECTIVE_CONNECTION_TYPE_SLOW_2G"
  "EFFECTIVE_CONNECTION_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_Network_EffectiveConnectionType_entries[] = {
  { {SystemProfileProto_Network_EffectiveConnectionType_names + 0, 46}, 1 },
  { {SystemProfileProto_Network_EffectiveConnectionType_names + 46, 28}, 4 },
  { {SystemProfileProto_Network_EffectiveConnectionType_names + 74, 28}, 5 },
  { {SystemProfileProto_Network_EffectiveConnectionType_names + 102, 28}, 6 },
  { {SystemProfileProto_Network_EffectiveConnectionType_names + 130, 33}, 2 },
  { {SystemProfileProto_Network_EffectiveConnectionType_names + 163, 33}, 3 },
  { {SystemProfileProto_Network_EffectiveConnectionType_names + 196, 33}, 0 },
};

static const int SystemProfileProto_Network_EffectiveConnectionType_entries_by_number[] = {
  6, // 0 -> EFFECTIVE_CONNECTION_TYPE_UNKNOWN
  0, // 1 -> DEPRECATED_EFFECTIVE_CONNECTION_TYPE_AMBIGUOUS
  4, // 2 -> EFFECTIVE_CONNECTION_TYPE_OFFLINE
  5, // 3 -> EFFECTIVE_CONNECTION_TYPE_SLOW_2G
  1, // 4 -> EFFECTIVE_CONNECTION_TYPE_2G
  2, // 5 -> EFFECTIVE_CONNECTION_TYPE_3G
  3, // 6 -> EFFECTIVE_CONNECTION_TYPE_4G
};

const std::string& SystemProfileProto_Network_EffectiveConnectionType_Name(
    SystemProfileProto_Network_EffectiveConnectionType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_Network_EffectiveConnectionType_entries,
          SystemProfileProto_Network_EffectiveConnectionType_entries_by_number,
          7, SystemProfileProto_Network_EffectiveConnectionType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_Network_EffectiveConnectionType_entries,
      SystemProfileProto_Network_EffectiveConnectionType_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_Network_EffectiveConnectionType_strings[idx].get();
}
bool SystemProfileProto_Network_EffectiveConnectionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_Network_EffectiveConnectionType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_Network_EffectiveConnectionType_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_Network_EffectiveConnectionType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_Network_EffectiveConnectionType SystemProfileProto_Network::EFFECTIVE_CONNECTION_TYPE_UNKNOWN;
constexpr SystemProfileProto_Network_EffectiveConnectionType SystemProfileProto_Network::DEPRECATED_EFFECTIVE_CONNECTION_TYPE_AMBIGUOUS;
constexpr SystemProfileProto_Network_EffectiveConnectionType SystemProfileProto_Network::EFFECTIVE_CONNECTION_TYPE_OFFLINE;
constexpr SystemProfileProto_Network_EffectiveConnectionType SystemProfileProto_Network::EFFECTIVE_CONNECTION_TYPE_SLOW_2G;
constexpr SystemProfileProto_Network_EffectiveConnectionType SystemProfileProto_Network::EFFECTIVE_CONNECTION_TYPE_2G;
constexpr SystemProfileProto_Network_EffectiveConnectionType SystemProfileProto_Network::EFFECTIVE_CONNECTION_TYPE_3G;
constexpr SystemProfileProto_Network_EffectiveConnectionType SystemProfileProto_Network::EFFECTIVE_CONNECTION_TYPE_4G;
constexpr SystemProfileProto_Network_EffectiveConnectionType SystemProfileProto_Network::EffectiveConnectionType_MIN;
constexpr SystemProfileProto_Network_EffectiveConnectionType SystemProfileProto_Network::EffectiveConnectionType_MAX;
constexpr int SystemProfileProto_Network::EffectiveConnectionType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult_strings[5] = {};

static const char SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult_names[] =
  "INSTALL_RESULT_EXIT_CODE"
  "INSTALL_RESULT_FAILED_CUSTOM_ERROR"
  "INSTALL_RESULT_FAILED_MSI_ERROR"
  "INSTALL_RESULT_FAILED_SYSTEM_ERROR"
  "INSTALL_RESULT_SUCCESS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult_entries[] = {
  { {SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult_names + 0, 24}, 4 },
  { {SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult_names + 24, 34}, 1 },
  { {SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult_names + 58, 31}, 2 },
  { {SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult_names + 89, 34}, 3 },
  { {SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult_names + 123, 22}, 0 },
};

static const int SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult_entries_by_number[] = {
  4, // 0 -> INSTALL_RESULT_SUCCESS
  1, // 1 -> INSTALL_RESULT_FAILED_CUSTOM_ERROR
  2, // 2 -> INSTALL_RESULT_FAILED_MSI_ERROR
  3, // 3 -> INSTALL_RESULT_FAILED_SYSTEM_ERROR
  0, // 4 -> INSTALL_RESULT_EXIT_CODE
};

const std::string& SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult_Name(
    SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult_entries,
          SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult_entries_by_number,
          5, SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult_entries,
      SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult_strings[idx].get();
}
bool SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult SystemProfileProto_GoogleUpdate_ProductInfo::INSTALL_RESULT_SUCCESS;
constexpr SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult SystemProfileProto_GoogleUpdate_ProductInfo::INSTALL_RESULT_FAILED_CUSTOM_ERROR;
constexpr SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult SystemProfileProto_GoogleUpdate_ProductInfo::INSTALL_RESULT_FAILED_MSI_ERROR;
constexpr SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult SystemProfileProto_GoogleUpdate_ProductInfo::INSTALL_RESULT_FAILED_SYSTEM_ERROR;
constexpr SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult SystemProfileProto_GoogleUpdate_ProductInfo::INSTALL_RESULT_EXIT_CODE;
constexpr SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult SystemProfileProto_GoogleUpdate_ProductInfo::InstallResult_MIN;
constexpr SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult SystemProfileProto_GoogleUpdate_ProductInfo::InstallResult_MAX;
constexpr int SystemProfileProto_GoogleUpdate_ProductInfo::InstallResult_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_strings[15] = {};

static const char SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_names[] =
  "AUDIO_FORMAT_AAC"
  "AUDIO_FORMAT_AC_3"
  "AUDIO_FORMAT_ATRAC"
  "AUDIO_FORMAT_DD_PLUS"
  "AUDIO_FORMAT_DST_AUDIO"
  "AUDIO_FORMAT_DTS"
  "AUDIO_FORMAT_DTS_HD"
  "AUDIO_FORMAT_LPCM"
  "AUDIO_FORMAT_MICROSOFT_WMA_PRO"
  "AUDIO_FORMAT_MLP_DOLBY_TRUEHD"
  "AUDIO_FORMAT_MP3"
  "AUDIO_FORMAT_MPEG1"
  "AUDIO_FORMAT_MPEG2"
  "AUDIO_FORMAT_ONE_BIT"
  "AUDIO_FORMAT_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_entries[] = {
  { {SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_names + 0, 16}, 6 },
  { {SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_names + 16, 17}, 2 },
  { {SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_names + 33, 18}, 8 },
  { {SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_names + 51, 20}, 10 },
  { {SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_names + 71, 22}, 13 },
  { {SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_names + 93, 16}, 7 },
  { {SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_names + 109, 19}, 11 },
  { {SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_names + 128, 17}, 1 },
  { {SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_names + 145, 30}, 14 },
  { {SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_names + 175, 29}, 12 },
  { {SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_names + 204, 16}, 4 },
  { {SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_names + 220, 18}, 3 },
  { {SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_names + 238, 18}, 5 },
  { {SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_names + 256, 20}, 9 },
  { {SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_names + 276, 20}, 0 },
};

static const int SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_entries_by_number[] = {
  14, // 0 -> AUDIO_FORMAT_UNKNOWN
  7, // 1 -> AUDIO_FORMAT_LPCM
  1, // 2 -> AUDIO_FORMAT_AC_3
  11, // 3 -> AUDIO_FORMAT_MPEG1
  10, // 4 -> AUDIO_FORMAT_MP3
  12, // 5 -> AUDIO_FORMAT_MPEG2
  0, // 6 -> AUDIO_FORMAT_AAC
  5, // 7 -> AUDIO_FORMAT_DTS
  2, // 8 -> AUDIO_FORMAT_ATRAC
  13, // 9 -> AUDIO_FORMAT_ONE_BIT
  3, // 10 -> AUDIO_FORMAT_DD_PLUS
  6, // 11 -> AUDIO_FORMAT_DTS_HD
  9, // 12 -> AUDIO_FORMAT_MLP_DOLBY_TRUEHD
  4, // 13 -> AUDIO_FORMAT_DST_AUDIO
  8, // 14 -> AUDIO_FORMAT_MICROSOFT_WMA_PRO
};

const std::string& SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_Name(
    SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_entries,
          SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_entries_by_number,
          15, SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_entries,
      SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_entries_by_number,
      15, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_strings[idx].get();
}
bool SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_entries, 15, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::AUDIO_FORMAT_UNKNOWN;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::AUDIO_FORMAT_LPCM;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::AUDIO_FORMAT_AC_3;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::AUDIO_FORMAT_MPEG1;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::AUDIO_FORMAT_MP3;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::AUDIO_FORMAT_MPEG2;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::AUDIO_FORMAT_AAC;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::AUDIO_FORMAT_DTS;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::AUDIO_FORMAT_ATRAC;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::AUDIO_FORMAT_ONE_BIT;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::AUDIO_FORMAT_DD_PLUS;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::AUDIO_FORMAT_DTS_HD;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::AUDIO_FORMAT_MLP_DOLBY_TRUEHD;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::AUDIO_FORMAT_DST_AUDIO;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::AUDIO_FORMAT_MICROSOFT_WMA_PRO;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::AudioFormat_MIN;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::AudioFormat_MAX;
constexpr int SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::AudioFormat_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode_strings[2] = {};

static const char SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode_names[] =
  "ANALOG"
  "DIGITAL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode_entries[] = {
  { {SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode_names + 0, 6}, 0 },
  { {SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode_names + 6, 7}, 1 },
};

static const int SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode_entries_by_number[] = {
  0, // 0 -> ANALOG
  1, // 1 -> DIGITAL
};

const std::string& SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode_Name(
    SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode_entries,
          SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode_entries_by_number,
          2, SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode_entries,
      SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode_strings[idx].get();
}
bool SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::ANALOG;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::DIGITAL;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::OutputMode_MIN;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::OutputMode_MAX;
constexpr int SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::OutputMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType_strings[6] = {};

static const char SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType_names[] =
  "AV_DEVICE_TYPE_AUDIO_SYSTEM"
  "AV_DEVICE_TYPE_PLAYER"
  "AV_DEVICE_TYPE_RECORDER"
  "AV_DEVICE_TYPE_TUNER"
  "AV_DEVICE_TYPE_TV"
  "AV_DEVICE_TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType_entries[] = {
  { {SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType_names + 0, 27}, 5 },
  { {SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType_names + 27, 21}, 4 },
  { {SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType_names + 48, 23}, 2 },
  { {SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType_names + 71, 20}, 3 },
  { {SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType_names + 91, 17}, 1 },
  { {SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType_names + 108, 22}, 0 },
};

static const int SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType_entries_by_number[] = {
  5, // 0 -> AV_DEVICE_TYPE_UNKNOWN
  4, // 1 -> AV_DEVICE_TYPE_TV
  2, // 2 -> AV_DEVICE_TYPE_RECORDER
  3, // 3 -> AV_DEVICE_TYPE_TUNER
  1, // 4 -> AV_DEVICE_TYPE_PLAYER
  0, // 5 -> AV_DEVICE_TYPE_AUDIO_SYSTEM
};

const std::string& SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType_Name(
    SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType_entries,
          SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType_entries_by_number,
          6, SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType_entries,
      SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType_strings[idx].get();
}
bool SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType SystemProfileProto_ExternalAudioVideoDevice::AV_DEVICE_TYPE_UNKNOWN;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType SystemProfileProto_ExternalAudioVideoDevice::AV_DEVICE_TYPE_TV;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType SystemProfileProto_ExternalAudioVideoDevice::AV_DEVICE_TYPE_RECORDER;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType SystemProfileProto_ExternalAudioVideoDevice::AV_DEVICE_TYPE_TUNER;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType SystemProfileProto_ExternalAudioVideoDevice::AV_DEVICE_TYPE_PLAYER;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType SystemProfileProto_ExternalAudioVideoDevice::AV_DEVICE_TYPE_AUDIO_SYSTEM;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType SystemProfileProto_ExternalAudioVideoDevice::AVDeviceType_MIN;
constexpr SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType SystemProfileProto_ExternalAudioVideoDevice::AVDeviceType_MAX;
constexpr int SystemProfileProto_ExternalAudioVideoDevice::AVDeviceType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding_strings[5] = {};

static const char SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding_names[] =
  "COLOR_ENCODING_RGB"
  "COLOR_ENCODING_UNKNOWN"
  "COLOR_ENCODING_YUV420"
  "COLOR_ENCODING_YUV422"
  "COLOR_ENCODING_YUV444";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding_entries[] = {
  { {SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding_names + 0, 18}, 1 },
  { {SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding_names + 18, 22}, 0 },
  { {SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding_names + 40, 21}, 4 },
  { {SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding_names + 61, 21}, 3 },
  { {SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding_names + 82, 21}, 2 },
};

static const int SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding_entries_by_number[] = {
  1, // 0 -> COLOR_ENCODING_UNKNOWN
  0, // 1 -> COLOR_ENCODING_RGB
  4, // 2 -> COLOR_ENCODING_YUV444
  3, // 3 -> COLOR_ENCODING_YUV422
  2, // 4 -> COLOR_ENCODING_YUV420
};

const std::string& SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding_Name(
    SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding_entries,
          SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding_entries_by_number,
          5, SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding_entries,
      SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding_strings[idx].get();
}
bool SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding SystemProfileProto_ExternalAudioVideoDevice::COLOR_ENCODING_UNKNOWN;
constexpr SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding SystemProfileProto_ExternalAudioVideoDevice::COLOR_ENCODING_RGB;
constexpr SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding SystemProfileProto_ExternalAudioVideoDevice::COLOR_ENCODING_YUV444;
constexpr SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding SystemProfileProto_ExternalAudioVideoDevice::COLOR_ENCODING_YUV422;
constexpr SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding SystemProfileProto_ExternalAudioVideoDevice::COLOR_ENCODING_YUV420;
constexpr SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding SystemProfileProto_ExternalAudioVideoDevice::ColorEncoding_MIN;
constexpr SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding SystemProfileProto_ExternalAudioVideoDevice::ColorEncoding_MAX;
constexpr int SystemProfileProto_ExternalAudioVideoDevice::ColorEncoding_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_DemoModeDimensions_CustomizationFacet_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_DemoModeDimensions_CustomizationFacet_strings[3] = {};

static const char SystemProfileProto_DemoModeDimensions_CustomizationFacet_names[] =
  "CLOUD_GAMING_DEVICE"
  "FEATURE_AWARE_DEVICE"
  "UNDEFINED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_DemoModeDimensions_CustomizationFacet_entries[] = {
  { {SystemProfileProto_DemoModeDimensions_CustomizationFacet_names + 0, 19}, 1 },
  { {SystemProfileProto_DemoModeDimensions_CustomizationFacet_names + 19, 20}, 2 },
  { {SystemProfileProto_DemoModeDimensions_CustomizationFacet_names + 39, 9}, 0 },
};

static const int SystemProfileProto_DemoModeDimensions_CustomizationFacet_entries_by_number[] = {
  2, // 0 -> UNDEFINED
  0, // 1 -> CLOUD_GAMING_DEVICE
  1, // 2 -> FEATURE_AWARE_DEVICE
};

const std::string& SystemProfileProto_DemoModeDimensions_CustomizationFacet_Name(
    SystemProfileProto_DemoModeDimensions_CustomizationFacet value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_DemoModeDimensions_CustomizationFacet_entries,
          SystemProfileProto_DemoModeDimensions_CustomizationFacet_entries_by_number,
          3, SystemProfileProto_DemoModeDimensions_CustomizationFacet_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_DemoModeDimensions_CustomizationFacet_entries,
      SystemProfileProto_DemoModeDimensions_CustomizationFacet_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_DemoModeDimensions_CustomizationFacet_strings[idx].get();
}
bool SystemProfileProto_DemoModeDimensions_CustomizationFacet_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_DemoModeDimensions_CustomizationFacet* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_DemoModeDimensions_CustomizationFacet_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_DemoModeDimensions_CustomizationFacet>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_DemoModeDimensions_CustomizationFacet SystemProfileProto_DemoModeDimensions::UNDEFINED;
constexpr SystemProfileProto_DemoModeDimensions_CustomizationFacet SystemProfileProto_DemoModeDimensions::CLOUD_GAMING_DEVICE;
constexpr SystemProfileProto_DemoModeDimensions_CustomizationFacet SystemProfileProto_DemoModeDimensions::FEATURE_AWARE_DEVICE;
constexpr SystemProfileProto_DemoModeDimensions_CustomizationFacet SystemProfileProto_DemoModeDimensions::CustomizationFacet_MIN;
constexpr SystemProfileProto_DemoModeDimensions_CustomizationFacet SystemProfileProto_DemoModeDimensions::CustomizationFacet_MAX;
constexpr int SystemProfileProto_DemoModeDimensions::CustomizationFacet_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_Channel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_Channel_strings[5] = {};

static const char SystemProfileProto_Channel_names[] =
  "CHANNEL_BETA"
  "CHANNEL_CANARY"
  "CHANNEL_DEV"
  "CHANNEL_STABLE"
  "CHANNEL_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_Channel_entries[] = {
  { {SystemProfileProto_Channel_names + 0, 12}, 3 },
  { {SystemProfileProto_Channel_names + 12, 14}, 1 },
  { {SystemProfileProto_Channel_names + 26, 11}, 2 },
  { {SystemProfileProto_Channel_names + 37, 14}, 4 },
  { {SystemProfileProto_Channel_names + 51, 15}, 0 },
};

static const int SystemProfileProto_Channel_entries_by_number[] = {
  4, // 0 -> CHANNEL_UNKNOWN
  1, // 1 -> CHANNEL_CANARY
  2, // 2 -> CHANNEL_DEV
  0, // 3 -> CHANNEL_BETA
  3, // 4 -> CHANNEL_STABLE
};

const std::string& SystemProfileProto_Channel_Name(
    SystemProfileProto_Channel value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_Channel_entries,
          SystemProfileProto_Channel_entries_by_number,
          5, SystemProfileProto_Channel_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_Channel_entries,
      SystemProfileProto_Channel_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_Channel_strings[idx].get();
}
bool SystemProfileProto_Channel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_Channel* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_Channel_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_Channel>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_Channel SystemProfileProto::CHANNEL_UNKNOWN;
constexpr SystemProfileProto_Channel SystemProfileProto::CHANNEL_CANARY;
constexpr SystemProfileProto_Channel SystemProfileProto::CHANNEL_DEV;
constexpr SystemProfileProto_Channel SystemProfileProto::CHANNEL_BETA;
constexpr SystemProfileProto_Channel SystemProfileProto::CHANNEL_STABLE;
constexpr SystemProfileProto_Channel SystemProfileProto::Channel_MIN;
constexpr SystemProfileProto_Channel SystemProfileProto::Channel_MAX;
constexpr int SystemProfileProto::Channel_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_ExtensionsState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_ExtensionsState_strings[4] = {};

static const char SystemProfileProto_ExtensionsState_names[] =
  "HAS_OFFSTORE"
  "NO_EXTENSIONS"
  "NO_OFFSTORE_UNVERIFIED"
  "NO_OFFSTORE_VERIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_ExtensionsState_entries[] = {
  { {SystemProfileProto_ExtensionsState_names + 0, 12}, 3 },
  { {SystemProfileProto_ExtensionsState_names + 12, 13}, 0 },
  { {SystemProfileProto_ExtensionsState_names + 25, 22}, 2 },
  { {SystemProfileProto_ExtensionsState_names + 47, 20}, 1 },
};

static const int SystemProfileProto_ExtensionsState_entries_by_number[] = {
  1, // 0 -> NO_EXTENSIONS
  3, // 1 -> NO_OFFSTORE_VERIFIED
  2, // 2 -> NO_OFFSTORE_UNVERIFIED
  0, // 3 -> HAS_OFFSTORE
};

const std::string& SystemProfileProto_ExtensionsState_Name(
    SystemProfileProto_ExtensionsState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_ExtensionsState_entries,
          SystemProfileProto_ExtensionsState_entries_by_number,
          4, SystemProfileProto_ExtensionsState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_ExtensionsState_entries,
      SystemProfileProto_ExtensionsState_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_ExtensionsState_strings[idx].get();
}
bool SystemProfileProto_ExtensionsState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_ExtensionsState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_ExtensionsState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_ExtensionsState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_ExtensionsState SystemProfileProto::NO_EXTENSIONS;
constexpr SystemProfileProto_ExtensionsState SystemProfileProto::NO_OFFSTORE_VERIFIED;
constexpr SystemProfileProto_ExtensionsState SystemProfileProto::NO_OFFSTORE_UNVERIFIED;
constexpr SystemProfileProto_ExtensionsState SystemProfileProto::HAS_OFFSTORE;
constexpr SystemProfileProto_ExtensionsState SystemProfileProto::ExtensionsState_MIN;
constexpr SystemProfileProto_ExtensionsState SystemProfileProto::ExtensionsState_MAX;
constexpr int SystemProfileProto::ExtensionsState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_UmaDefaultState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_UmaDefaultState_strings[4] = {};

static const char SystemProfileProto_UmaDefaultState_names[] =
  "OPT_IN"
  "OPT_OUT"
  "OPT_UNKNOWN"
  "POLICY_FORCED_ENABLED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_UmaDefaultState_entries[] = {
  { {SystemProfileProto_UmaDefaultState_names + 0, 6}, 0 },
  { {SystemProfileProto_UmaDefaultState_names + 6, 7}, 1 },
  { {SystemProfileProto_UmaDefaultState_names + 13, 11}, 3 },
  { {SystemProfileProto_UmaDefaultState_names + 24, 21}, 2 },
};

static const int SystemProfileProto_UmaDefaultState_entries_by_number[] = {
  0, // 0 -> OPT_IN
  1, // 1 -> OPT_OUT
  3, // 2 -> POLICY_FORCED_ENABLED
  2, // 3 -> OPT_UNKNOWN
};

const std::string& SystemProfileProto_UmaDefaultState_Name(
    SystemProfileProto_UmaDefaultState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_UmaDefaultState_entries,
          SystemProfileProto_UmaDefaultState_entries_by_number,
          4, SystemProfileProto_UmaDefaultState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_UmaDefaultState_entries,
      SystemProfileProto_UmaDefaultState_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_UmaDefaultState_strings[idx].get();
}
bool SystemProfileProto_UmaDefaultState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_UmaDefaultState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_UmaDefaultState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_UmaDefaultState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_UmaDefaultState SystemProfileProto::OPT_IN;
constexpr SystemProfileProto_UmaDefaultState SystemProfileProto::OPT_OUT;
constexpr SystemProfileProto_UmaDefaultState SystemProfileProto::POLICY_FORCED_ENABLED;
constexpr SystemProfileProto_UmaDefaultState SystemProfileProto::OPT_UNKNOWN;
constexpr SystemProfileProto_UmaDefaultState SystemProfileProto::UmaDefaultState_MIN;
constexpr SystemProfileProto_UmaDefaultState SystemProfileProto::UmaDefaultState_MAX;
constexpr int SystemProfileProto::UmaDefaultState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_AntiVirusState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_AntiVirusState_strings[4] = {};

static const char SystemProfileProto_AntiVirusState_names[] =
  "STATE_EXPIRED"
  "STATE_OFF"
  "STATE_ON"
  "STATE_SNOOZED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_AntiVirusState_entries[] = {
  { {SystemProfileProto_AntiVirusState_names + 0, 13}, 3 },
  { {SystemProfileProto_AntiVirusState_names + 13, 9}, 1 },
  { {SystemProfileProto_AntiVirusState_names + 22, 8}, 0 },
  { {SystemProfileProto_AntiVirusState_names + 30, 13}, 2 },
};

static const int SystemProfileProto_AntiVirusState_entries_by_number[] = {
  2, // 0 -> STATE_ON
  1, // 1 -> STATE_OFF
  3, // 2 -> STATE_SNOOZED
  0, // 3 -> STATE_EXPIRED
};

const std::string& SystemProfileProto_AntiVirusState_Name(
    SystemProfileProto_AntiVirusState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_AntiVirusState_entries,
          SystemProfileProto_AntiVirusState_entries_by_number,
          4, SystemProfileProto_AntiVirusState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_AntiVirusState_entries,
      SystemProfileProto_AntiVirusState_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_AntiVirusState_strings[idx].get();
}
bool SystemProfileProto_AntiVirusState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_AntiVirusState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_AntiVirusState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_AntiVirusState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_AntiVirusState SystemProfileProto::STATE_ON;
constexpr SystemProfileProto_AntiVirusState SystemProfileProto::STATE_OFF;
constexpr SystemProfileProto_AntiVirusState SystemProfileProto::STATE_SNOOZED;
constexpr SystemProfileProto_AntiVirusState SystemProfileProto::STATE_EXPIRED;
constexpr SystemProfileProto_AntiVirusState SystemProfileProto::AntiVirusState_MIN;
constexpr SystemProfileProto_AntiVirusState SystemProfileProto::AntiVirusState_MAX;
constexpr int SystemProfileProto::AntiVirusState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_ComponentId_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_ComponentId_strings[62] = {};

static const char SystemProfileProto_ComponentId_names[] =
  "APP_PROVISIONING"
  "AUTOFILL_REGEX_CONSTANTS"
  "AUTOFILL_STATES"
  "CELLULAR"
  "CLIENT_SIDE_PHISHING"
  "COMMERCE_HEURISTICS"
  "CRL_SET"
  "CROS_SMART_DIM"
  "CROS_TERMINA"
  "CROWD_DENY"
  "CROW_DOMAIN_LIST"
  "DEMO_MODE_APP"
  "DEMO_MODE_RESOURCES"
  "DESKTOP_SCREENSHOT_EDITOR"
  "DESKTOP_SHARING_HUB"
  "DOWNLOADABLE_STRINGS"
  "EPSON_INKJET_PRINTER_ESCPR"
  "FILE_TYPE_POLICIES"
  "FIRST_PARTY_SETS"
  "HYPHENATION"
  "INTERVENTION_POLICY_DATABASE"
  "LACROS_DOGFOOD_BETA"
  "LACROS_DOGFOOD_CANARY"
  "LACROS_DOGFOOD_DEV"
  "LACROS_DOGFOOD_STABLE"
  "MEDIA_FOUNDATION_WIDEVINE_CDM"
  "MEI_PRELOAD"
  "ON_DEVICE_HEAD_SUGGEST"
  "OPTIMIZATION_HINTS"
  "ORIGIN_TRIALS"
  "PEPPER_FLASH"
  "PEPPER_FLASH_CHROMEOS"
  "PKI_METADATA"
  "PNACL"
  "REAL_TIME_URL_CHECKS_ALLOWLIST"
  "RECOVERY"
  "RECOVERY_IMPROVED"
  "RTANALYTICS_FULL"
  "RTANALYTICS_LIGHT"
  "SAFETY_TIPS"
  "SCREEN_AI"
  "SMART_DIM"
  "SODA"
  "SODA_DE_DE"
  "SODA_EN_US"
  "SODA_ES_ES"
  "SODA_FR_FR"
  "SODA_IT_IT"
  "SODA_JA_JP"
  "SPEECH_SYNTHESIS_SV_SE"
  "SSL_ERROR_ASSISTANT"
  "STAR_CUPS_DRIVER"
  "STH_SET"
  "SUBRESOURCE_FILTER"
  "SW_REPORTER"
  "THIRD_PARTY_MODULE_LIST"
  "TRUST_TOKEN_KEY_COMMITMENTS"
  "UNKNOWN"
  "VR_ASSETS"
  "WEBVIEW_APPS_PACKAGE_NAMES_ALLOWLIST"
  "WIDEVINE_CDM"
  "ZXCVBN_DATA";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_ComponentId_entries[] = {
  { {SystemProfileProto_ComponentId_names + 0, 16}, 32 },
  { {SystemProfileProto_ComponentId_names + 16, 24}, 28 },
  { {SystemProfileProto_ComponentId_names + 40, 15}, 33 },
  { {SystemProfileProto_ComponentId_names + 55, 8}, 23 },
  { {SystemProfileProto_ComponentId_names + 63, 20}, 34 },
  { {SystemProfileProto_ComponentId_names + 83, 19}, 35 },
  { {SystemProfileProto_ComponentId_names + 102, 7}, 10 },
  { {SystemProfileProto_ComponentId_names + 109, 14}, 26 },
  { {SystemProfileProto_ComponentId_names + 123, 12}, 15 },
  { {SystemProfileProto_ComponentId_names + 135, 10}, 31 },
  { {SystemProfileProto_ComponentId_names + 145, 16}, 36 },
  { {SystemProfileProto_ComponentId_names + 161, 13}, 37 },
  { {SystemProfileProto_ComponentId_names + 174, 19}, 24 },
  { {SystemProfileProto_ComponentId_names + 193, 25}, 38 },
  { {SystemProfileProto_ComponentId_names + 218, 19}, 39 },
  { {SystemProfileProto_ComponentId_names + 237, 20}, 19 },
  { {SystemProfileProto_ComponentId_names + 257, 26}, 14 },
  { {SystemProfileProto_ComponentId_names + 283, 18}, 2 },
  { {SystemProfileProto_ComponentId_names + 301, 16}, 40 },
  { {SystemProfileProto_ComponentId_names + 317, 11}, 41 },
  { {SystemProfileProto_ComponentId_names + 328, 28}, 42 },
  { {SystemProfileProto_ComponentId_names + 356, 19}, 43 },
  { {SystemProfileProto_ComponentId_names + 375, 21}, 44 },
  { {SystemProfileProto_ComponentId_names + 396, 18}, 45 },
  { {SystemProfileProto_ComponentId_names + 414, 21}, 46 },
  { {SystemProfileProto_ComponentId_names + 435, 29}, 30 },
  { {SystemProfileProto_ComponentId_names + 464, 11}, 47 },
  { {SystemProfileProto_ComponentId_names + 475, 22}, 25 },
  { {SystemProfileProto_ComponentId_names + 497, 18}, 18 },
  { {SystemProfileProto_ComponentId_names + 515, 13}, 3 },
  { {SystemProfileProto_ComponentId_names + 528, 12}, 4 },
  { {SystemProfileProto_ComponentId_names + 540, 21}, 5 },
  { {SystemProfileProto_ComponentId_names + 561, 12}, 48 },
  { {SystemProfileProto_ComponentId_names + 573, 5}, 6 },
  { {SystemProfileProto_ComponentId_names + 578, 30}, 49 },
  { {SystemProfileProto_ComponentId_names + 608, 8}, 7 },
  { {SystemProfileProto_ComponentId_names + 616, 17}, 50 },
  { {SystemProfileProto_ComponentId_names + 633, 16}, 22 },
  { {SystemProfileProto_ComponentId_names + 649, 17}, 21 },
  { {SystemProfileProto_ComponentId_names + 666, 11}, 51 },
  { {SystemProfileProto_ComponentId_names + 677, 9}, 52 },
  { {SystemProfileProto_ComponentId_names + 686, 9}, 53 },
  { {SystemProfileProto_ComponentId_names + 695, 4}, 54 },
  { {SystemProfileProto_ComponentId_names + 699, 10}, 55 },
  { {SystemProfileProto_ComponentId_names + 709, 10}, 56 },
  { {SystemProfileProto_ComponentId_names + 719, 10}, 57 },
  { {SystemProfileProto_ComponentId_names + 729, 10}, 58 },
  { {SystemProfileProto_ComponentId_names + 739, 10}, 59 },
  { {SystemProfileProto_ComponentId_names + 749, 10}, 60 },
  { {SystemProfileProto_ComponentId_names + 759, 22}, 17 },
  { {SystemProfileProto_ComponentId_names + 781, 19}, 8 },
  { {SystemProfileProto_ComponentId_names + 800, 16}, 16 },
  { {SystemProfileProto_ComponentId_names + 816, 7}, 9 },
  { {SystemProfileProto_ComponentId_names + 823, 18}, 11 },
  { {SystemProfileProto_ComponentId_names + 841, 11}, 12 },
  { {SystemProfileProto_ComponentId_names + 852, 23}, 61 },
  { {SystemProfileProto_ComponentId_names + 875, 27}, 62 },
  { {SystemProfileProto_ComponentId_names + 902, 7}, 1 },
  { {SystemProfileProto_ComponentId_names + 909, 9}, 20 },
  { {SystemProfileProto_ComponentId_names + 918, 36}, 29 },
  { {SystemProfileProto_ComponentId_names + 954, 12}, 13 },
  { {SystemProfileProto_ComponentId_names + 966, 11}, 27 },
};

static const int SystemProfileProto_ComponentId_entries_by_number[] = {
  57, // 1 -> UNKNOWN
  17, // 2 -> FILE_TYPE_POLICIES
  29, // 3 -> ORIGIN_TRIALS
  30, // 4 -> PEPPER_FLASH
  31, // 5 -> PEPPER_FLASH_CHROMEOS
  33, // 6 -> PNACL
  35, // 7 -> RECOVERY
  50, // 8 -> SSL_ERROR_ASSISTANT
  52, // 9 -> STH_SET
  6, // 10 -> CRL_SET
  53, // 11 -> SUBRESOURCE_FILTER
  54, // 12 -> SW_REPORTER
  60, // 13 -> WIDEVINE_CDM
  16, // 14 -> EPSON_INKJET_PRINTER_ESCPR
  8, // 15 -> CROS_TERMINA
  51, // 16 -> STAR_CUPS_DRIVER
  49, // 17 -> SPEECH_SYNTHESIS_SV_SE
  28, // 18 -> OPTIMIZATION_HINTS
  15, // 19 -> DOWNLOADABLE_STRINGS
  58, // 20 -> VR_ASSETS
  38, // 21 -> RTANALYTICS_LIGHT
  37, // 22 -> RTANALYTICS_FULL
  3, // 23 -> CELLULAR
  12, // 24 -> DEMO_MODE_RESOURCES
  27, // 25 -> ON_DEVICE_HEAD_SUGGEST
  7, // 26 -> CROS_SMART_DIM
  61, // 27 -> ZXCVBN_DATA
  1, // 28 -> AUTOFILL_REGEX_CONSTANTS
  59, // 29 -> WEBVIEW_APPS_PACKAGE_NAMES_ALLOWLIST
  25, // 30 -> MEDIA_FOUNDATION_WIDEVINE_CDM
  9, // 31 -> CROWD_DENY
  0, // 32 -> APP_PROVISIONING
  2, // 33 -> AUTOFILL_STATES
  4, // 34 -> CLIENT_SIDE_PHISHING
  5, // 35 -> COMMERCE_HEURISTICS
  10, // 36 -> CROW_DOMAIN_LIST
  11, // 37 -> DEMO_MODE_APP
  13, // 38 -> DESKTOP_SCREENSHOT_EDITOR
  14, // 39 -> DESKTOP_SHARING_HUB
  18, // 40 -> FIRST_PARTY_SETS
  19, // 41 -> HYPHENATION
  20, // 42 -> INTERVENTION_POLICY_DATABASE
  21, // 43 -> LACROS_DOGFOOD_BETA
  22, // 44 -> LACROS_DOGFOOD_CANARY
  23, // 45 -> LACROS_DOGFOOD_DEV
  24, // 46 -> LACROS_DOGFOOD_STABLE
  26, // 47 -> MEI_PRELOAD
  32, // 48 -> PKI_METADATA
  34, // 49 -> REAL_TIME_URL_CHECKS_ALLOWLIST
  36, // 50 -> RECOVERY_IMPROVED
  39, // 51 -> SAFETY_TIPS
  40, // 52 -> SCREEN_AI
  41, // 53 -> SMART_DIM
  42, // 54 -> SODA
  43, // 55 -> SODA_DE_DE
  44, // 56 -> SODA_EN_US
  45, // 57 -> SODA_ES_ES
  46, // 58 -> SODA_FR_FR
  47, // 59 -> SODA_IT_IT
  48, // 60 -> SODA_JA_JP
  55, // 61 -> THIRD_PARTY_MODULE_LIST
  56, // 62 -> TRUST_TOKEN_KEY_COMMITMENTS
};

const std::string& SystemProfileProto_ComponentId_Name(
    SystemProfileProto_ComponentId value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_ComponentId_entries,
          SystemProfileProto_ComponentId_entries_by_number,
          62, SystemProfileProto_ComponentId_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_ComponentId_entries,
      SystemProfileProto_ComponentId_entries_by_number,
      62, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_ComponentId_strings[idx].get();
}
bool SystemProfileProto_ComponentId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_ComponentId* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_ComponentId_entries, 62, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_ComponentId>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_ComponentId SystemProfileProto::UNKNOWN;
constexpr SystemProfileProto_ComponentId SystemProfileProto::FILE_TYPE_POLICIES;
constexpr SystemProfileProto_ComponentId SystemProfileProto::ORIGIN_TRIALS;
constexpr SystemProfileProto_ComponentId SystemProfileProto::PEPPER_FLASH;
constexpr SystemProfileProto_ComponentId SystemProfileProto::PEPPER_FLASH_CHROMEOS;
constexpr SystemProfileProto_ComponentId SystemProfileProto::PNACL;
constexpr SystemProfileProto_ComponentId SystemProfileProto::RECOVERY;
constexpr SystemProfileProto_ComponentId SystemProfileProto::SSL_ERROR_ASSISTANT;
constexpr SystemProfileProto_ComponentId SystemProfileProto::STH_SET;
constexpr SystemProfileProto_ComponentId SystemProfileProto::CRL_SET;
constexpr SystemProfileProto_ComponentId SystemProfileProto::SUBRESOURCE_FILTER;
constexpr SystemProfileProto_ComponentId SystemProfileProto::SW_REPORTER;
constexpr SystemProfileProto_ComponentId SystemProfileProto::WIDEVINE_CDM;
constexpr SystemProfileProto_ComponentId SystemProfileProto::EPSON_INKJET_PRINTER_ESCPR;
constexpr SystemProfileProto_ComponentId SystemProfileProto::CROS_TERMINA;
constexpr SystemProfileProto_ComponentId SystemProfileProto::STAR_CUPS_DRIVER;
constexpr SystemProfileProto_ComponentId SystemProfileProto::SPEECH_SYNTHESIS_SV_SE;
constexpr SystemProfileProto_ComponentId SystemProfileProto::OPTIMIZATION_HINTS;
constexpr SystemProfileProto_ComponentId SystemProfileProto::DOWNLOADABLE_STRINGS;
constexpr SystemProfileProto_ComponentId SystemProfileProto::VR_ASSETS;
constexpr SystemProfileProto_ComponentId SystemProfileProto::RTANALYTICS_LIGHT;
constexpr SystemProfileProto_ComponentId SystemProfileProto::RTANALYTICS_FULL;
constexpr SystemProfileProto_ComponentId SystemProfileProto::CELLULAR;
constexpr SystemProfileProto_ComponentId SystemProfileProto::DEMO_MODE_RESOURCES;
constexpr SystemProfileProto_ComponentId SystemProfileProto::ON_DEVICE_HEAD_SUGGEST;
constexpr SystemProfileProto_ComponentId SystemProfileProto::CROS_SMART_DIM;
constexpr SystemProfileProto_ComponentId SystemProfileProto::ZXCVBN_DATA;
constexpr SystemProfileProto_ComponentId SystemProfileProto::AUTOFILL_REGEX_CONSTANTS;
constexpr SystemProfileProto_ComponentId SystemProfileProto::WEBVIEW_APPS_PACKAGE_NAMES_ALLOWLIST;
constexpr SystemProfileProto_ComponentId SystemProfileProto::MEDIA_FOUNDATION_WIDEVINE_CDM;
constexpr SystemProfileProto_ComponentId SystemProfileProto::CROWD_DENY;
constexpr SystemProfileProto_ComponentId SystemProfileProto::APP_PROVISIONING;
constexpr SystemProfileProto_ComponentId SystemProfileProto::AUTOFILL_STATES;
constexpr SystemProfileProto_ComponentId SystemProfileProto::CLIENT_SIDE_PHISHING;
constexpr SystemProfileProto_ComponentId SystemProfileProto::COMMERCE_HEURISTICS;
constexpr SystemProfileProto_ComponentId SystemProfileProto::CROW_DOMAIN_LIST;
constexpr SystemProfileProto_ComponentId SystemProfileProto::DEMO_MODE_APP;
constexpr SystemProfileProto_ComponentId SystemProfileProto::DESKTOP_SCREENSHOT_EDITOR;
constexpr SystemProfileProto_ComponentId SystemProfileProto::DESKTOP_SHARING_HUB;
constexpr SystemProfileProto_ComponentId SystemProfileProto::FIRST_PARTY_SETS;
constexpr SystemProfileProto_ComponentId SystemProfileProto::HYPHENATION;
constexpr SystemProfileProto_ComponentId SystemProfileProto::INTERVENTION_POLICY_DATABASE;
constexpr SystemProfileProto_ComponentId SystemProfileProto::LACROS_DOGFOOD_BETA;
constexpr SystemProfileProto_ComponentId SystemProfileProto::LACROS_DOGFOOD_CANARY;
constexpr SystemProfileProto_ComponentId SystemProfileProto::LACROS_DOGFOOD_DEV;
constexpr SystemProfileProto_ComponentId SystemProfileProto::LACROS_DOGFOOD_STABLE;
constexpr SystemProfileProto_ComponentId SystemProfileProto::MEI_PRELOAD;
constexpr SystemProfileProto_ComponentId SystemProfileProto::PKI_METADATA;
constexpr SystemProfileProto_ComponentId SystemProfileProto::REAL_TIME_URL_CHECKS_ALLOWLIST;
constexpr SystemProfileProto_ComponentId SystemProfileProto::RECOVERY_IMPROVED;
constexpr SystemProfileProto_ComponentId SystemProfileProto::SAFETY_TIPS;
constexpr SystemProfileProto_ComponentId SystemProfileProto::SCREEN_AI;
constexpr SystemProfileProto_ComponentId SystemProfileProto::SMART_DIM;
constexpr SystemProfileProto_ComponentId SystemProfileProto::SODA;
constexpr SystemProfileProto_ComponentId SystemProfileProto::SODA_DE_DE;
constexpr SystemProfileProto_ComponentId SystemProfileProto::SODA_EN_US;
constexpr SystemProfileProto_ComponentId SystemProfileProto::SODA_ES_ES;
constexpr SystemProfileProto_ComponentId SystemProfileProto::SODA_FR_FR;
constexpr SystemProfileProto_ComponentId SystemProfileProto::SODA_IT_IT;
constexpr SystemProfileProto_ComponentId SystemProfileProto::SODA_JA_JP;
constexpr SystemProfileProto_ComponentId SystemProfileProto::THIRD_PARTY_MODULE_LIST;
constexpr SystemProfileProto_ComponentId SystemProfileProto::TRUST_TOKEN_KEY_COMMITMENTS;
constexpr SystemProfileProto_ComponentId SystemProfileProto::ComponentId_MIN;
constexpr SystemProfileProto_ComponentId SystemProfileProto::ComponentId_MAX;
constexpr int SystemProfileProto::ComponentId_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_AppPackageNameAllowlistFilter_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_AppPackageNameAllowlistFilter_strings[4] = {};

static const char SystemProfileProto_AppPackageNameAllowlistFilter_names[] =
  "NO_SERVER_SIDE_FILTER_REQUIRED_DUE_TO_CLIENT_FILTERING"
  "NO_SERVER_SIDE_FILTER_REQUIRED_FOR_SYSTEM_APPS"
  "SERVER_SIDE_FILTER_REQUIRED"
  "SERVER_SIDE_FILTER_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_AppPackageNameAllowlistFilter_entries[] = {
  { {SystemProfileProto_AppPackageNameAllowlistFilter_names + 0, 54}, 2 },
  { {SystemProfileProto_AppPackageNameAllowlistFilter_names + 54, 46}, 3 },
  { {SystemProfileProto_AppPackageNameAllowlistFilter_names + 100, 27}, 1 },
  { {SystemProfileProto_AppPackageNameAllowlistFilter_names + 127, 30}, 0 },
};

static const int SystemProfileProto_AppPackageNameAllowlistFilter_entries_by_number[] = {
  3, // 0 -> SERVER_SIDE_FILTER_UNSPECIFIED
  2, // 1 -> SERVER_SIDE_FILTER_REQUIRED
  0, // 2 -> NO_SERVER_SIDE_FILTER_REQUIRED_DUE_TO_CLIENT_FILTERING
  1, // 3 -> NO_SERVER_SIDE_FILTER_REQUIRED_FOR_SYSTEM_APPS
};

const std::string& SystemProfileProto_AppPackageNameAllowlistFilter_Name(
    SystemProfileProto_AppPackageNameAllowlistFilter value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_AppPackageNameAllowlistFilter_entries,
          SystemProfileProto_AppPackageNameAllowlistFilter_entries_by_number,
          4, SystemProfileProto_AppPackageNameAllowlistFilter_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_AppPackageNameAllowlistFilter_entries,
      SystemProfileProto_AppPackageNameAllowlistFilter_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_AppPackageNameAllowlistFilter_strings[idx].get();
}
bool SystemProfileProto_AppPackageNameAllowlistFilter_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_AppPackageNameAllowlistFilter* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_AppPackageNameAllowlistFilter_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_AppPackageNameAllowlistFilter>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_AppPackageNameAllowlistFilter SystemProfileProto::SERVER_SIDE_FILTER_UNSPECIFIED;
constexpr SystemProfileProto_AppPackageNameAllowlistFilter SystemProfileProto::SERVER_SIDE_FILTER_REQUIRED;
constexpr SystemProfileProto_AppPackageNameAllowlistFilter SystemProfileProto::NO_SERVER_SIDE_FILTER_REQUIRED_DUE_TO_CLIENT_FILTERING;
constexpr SystemProfileProto_AppPackageNameAllowlistFilter SystemProfileProto::NO_SERVER_SIDE_FILTER_REQUIRED_FOR_SYSTEM_APPS;
constexpr SystemProfileProto_AppPackageNameAllowlistFilter SystemProfileProto::AppPackageNameAllowlistFilter_MIN;
constexpr SystemProfileProto_AppPackageNameAllowlistFilter SystemProfileProto::AppPackageNameAllowlistFilter_MAX;
constexpr int SystemProfileProto::AppPackageNameAllowlistFilter_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_ClientSideSamplingStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_ClientSideSamplingStatus_strings[3] = {};

static const char SystemProfileProto_ClientSideSamplingStatus_names[] =
  "SAMPLING_APPLIED"
  "SAMPLING_NOT_APPLIED"
  "SAMPLING_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_ClientSideSamplingStatus_entries[] = {
  { {SystemProfileProto_ClientSideSamplingStatus_names + 0, 16}, 1 },
  { {SystemProfileProto_ClientSideSamplingStatus_names + 16, 20}, 2 },
  { {SystemProfileProto_ClientSideSamplingStatus_names + 36, 16}, 0 },
};

static const int SystemProfileProto_ClientSideSamplingStatus_entries_by_number[] = {
  2, // 0 -> SAMPLING_UNKNOWN
  0, // 1 -> SAMPLING_APPLIED
  1, // 2 -> SAMPLING_NOT_APPLIED
};

const std::string& SystemProfileProto_ClientSideSamplingStatus_Name(
    SystemProfileProto_ClientSideSamplingStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_ClientSideSamplingStatus_entries,
          SystemProfileProto_ClientSideSamplingStatus_entries_by_number,
          3, SystemProfileProto_ClientSideSamplingStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_ClientSideSamplingStatus_entries,
      SystemProfileProto_ClientSideSamplingStatus_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_ClientSideSamplingStatus_strings[idx].get();
}
bool SystemProfileProto_ClientSideSamplingStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_ClientSideSamplingStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_ClientSideSamplingStatus_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_ClientSideSamplingStatus>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_ClientSideSamplingStatus SystemProfileProto::SAMPLING_UNKNOWN;
constexpr SystemProfileProto_ClientSideSamplingStatus SystemProfileProto::SAMPLING_APPLIED;
constexpr SystemProfileProto_ClientSideSamplingStatus SystemProfileProto::SAMPLING_NOT_APPLIED;
constexpr SystemProfileProto_ClientSideSamplingStatus SystemProfileProto::ClientSideSamplingStatus_MIN;
constexpr SystemProfileProto_ClientSideSamplingStatus SystemProfileProto::ClientSideSamplingStatus_MAX;
constexpr int SystemProfileProto::ClientSideSamplingStatus_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_MetricsFilteringStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_MetricsFilteringStatus_strings[3] = {};

static const char SystemProfileProto_MetricsFilteringStatus_names[] =
  "METRICS_ALL"
  "METRICS_ONLY_CRITICAL"
  "METRICS_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_MetricsFilteringStatus_entries[] = {
  { {SystemProfileProto_MetricsFilteringStatus_names + 0, 11}, 1 },
  { {SystemProfileProto_MetricsFilteringStatus_names + 11, 21}, 2 },
  { {SystemProfileProto_MetricsFilteringStatus_names + 32, 15}, 0 },
};

static const int SystemProfileProto_MetricsFilteringStatus_entries_by_number[] = {
  2, // 0 -> METRICS_UNKNOWN
  0, // 1 -> METRICS_ALL
  1, // 2 -> METRICS_ONLY_CRITICAL
};

const std::string& SystemProfileProto_MetricsFilteringStatus_Name(
    SystemProfileProto_MetricsFilteringStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_MetricsFilteringStatus_entries,
          SystemProfileProto_MetricsFilteringStatus_entries_by_number,
          3, SystemProfileProto_MetricsFilteringStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_MetricsFilteringStatus_entries,
      SystemProfileProto_MetricsFilteringStatus_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_MetricsFilteringStatus_strings[idx].get();
}
bool SystemProfileProto_MetricsFilteringStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_MetricsFilteringStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_MetricsFilteringStatus_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_MetricsFilteringStatus>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_MetricsFilteringStatus SystemProfileProto::METRICS_UNKNOWN;
constexpr SystemProfileProto_MetricsFilteringStatus SystemProfileProto::METRICS_ALL;
constexpr SystemProfileProto_MetricsFilteringStatus SystemProfileProto::METRICS_ONLY_CRITICAL;
constexpr SystemProfileProto_MetricsFilteringStatus SystemProfileProto::MetricsFilteringStatus_MIN;
constexpr SystemProfileProto_MetricsFilteringStatus SystemProfileProto::MetricsFilteringStatus_MAX;
constexpr int SystemProfileProto::MetricsFilteringStatus_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_InstallerPackage_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_InstallerPackage_strings[4] = {};

static const char SystemProfileProto_InstallerPackage_names[] =
  "INSTALLER_PACKAGE_GOOGLE_PLAY_STORE"
  "INSTALLER_PACKAGE_NONE"
  "INSTALLER_PACKAGE_OTHER"
  "INSTALLER_PACKAGE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_InstallerPackage_entries[] = {
  { {SystemProfileProto_InstallerPackage_names + 0, 35}, 2 },
  { {SystemProfileProto_InstallerPackage_names + 35, 22}, 1 },
  { {SystemProfileProto_InstallerPackage_names + 57, 23}, 3 },
  { {SystemProfileProto_InstallerPackage_names + 80, 25}, 0 },
};

static const int SystemProfileProto_InstallerPackage_entries_by_number[] = {
  3, // 0 -> INSTALLER_PACKAGE_UNKNOWN
  1, // 1 -> INSTALLER_PACKAGE_NONE
  0, // 2 -> INSTALLER_PACKAGE_GOOGLE_PLAY_STORE
  2, // 3 -> INSTALLER_PACKAGE_OTHER
};

const std::string& SystemProfileProto_InstallerPackage_Name(
    SystemProfileProto_InstallerPackage value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_InstallerPackage_entries,
          SystemProfileProto_InstallerPackage_entries_by_number,
          4, SystemProfileProto_InstallerPackage_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_InstallerPackage_entries,
      SystemProfileProto_InstallerPackage_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_InstallerPackage_strings[idx].get();
}
bool SystemProfileProto_InstallerPackage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_InstallerPackage* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_InstallerPackage_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_InstallerPackage>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_InstallerPackage SystemProfileProto::INSTALLER_PACKAGE_UNKNOWN;
constexpr SystemProfileProto_InstallerPackage SystemProfileProto::INSTALLER_PACKAGE_NONE;
constexpr SystemProfileProto_InstallerPackage SystemProfileProto::INSTALLER_PACKAGE_GOOGLE_PLAY_STORE;
constexpr SystemProfileProto_InstallerPackage SystemProfileProto::INSTALLER_PACKAGE_OTHER;
constexpr SystemProfileProto_InstallerPackage SystemProfileProto::InstallerPackage_MIN;
constexpr SystemProfileProto_InstallerPackage SystemProfileProto::InstallerPackage_MAX;
constexpr int SystemProfileProto::InstallerPackage_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SystemProfileProto_LTSChannel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SystemProfileProto_LTSChannel_strings[4] = {};

static const char SystemProfileProto_LTSChannel_names[] =
  "LTS_CHANNEL_LTC"
  "LTS_CHANNEL_LTS"
  "LTS_CHANNEL_STABLE"
  "LTS_CHANNEL_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SystemProfileProto_LTSChannel_entries[] = {
  { {SystemProfileProto_LTSChannel_names + 0, 15}, 2 },
  { {SystemProfileProto_LTSChannel_names + 15, 15}, 3 },
  { {SystemProfileProto_LTSChannel_names + 30, 18}, 1 },
  { {SystemProfileProto_LTSChannel_names + 48, 19}, 0 },
};

static const int SystemProfileProto_LTSChannel_entries_by_number[] = {
  3, // 0 -> LTS_CHANNEL_UNKNOWN
  2, // 1 -> LTS_CHANNEL_STABLE
  0, // 2 -> LTS_CHANNEL_LTC
  1, // 3 -> LTS_CHANNEL_LTS
};

const std::string& SystemProfileProto_LTSChannel_Name(
    SystemProfileProto_LTSChannel value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SystemProfileProto_LTSChannel_entries,
          SystemProfileProto_LTSChannel_entries_by_number,
          4, SystemProfileProto_LTSChannel_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SystemProfileProto_LTSChannel_entries,
      SystemProfileProto_LTSChannel_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SystemProfileProto_LTSChannel_strings[idx].get();
}
bool SystemProfileProto_LTSChannel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemProfileProto_LTSChannel* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SystemProfileProto_LTSChannel_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<SystemProfileProto_LTSChannel>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SystemProfileProto_LTSChannel SystemProfileProto::LTS_CHANNEL_UNKNOWN;
constexpr SystemProfileProto_LTSChannel SystemProfileProto::LTS_CHANNEL_STABLE;
constexpr SystemProfileProto_LTSChannel SystemProfileProto::LTS_CHANNEL_LTC;
constexpr SystemProfileProto_LTSChannel SystemProfileProto::LTS_CHANNEL_LTS;
constexpr SystemProfileProto_LTSChannel SystemProfileProto::LTSChannel_MIN;
constexpr SystemProfileProto_LTSChannel SystemProfileProto::LTSChannel_MAX;
constexpr int SystemProfileProto::LTSChannel_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class SystemProfileProto_ClonedInstallInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto_ClonedInstallInfo>()._has_bits_);
  static void set_has_last_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cloned_from_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_first_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SystemProfileProto_ClonedInstallInfo::SystemProfileProto_ClonedInstallInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto.ClonedInstallInfo)
}
SystemProfileProto_ClonedInstallInfo::SystemProfileProto_ClonedInstallInfo(const SystemProfileProto_ClonedInstallInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&last_timestamp_, &from.last_timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&last_timestamp_)) + sizeof(count_));
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto.ClonedInstallInfo)
}

inline void SystemProfileProto_ClonedInstallInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&last_timestamp_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&last_timestamp_)) + sizeof(count_));
}

SystemProfileProto_ClonedInstallInfo::~SystemProfileProto_ClonedInstallInfo() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto.ClonedInstallInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto_ClonedInstallInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SystemProfileProto_ClonedInstallInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto_ClonedInstallInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto.ClonedInstallInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&last_timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&count_) -
        reinterpret_cast<char*>(&last_timestamp_)) + sizeof(count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto_ClonedInstallInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 last_timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_last_timestamp(&has_bits);
          last_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 cloned_from_client_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_cloned_from_client_id(&has_bits);
          cloned_from_client_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional int64 first_timestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_first_timestamp(&has_bits);
          first_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto_ClonedInstallInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto.ClonedInstallInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 last_timestamp = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_last_timestamp(), target);
  }

  // optional fixed64 cloned_from_client_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_cloned_from_client_id(), target);
  }

  // optional int64 first_timestamp = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_first_timestamp(), target);
  }

  // optional int32 count = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto.ClonedInstallInfo)
  return target;
}

size_t SystemProfileProto_ClonedInstallInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto.ClonedInstallInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int64 last_timestamp = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_last_timestamp());
    }

    // optional fixed64 cloned_from_client_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional int64 first_timestamp = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_first_timestamp());
    }

    // optional int32 count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_count());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto_ClonedInstallInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto_ClonedInstallInfo*>(
      &from));
}

void SystemProfileProto_ClonedInstallInfo::MergeFrom(const SystemProfileProto_ClonedInstallInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto.ClonedInstallInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      last_timestamp_ = from.last_timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      cloned_from_client_id_ = from.cloned_from_client_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      first_timestamp_ = from.first_timestamp_;
    }
    if (cached_has_bits & 0x00000008u) {
      count_ = from.count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto_ClonedInstallInfo::CopyFrom(const SystemProfileProto_ClonedInstallInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto.ClonedInstallInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto_ClonedInstallInfo::IsInitialized() const {
  return true;
}

void SystemProfileProto_ClonedInstallInfo::InternalSwap(SystemProfileProto_ClonedInstallInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemProfileProto_ClonedInstallInfo, count_)
      + sizeof(SystemProfileProto_ClonedInstallInfo::count_)
      - PROTOBUF_FIELD_OFFSET(SystemProfileProto_ClonedInstallInfo, last_timestamp_)>(
          reinterpret_cast<char*>(&last_timestamp_),
          reinterpret_cast<char*>(&other->last_timestamp_));
}

std::string SystemProfileProto_ClonedInstallInfo::GetTypeName() const {
  return "metrics.SystemProfileProto.ClonedInstallInfo";
}


// ===================================================================

class SystemProfileProto_OS_Arc::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto_OS_Arc>()._has_bits_);
  static void set_has_release(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SystemProfileProto_OS_Arc::SystemProfileProto_OS_Arc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto.OS.Arc)
}
SystemProfileProto_OS_Arc::SystemProfileProto_OS_Arc(const SystemProfileProto_OS_Arc& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  release_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    release_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_release()) {
    release_.Set(from._internal_release(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto.OS.Arc)
}

inline void SystemProfileProto_OS_Arc::SharedCtor() {
release_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  release_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SystemProfileProto_OS_Arc::~SystemProfileProto_OS_Arc() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto.OS.Arc)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto_OS_Arc::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  release_.Destroy();
}

void SystemProfileProto_OS_Arc::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto_OS_Arc::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto.OS.Arc)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    release_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto_OS_Arc::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string release = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_release();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto_OS_Arc::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto.OS.Arc)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string release = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_release(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto.OS.Arc)
  return target;
}

size_t SystemProfileProto_OS_Arc::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto.OS.Arc)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string release = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_release());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto_OS_Arc::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto_OS_Arc*>(
      &from));
}

void SystemProfileProto_OS_Arc::MergeFrom(const SystemProfileProto_OS_Arc& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto.OS.Arc)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_release()) {
    _internal_set_release(from._internal_release());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto_OS_Arc::CopyFrom(const SystemProfileProto_OS_Arc& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto.OS.Arc)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto_OS_Arc::IsInitialized() const {
  return true;
}

void SystemProfileProto_OS_Arc::InternalSwap(SystemProfileProto_OS_Arc* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &release_, lhs_arena,
      &other->release_, rhs_arena
  );
}

std::string SystemProfileProto_OS_Arc::GetTypeName() const {
  return "metrics.SystemProfileProto.OS.Arc";
}


// ===================================================================

class SystemProfileProto_OS::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto_OS>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_build_fingerprint(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_deprecated_is_jailbroken(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_build_number(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_kernel_version(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::metrics::SystemProfileProto_OS_Arc& arc(const SystemProfileProto_OS* msg);
  static void set_has_arc(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_dark_mode_state(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_xdg_session_type(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_xdg_current_desktop(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

const ::metrics::SystemProfileProto_OS_Arc&
SystemProfileProto_OS::_Internal::arc(const SystemProfileProto_OS* msg) {
  return *msg->arc_;
}
SystemProfileProto_OS::SystemProfileProto_OS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto.OS)
}
SystemProfileProto_OS::SystemProfileProto_OS(const SystemProfileProto_OS& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version()) {
    version_.Set(from._internal_version(), 
      GetArenaForAllocation());
  }
  build_fingerprint_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    build_fingerprint_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_build_fingerprint()) {
    build_fingerprint_.Set(from._internal_build_fingerprint(), 
      GetArenaForAllocation());
  }
  build_number_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    build_number_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_build_number()) {
    build_number_.Set(from._internal_build_number(), 
      GetArenaForAllocation());
  }
  kernel_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    kernel_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_kernel_version()) {
    kernel_version_.Set(from._internal_kernel_version(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_arc()) {
    arc_ = new ::metrics::SystemProfileProto_OS_Arc(*from.arc_);
  } else {
    arc_ = nullptr;
  }
  ::memcpy(&deprecated_is_jailbroken_, &from.deprecated_is_jailbroken_,
    static_cast<size_t>(reinterpret_cast<char*>(&xdg_current_desktop_) -
    reinterpret_cast<char*>(&deprecated_is_jailbroken_)) + sizeof(xdg_current_desktop_));
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto.OS)
}

inline void SystemProfileProto_OS::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
build_fingerprint_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  build_fingerprint_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
build_number_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  build_number_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
kernel_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  kernel_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&arc_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&xdg_current_desktop_) -
    reinterpret_cast<char*>(&arc_)) + sizeof(xdg_current_desktop_));
}

SystemProfileProto_OS::~SystemProfileProto_OS() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto.OS)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto_OS::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
  version_.Destroy();
  build_fingerprint_.Destroy();
  build_number_.Destroy();
  kernel_version_.Destroy();
  if (this != internal_default_instance()) delete arc_;
}

void SystemProfileProto_OS::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto_OS::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto.OS)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      build_fingerprint_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      build_number_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      kernel_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(arc_ != nullptr);
      arc_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&deprecated_is_jailbroken_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&dark_mode_state_) -
        reinterpret_cast<char*>(&deprecated_is_jailbroken_)) + sizeof(dark_mode_state_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&xdg_session_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&xdg_current_desktop_) -
        reinterpret_cast<char*>(&xdg_session_type_)) + sizeof(xdg_current_desktop_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto_OS::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string build_fingerprint = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_build_fingerprint();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool DEPRECATED_is_jailbroken = 4 [deprecated = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_deprecated_is_jailbroken(&has_bits);
          deprecated_is_jailbroken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string build_number = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_build_number();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string kernel_version = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_kernel_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.OS.Arc arc = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_arc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.OS.DarkModeState dark_mode_state = 8 [default = UNKNOWN];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_OS_DarkModeState_IsValid(val))) {
            _internal_set_dark_mode_state(static_cast<::metrics::SystemProfileProto_OS_DarkModeState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.OS.XdgSessionType xdg_session_type = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_OS_XdgSessionType_IsValid(val))) {
            _internal_set_xdg_session_type(static_cast<::metrics::SystemProfileProto_OS_XdgSessionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.OS.XdgCurrentDesktop xdg_current_desktop = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_OS_XdgCurrentDesktop_IsValid(val))) {
            _internal_set_xdg_current_desktop(static_cast<::metrics::SystemProfileProto_OS_XdgCurrentDesktop>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto_OS::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto.OS)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_version(), target);
  }

  // optional string build_fingerprint = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_build_fingerprint(), target);
  }

  // optional bool DEPRECATED_is_jailbroken = 4 [deprecated = true];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_deprecated_is_jailbroken(), target);
  }

  // optional string build_number = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_build_number(), target);
  }

  // optional string kernel_version = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_kernel_version(), target);
  }

  // optional .metrics.SystemProfileProto.OS.Arc arc = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::arc(this),
        _Internal::arc(this).GetCachedSize(), target, stream);
  }

  // optional .metrics.SystemProfileProto.OS.DarkModeState dark_mode_state = 8 [default = UNKNOWN];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_dark_mode_state(), target);
  }

  // optional .metrics.SystemProfileProto.OS.XdgSessionType xdg_session_type = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_xdg_session_type(), target);
  }

  // optional .metrics.SystemProfileProto.OS.XdgCurrentDesktop xdg_current_desktop = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_xdg_current_desktop(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto.OS)
  return target;
}

size_t SystemProfileProto_OS::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto.OS)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version());
    }

    // optional string build_fingerprint = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_build_fingerprint());
    }

    // optional string build_number = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_build_number());
    }

    // optional string kernel_version = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_kernel_version());
    }

    // optional .metrics.SystemProfileProto.OS.Arc arc = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *arc_);
    }

    // optional bool DEPRECATED_is_jailbroken = 4 [deprecated = true];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional .metrics.SystemProfileProto.OS.DarkModeState dark_mode_state = 8 [default = UNKNOWN];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_dark_mode_state());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional .metrics.SystemProfileProto.OS.XdgSessionType xdg_session_type = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_xdg_session_type());
    }

    // optional .metrics.SystemProfileProto.OS.XdgCurrentDesktop xdg_current_desktop = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_xdg_current_desktop());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto_OS::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto_OS*>(
      &from));
}

void SystemProfileProto_OS::MergeFrom(const SystemProfileProto_OS& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto.OS)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_build_fingerprint(from._internal_build_fingerprint());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_build_number(from._internal_build_number());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_kernel_version(from._internal_kernel_version());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_arc()->::metrics::SystemProfileProto_OS_Arc::MergeFrom(from._internal_arc());
    }
    if (cached_has_bits & 0x00000040u) {
      deprecated_is_jailbroken_ = from.deprecated_is_jailbroken_;
    }
    if (cached_has_bits & 0x00000080u) {
      dark_mode_state_ = from.dark_mode_state_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      xdg_session_type_ = from.xdg_session_type_;
    }
    if (cached_has_bits & 0x00000200u) {
      xdg_current_desktop_ = from.xdg_current_desktop_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto_OS::CopyFrom(const SystemProfileProto_OS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto.OS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto_OS::IsInitialized() const {
  return true;
}

void SystemProfileProto_OS::InternalSwap(SystemProfileProto_OS* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &version_, lhs_arena,
      &other->version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &build_fingerprint_, lhs_arena,
      &other->build_fingerprint_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &build_number_, lhs_arena,
      &other->build_number_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &kernel_version_, lhs_arena,
      &other->kernel_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemProfileProto_OS, xdg_current_desktop_)
      + sizeof(SystemProfileProto_OS::xdg_current_desktop_)
      - PROTOBUF_FIELD_OFFSET(SystemProfileProto_OS, arc_)>(
          reinterpret_cast<char*>(&arc_),
          reinterpret_cast<char*>(&other->arc_));
}

std::string SystemProfileProto_OS::GetTypeName() const {
  return "metrics.SystemProfileProto.OS";
}


// ===================================================================

class SystemProfileProto_Hardware_CPU::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto_Hardware_CPU>()._has_bits_);
  static void set_has_vendor_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_cores(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_hypervisor(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SystemProfileProto_Hardware_CPU::SystemProfileProto_Hardware_CPU(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto.Hardware.CPU)
}
SystemProfileProto_Hardware_CPU::SystemProfileProto_Hardware_CPU(const SystemProfileProto_Hardware_CPU& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  vendor_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    vendor_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vendor_name()) {
    vendor_name_.Set(from._internal_vendor_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&signature_, &from.signature_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_hypervisor_) -
    reinterpret_cast<char*>(&signature_)) + sizeof(is_hypervisor_));
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto.Hardware.CPU)
}

inline void SystemProfileProto_Hardware_CPU::SharedCtor() {
vendor_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  vendor_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&signature_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_hypervisor_) -
    reinterpret_cast<char*>(&signature_)) + sizeof(is_hypervisor_));
}

SystemProfileProto_Hardware_CPU::~SystemProfileProto_Hardware_CPU() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto.Hardware.CPU)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto_Hardware_CPU::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  vendor_name_.Destroy();
}

void SystemProfileProto_Hardware_CPU::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto_Hardware_CPU::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto.Hardware.CPU)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    vendor_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&signature_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_hypervisor_) -
        reinterpret_cast<char*>(&signature_)) + sizeof(is_hypervisor_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto_Hardware_CPU::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string vendor_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_vendor_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 signature = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_signature(&has_bits);
          signature_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_cores = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_num_cores(&has_bits);
          num_cores_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_hypervisor = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_hypervisor(&has_bits);
          is_hypervisor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto_Hardware_CPU::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto.Hardware.CPU)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string vendor_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_vendor_name(), target);
  }

  // optional uint32 signature = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_signature(), target);
  }

  // optional uint32 num_cores = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_num_cores(), target);
  }

  // optional bool is_hypervisor = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_hypervisor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto.Hardware.CPU)
  return target;
}

size_t SystemProfileProto_Hardware_CPU::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto.Hardware.CPU)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string vendor_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_vendor_name());
    }

    // optional uint32 signature = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_signature());
    }

    // optional uint32 num_cores = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_cores());
    }

    // optional bool is_hypervisor = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto_Hardware_CPU::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto_Hardware_CPU*>(
      &from));
}

void SystemProfileProto_Hardware_CPU::MergeFrom(const SystemProfileProto_Hardware_CPU& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto.Hardware.CPU)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_vendor_name(from._internal_vendor_name());
    }
    if (cached_has_bits & 0x00000002u) {
      signature_ = from.signature_;
    }
    if (cached_has_bits & 0x00000004u) {
      num_cores_ = from.num_cores_;
    }
    if (cached_has_bits & 0x00000008u) {
      is_hypervisor_ = from.is_hypervisor_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto_Hardware_CPU::CopyFrom(const SystemProfileProto_Hardware_CPU& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto.Hardware.CPU)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto_Hardware_CPU::IsInitialized() const {
  return true;
}

void SystemProfileProto_Hardware_CPU::InternalSwap(SystemProfileProto_Hardware_CPU* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &vendor_name_, lhs_arena,
      &other->vendor_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemProfileProto_Hardware_CPU, is_hypervisor_)
      + sizeof(SystemProfileProto_Hardware_CPU::is_hypervisor_)
      - PROTOBUF_FIELD_OFFSET(SystemProfileProto_Hardware_CPU, signature_)>(
          reinterpret_cast<char*>(&signature_),
          reinterpret_cast<char*>(&other->signature_));
}

std::string SystemProfileProto_Hardware_CPU::GetTypeName() const {
  return "metrics.SystemProfileProto.Hardware.CPU";
}


// ===================================================================

class SystemProfileProto_Hardware_Motherboard::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto_Hardware_Motherboard>()._has_bits_);
  static void set_has_manufacturer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_model(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bios_manufacturer(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bios_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_bios_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

SystemProfileProto_Hardware_Motherboard::SystemProfileProto_Hardware_Motherboard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto.Hardware.Motherboard)
}
SystemProfileProto_Hardware_Motherboard::SystemProfileProto_Hardware_Motherboard(const SystemProfileProto_Hardware_Motherboard& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  manufacturer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    manufacturer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_manufacturer()) {
    manufacturer_.Set(from._internal_manufacturer(), 
      GetArenaForAllocation());
  }
  model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model()) {
    model_.Set(from._internal_model(), 
      GetArenaForAllocation());
  }
  bios_manufacturer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    bios_manufacturer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_bios_manufacturer()) {
    bios_manufacturer_.Set(from._internal_bios_manufacturer(), 
      GetArenaForAllocation());
  }
  bios_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    bios_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_bios_version()) {
    bios_version_.Set(from._internal_bios_version(), 
      GetArenaForAllocation());
  }
  bios_type_ = from.bios_type_;
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto.Hardware.Motherboard)
}

inline void SystemProfileProto_Hardware_Motherboard::SharedCtor() {
manufacturer_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  manufacturer_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
model_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
bios_manufacturer_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  bios_manufacturer_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
bios_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  bios_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
bios_type_ = 0;
}

SystemProfileProto_Hardware_Motherboard::~SystemProfileProto_Hardware_Motherboard() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto.Hardware.Motherboard)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto_Hardware_Motherboard::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  manufacturer_.Destroy();
  model_.Destroy();
  bios_manufacturer_.Destroy();
  bios_version_.Destroy();
}

void SystemProfileProto_Hardware_Motherboard::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto_Hardware_Motherboard::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto.Hardware.Motherboard)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      manufacturer_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      model_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      bios_manufacturer_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      bios_version_.ClearNonDefaultToEmpty();
    }
  }
  bios_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto_Hardware_Motherboard::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string manufacturer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_manufacturer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string model = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_model();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string bios_manufacturer = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_bios_manufacturer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string bios_version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_bios_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.Hardware.BiosType bios_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_Hardware_BiosType_IsValid(val))) {
            _internal_set_bios_type(static_cast<::metrics::SystemProfileProto_Hardware_BiosType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto_Hardware_Motherboard::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto.Hardware.Motherboard)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string manufacturer = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_manufacturer(), target);
  }

  // optional string model = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_model(), target);
  }

  // optional string bios_manufacturer = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_bios_manufacturer(), target);
  }

  // optional string bios_version = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_bios_version(), target);
  }

  // optional .metrics.SystemProfileProto.Hardware.BiosType bios_type = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_bios_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto.Hardware.Motherboard)
  return target;
}

size_t SystemProfileProto_Hardware_Motherboard::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto.Hardware.Motherboard)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string manufacturer = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_manufacturer());
    }

    // optional string model = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model());
    }

    // optional string bios_manufacturer = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_bios_manufacturer());
    }

    // optional string bios_version = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_bios_version());
    }

    // optional .metrics.SystemProfileProto.Hardware.BiosType bios_type = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_bios_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto_Hardware_Motherboard::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto_Hardware_Motherboard*>(
      &from));
}

void SystemProfileProto_Hardware_Motherboard::MergeFrom(const SystemProfileProto_Hardware_Motherboard& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto.Hardware.Motherboard)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_manufacturer(from._internal_manufacturer());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_model(from._internal_model());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_bios_manufacturer(from._internal_bios_manufacturer());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_bios_version(from._internal_bios_version());
    }
    if (cached_has_bits & 0x00000010u) {
      bios_type_ = from.bios_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto_Hardware_Motherboard::CopyFrom(const SystemProfileProto_Hardware_Motherboard& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto.Hardware.Motherboard)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto_Hardware_Motherboard::IsInitialized() const {
  return true;
}

void SystemProfileProto_Hardware_Motherboard::InternalSwap(SystemProfileProto_Hardware_Motherboard* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &manufacturer_, lhs_arena,
      &other->manufacturer_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &model_, lhs_arena,
      &other->model_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &bios_manufacturer_, lhs_arena,
      &other->bios_manufacturer_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &bios_version_, lhs_arena,
      &other->bios_version_, rhs_arena
  );
  swap(bios_type_, other->bios_type_);
}

std::string SystemProfileProto_Hardware_Motherboard::GetTypeName() const {
  return "metrics.SystemProfileProto.Hardware.Motherboard";
}


// ===================================================================

class SystemProfileProto_Hardware_Graphics::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto_Hardware_Graphics>()._has_bits_);
  static void set_has_vendor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_driver_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_gl_vendor(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_gl_renderer(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SystemProfileProto_Hardware_Graphics::SystemProfileProto_Hardware_Graphics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto.Hardware.Graphics)
}
SystemProfileProto_Hardware_Graphics::SystemProfileProto_Hardware_Graphics(const SystemProfileProto_Hardware_Graphics& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  driver_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    driver_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_driver_version()) {
    driver_version_.Set(from._internal_driver_version(), 
      GetArenaForAllocation());
  }
  gl_vendor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    gl_vendor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gl_vendor()) {
    gl_vendor_.Set(from._internal_gl_vendor(), 
      GetArenaForAllocation());
  }
  gl_renderer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    gl_renderer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gl_renderer()) {
    gl_renderer_.Set(from._internal_gl_renderer(), 
      GetArenaForAllocation());
  }
  ::memcpy(&vendor_id_, &from.vendor_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&device_id_) -
    reinterpret_cast<char*>(&vendor_id_)) + sizeof(device_id_));
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto.Hardware.Graphics)
}

inline void SystemProfileProto_Hardware_Graphics::SharedCtor() {
driver_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  driver_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
gl_vendor_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  gl_vendor_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
gl_renderer_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  gl_renderer_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&vendor_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&device_id_) -
    reinterpret_cast<char*>(&vendor_id_)) + sizeof(device_id_));
}

SystemProfileProto_Hardware_Graphics::~SystemProfileProto_Hardware_Graphics() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto.Hardware.Graphics)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto_Hardware_Graphics::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  driver_version_.Destroy();
  gl_vendor_.Destroy();
  gl_renderer_.Destroy();
}

void SystemProfileProto_Hardware_Graphics::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto_Hardware_Graphics::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto.Hardware.Graphics)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      driver_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      gl_vendor_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      gl_renderer_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&vendor_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&device_id_) -
        reinterpret_cast<char*>(&vendor_id_)) + sizeof(device_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto_Hardware_Graphics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 vendor_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_vendor_id(&has_bits);
          vendor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 device_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_device_id(&has_bits);
          device_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string driver_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_driver_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string gl_vendor = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_gl_vendor();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string gl_renderer = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_gl_renderer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto_Hardware_Graphics::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto.Hardware.Graphics)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 vendor_id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_vendor_id(), target);
  }

  // optional uint32 device_id = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_device_id(), target);
  }

  // optional string driver_version = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_driver_version(), target);
  }

  // optional string gl_vendor = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_gl_vendor(), target);
  }

  // optional string gl_renderer = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_gl_renderer(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto.Hardware.Graphics)
  return target;
}

size_t SystemProfileProto_Hardware_Graphics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto.Hardware.Graphics)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string driver_version = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_driver_version());
    }

    // optional string gl_vendor = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gl_vendor());
    }

    // optional string gl_renderer = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gl_renderer());
    }

    // optional uint32 vendor_id = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_vendor_id());
    }

    // optional uint32 device_id = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_device_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto_Hardware_Graphics::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto_Hardware_Graphics*>(
      &from));
}

void SystemProfileProto_Hardware_Graphics::MergeFrom(const SystemProfileProto_Hardware_Graphics& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto.Hardware.Graphics)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_driver_version(from._internal_driver_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_gl_vendor(from._internal_gl_vendor());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_gl_renderer(from._internal_gl_renderer());
    }
    if (cached_has_bits & 0x00000008u) {
      vendor_id_ = from.vendor_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      device_id_ = from.device_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto_Hardware_Graphics::CopyFrom(const SystemProfileProto_Hardware_Graphics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto.Hardware.Graphics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto_Hardware_Graphics::IsInitialized() const {
  return true;
}

void SystemProfileProto_Hardware_Graphics::InternalSwap(SystemProfileProto_Hardware_Graphics* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &driver_version_, lhs_arena,
      &other->driver_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &gl_vendor_, lhs_arena,
      &other->gl_vendor_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &gl_renderer_, lhs_arena,
      &other->gl_renderer_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemProfileProto_Hardware_Graphics, device_id_)
      + sizeof(SystemProfileProto_Hardware_Graphics::device_id_)
      - PROTOBUF_FIELD_OFFSET(SystemProfileProto_Hardware_Graphics, vendor_id_)>(
          reinterpret_cast<char*>(&vendor_id_),
          reinterpret_cast<char*>(&other->vendor_id_));
}

std::string SystemProfileProto_Hardware_Graphics::GetTypeName() const {
  return "metrics.SystemProfileProto.Hardware.Graphics";
}


// ===================================================================

class SystemProfileProto_Hardware_InternalStorageDevice::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto_Hardware_InternalStorageDevice>()._has_bits_);
  static void set_has_vendor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_product_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_revision(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_model(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_size_mb(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_firmware_version(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_purpose(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

SystemProfileProto_Hardware_InternalStorageDevice::SystemProfileProto_Hardware_InternalStorageDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto.Hardware.InternalStorageDevice)
}
SystemProfileProto_Hardware_InternalStorageDevice::SystemProfileProto_Hardware_InternalStorageDevice(const SystemProfileProto_Hardware_InternalStorageDevice& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model()) {
    model_.Set(from._internal_model(), 
      GetArenaForAllocation());
  }
  ::memcpy(&product_id_, &from.product_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&purpose_) -
    reinterpret_cast<char*>(&product_id_)) + sizeof(purpose_));
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto.Hardware.InternalStorageDevice)
}

inline void SystemProfileProto_Hardware_InternalStorageDevice::SharedCtor() {
model_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&product_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&purpose_) -
    reinterpret_cast<char*>(&product_id_)) + sizeof(purpose_));
}

SystemProfileProto_Hardware_InternalStorageDevice::~SystemProfileProto_Hardware_InternalStorageDevice() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto.Hardware.InternalStorageDevice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto_Hardware_InternalStorageDevice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  model_.Destroy();
}

void SystemProfileProto_Hardware_InternalStorageDevice::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto_Hardware_InternalStorageDevice::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto.Hardware.InternalStorageDevice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    model_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&product_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&purpose_) -
        reinterpret_cast<char*>(&product_id_)) + sizeof(purpose_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto_Hardware_InternalStorageDevice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 vendor_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_vendor_id(&has_bits);
          vendor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 product_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_product_id(&has_bits);
          product_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 revision = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_revision(&has_bits);
          revision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string model = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_model();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 size_mb = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_size_mb(&has_bits);
          size_mb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 firmware_version = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_firmware_version(&has_bits);
          firmware_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.Hardware.InternalStorageDevice.Type type = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_Hardware_InternalStorageDevice_Type_IsValid(val))) {
            _internal_set_type(static_cast<::metrics::SystemProfileProto_Hardware_InternalStorageDevice_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.Hardware.InternalStorageDevice.Purpose purpose = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_Hardware_InternalStorageDevice_Purpose_IsValid(val))) {
            _internal_set_purpose(static_cast<::metrics::SystemProfileProto_Hardware_InternalStorageDevice_Purpose>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto_Hardware_InternalStorageDevice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto.Hardware.InternalStorageDevice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 vendor_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_vendor_id(), target);
  }

  // optional uint64 product_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_product_id(), target);
  }

  // optional uint32 revision = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_revision(), target);
  }

  // optional string model = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_model(), target);
  }

  // optional uint32 size_mb = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_size_mb(), target);
  }

  // optional uint64 firmware_version = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_firmware_version(), target);
  }

  // optional .metrics.SystemProfileProto.Hardware.InternalStorageDevice.Type type = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_type(), target);
  }

  // optional .metrics.SystemProfileProto.Hardware.InternalStorageDevice.Purpose purpose = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_purpose(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto.Hardware.InternalStorageDevice)
  return target;
}

size_t SystemProfileProto_Hardware_InternalStorageDevice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto.Hardware.InternalStorageDevice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string model = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model());
    }

    // optional uint64 product_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_product_id());
    }

    // optional uint32 vendor_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_vendor_id());
    }

    // optional uint32 revision = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_revision());
    }

    // optional uint64 firmware_version = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_firmware_version());
    }

    // optional uint32 size_mb = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_size_mb());
    }

    // optional .metrics.SystemProfileProto.Hardware.InternalStorageDevice.Type type = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional .metrics.SystemProfileProto.Hardware.InternalStorageDevice.Purpose purpose = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_purpose());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto_Hardware_InternalStorageDevice::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto_Hardware_InternalStorageDevice*>(
      &from));
}

void SystemProfileProto_Hardware_InternalStorageDevice::MergeFrom(const SystemProfileProto_Hardware_InternalStorageDevice& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto.Hardware.InternalStorageDevice)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_model(from._internal_model());
    }
    if (cached_has_bits & 0x00000002u) {
      product_id_ = from.product_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      vendor_id_ = from.vendor_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      revision_ = from.revision_;
    }
    if (cached_has_bits & 0x00000010u) {
      firmware_version_ = from.firmware_version_;
    }
    if (cached_has_bits & 0x00000020u) {
      size_mb_ = from.size_mb_;
    }
    if (cached_has_bits & 0x00000040u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000080u) {
      purpose_ = from.purpose_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto_Hardware_InternalStorageDevice::CopyFrom(const SystemProfileProto_Hardware_InternalStorageDevice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto.Hardware.InternalStorageDevice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto_Hardware_InternalStorageDevice::IsInitialized() const {
  return true;
}

void SystemProfileProto_Hardware_InternalStorageDevice::InternalSwap(SystemProfileProto_Hardware_InternalStorageDevice* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &model_, lhs_arena,
      &other->model_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemProfileProto_Hardware_InternalStorageDevice, purpose_)
      + sizeof(SystemProfileProto_Hardware_InternalStorageDevice::purpose_)
      - PROTOBUF_FIELD_OFFSET(SystemProfileProto_Hardware_InternalStorageDevice, product_id_)>(
          reinterpret_cast<char*>(&product_id_),
          reinterpret_cast<char*>(&other->product_id_));
}

std::string SystemProfileProto_Hardware_InternalStorageDevice::GetTypeName() const {
  return "metrics.SystemProfileProto.Hardware.InternalStorageDevice";
}


// ===================================================================

class SystemProfileProto_Hardware_Drive::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto_Hardware_Drive>()._has_bits_);
  static void set_has_has_seek_penalty(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SystemProfileProto_Hardware_Drive::SystemProfileProto_Hardware_Drive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto.Hardware.Drive)
}
SystemProfileProto_Hardware_Drive::SystemProfileProto_Hardware_Drive(const SystemProfileProto_Hardware_Drive& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  has_seek_penalty_ = from.has_seek_penalty_;
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto.Hardware.Drive)
}

inline void SystemProfileProto_Hardware_Drive::SharedCtor() {
has_seek_penalty_ = false;
}

SystemProfileProto_Hardware_Drive::~SystemProfileProto_Hardware_Drive() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto.Hardware.Drive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto_Hardware_Drive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SystemProfileProto_Hardware_Drive::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto_Hardware_Drive::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto.Hardware.Drive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  has_seek_penalty_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto_Hardware_Drive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool has_seek_penalty = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_has_seek_penalty(&has_bits);
          has_seek_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto_Hardware_Drive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto.Hardware.Drive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool has_seek_penalty = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_has_seek_penalty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto.Hardware.Drive)
  return target;
}

size_t SystemProfileProto_Hardware_Drive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto.Hardware.Drive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool has_seek_penalty = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto_Hardware_Drive::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto_Hardware_Drive*>(
      &from));
}

void SystemProfileProto_Hardware_Drive::MergeFrom(const SystemProfileProto_Hardware_Drive& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto.Hardware.Drive)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_has_seek_penalty()) {
    _internal_set_has_seek_penalty(from._internal_has_seek_penalty());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto_Hardware_Drive::CopyFrom(const SystemProfileProto_Hardware_Drive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto.Hardware.Drive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto_Hardware_Drive::IsInitialized() const {
  return true;
}

void SystemProfileProto_Hardware_Drive::InternalSwap(SystemProfileProto_Hardware_Drive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(has_seek_penalty_, other->has_seek_penalty_);
}

std::string SystemProfileProto_Hardware_Drive::GetTypeName() const {
  return "metrics.SystemProfileProto.Hardware.Drive";
}


// ===================================================================

class SystemProfileProto_Hardware::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto_Hardware>()._has_bits_);
  static void set_has_cpu_architecture(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_app_cpu_architecture(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_system_ram_mb(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_dll_base(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_hardware_class(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_full_hardware_class(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_cellular_device_variant(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_screen_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_primary_screen_width(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_primary_screen_height(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_primary_screen_scale_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_max_dpi_x(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_max_dpi_y(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_form_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static const ::metrics::SystemProfileProto_Hardware_CPU& cpu(const SystemProfileProto_Hardware* msg);
  static void set_has_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::metrics::SystemProfileProto_Hardware_Motherboard& motherboard(const SystemProfileProto_Hardware* msg);
  static void set_has_motherboard(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::metrics::SystemProfileProto_Hardware_Graphics& gpu(const SystemProfileProto_Hardware* msg);
  static void set_has_gpu(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_internal_display_supports_touch(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::metrics::SystemProfileProto_Hardware_Drive& app_drive(const SystemProfileProto_Hardware* msg);
  static void set_has_app_drive(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::metrics::SystemProfileProto_Hardware_Drive& user_data_drive(const SystemProfileProto_Hardware* msg);
  static void set_has_user_data_drive(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_tpm_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_tpm_firmware_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_tpm_rw_firmware_version(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::metrics::SystemProfileProto_Hardware_CPU&
SystemProfileProto_Hardware::_Internal::cpu(const SystemProfileProto_Hardware* msg) {
  return *msg->cpu_;
}
const ::metrics::SystemProfileProto_Hardware_Motherboard&
SystemProfileProto_Hardware::_Internal::motherboard(const SystemProfileProto_Hardware* msg) {
  return *msg->motherboard_;
}
const ::metrics::SystemProfileProto_Hardware_Graphics&
SystemProfileProto_Hardware::_Internal::gpu(const SystemProfileProto_Hardware* msg) {
  return *msg->gpu_;
}
const ::metrics::SystemProfileProto_Hardware_Drive&
SystemProfileProto_Hardware::_Internal::app_drive(const SystemProfileProto_Hardware* msg) {
  return *msg->app_drive_;
}
const ::metrics::SystemProfileProto_Hardware_Drive&
SystemProfileProto_Hardware::_Internal::user_data_drive(const SystemProfileProto_Hardware* msg) {
  return *msg->user_data_drive_;
}
SystemProfileProto_Hardware::SystemProfileProto_Hardware(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  internal_storage_devices_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto.Hardware)
}
SystemProfileProto_Hardware::SystemProfileProto_Hardware(const SystemProfileProto_Hardware& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      internal_storage_devices_(from.internal_storage_devices_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  cpu_architecture_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    cpu_architecture_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cpu_architecture()) {
    cpu_architecture_.Set(from._internal_cpu_architecture(), 
      GetArenaForAllocation());
  }
  hardware_class_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    hardware_class_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hardware_class()) {
    hardware_class_.Set(from._internal_hardware_class(), 
      GetArenaForAllocation());
  }
  full_hardware_class_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    full_hardware_class_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_full_hardware_class()) {
    full_hardware_class_.Set(from._internal_full_hardware_class(), 
      GetArenaForAllocation());
  }
  app_cpu_architecture_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    app_cpu_architecture_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_app_cpu_architecture()) {
    app_cpu_architecture_.Set(from._internal_app_cpu_architecture(), 
      GetArenaForAllocation());
  }
  cellular_device_variant_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    cellular_device_variant_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cellular_device_variant()) {
    cellular_device_variant_.Set(from._internal_cellular_device_variant(), 
      GetArenaForAllocation());
  }
  tpm_rw_firmware_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    tpm_rw_firmware_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tpm_rw_firmware_version()) {
    tpm_rw_firmware_version_.Set(from._internal_tpm_rw_firmware_version(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_gpu()) {
    gpu_ = new ::metrics::SystemProfileProto_Hardware_Graphics(*from.gpu_);
  } else {
    gpu_ = nullptr;
  }
  if (from._internal_has_cpu()) {
    cpu_ = new ::metrics::SystemProfileProto_Hardware_CPU(*from.cpu_);
  } else {
    cpu_ = nullptr;
  }
  if (from._internal_has_app_drive()) {
    app_drive_ = new ::metrics::SystemProfileProto_Hardware_Drive(*from.app_drive_);
  } else {
    app_drive_ = nullptr;
  }
  if (from._internal_has_user_data_drive()) {
    user_data_drive_ = new ::metrics::SystemProfileProto_Hardware_Drive(*from.user_data_drive_);
  } else {
    user_data_drive_ = nullptr;
  }
  if (from._internal_has_motherboard()) {
    motherboard_ = new ::metrics::SystemProfileProto_Hardware_Motherboard(*from.motherboard_);
  } else {
    motherboard_ = nullptr;
  }
  ::memcpy(&system_ram_mb_, &from.system_ram_mb_,
    static_cast<size_t>(reinterpret_cast<char*>(&tpm_type_) -
    reinterpret_cast<char*>(&system_ram_mb_)) + sizeof(tpm_type_));
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto.Hardware)
}

inline void SystemProfileProto_Hardware::SharedCtor() {
cpu_architecture_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  cpu_architecture_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
hardware_class_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  hardware_class_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
full_hardware_class_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  full_hardware_class_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
app_cpu_architecture_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  app_cpu_architecture_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
cellular_device_variant_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  cellular_device_variant_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
tpm_rw_firmware_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  tpm_rw_firmware_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gpu_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&tpm_type_) -
    reinterpret_cast<char*>(&gpu_)) + sizeof(tpm_type_));
}

SystemProfileProto_Hardware::~SystemProfileProto_Hardware() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto.Hardware)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto_Hardware::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  cpu_architecture_.Destroy();
  hardware_class_.Destroy();
  full_hardware_class_.Destroy();
  app_cpu_architecture_.Destroy();
  cellular_device_variant_.Destroy();
  tpm_rw_firmware_version_.Destroy();
  if (this != internal_default_instance()) delete gpu_;
  if (this != internal_default_instance()) delete cpu_;
  if (this != internal_default_instance()) delete app_drive_;
  if (this != internal_default_instance()) delete user_data_drive_;
  if (this != internal_default_instance()) delete motherboard_;
}

void SystemProfileProto_Hardware::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto_Hardware::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto.Hardware)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  internal_storage_devices_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      cpu_architecture_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      hardware_class_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      full_hardware_class_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      app_cpu_architecture_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      cellular_device_variant_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      tpm_rw_firmware_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(gpu_ != nullptr);
      gpu_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(cpu_ != nullptr);
      cpu_->Clear();
    }
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(app_drive_ != nullptr);
      app_drive_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(user_data_drive_ != nullptr);
      user_data_drive_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(motherboard_ != nullptr);
      motherboard_->Clear();
    }
  }
  if (cached_has_bits & 0x0000f800u) {
    ::memset(&system_ram_mb_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&primary_screen_height_) -
        reinterpret_cast<char*>(&system_ram_mb_)) + sizeof(primary_screen_height_));
  }
  if (cached_has_bits & 0x007f0000u) {
    ::memset(&max_dpi_x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&tpm_type_) -
        reinterpret_cast<char*>(&max_dpi_x_)) + sizeof(tpm_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto_Hardware::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string cpu_architecture = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_cpu_architecture();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 system_ram_mb = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_system_ram_mb(&has_bits);
          system_ram_mb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 dll_base = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_dll_base(&has_bits);
          dll_base_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string hardware_class = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_hardware_class();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 screen_count = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_screen_count(&has_bits);
          screen_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 primary_screen_width = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_primary_screen_width(&has_bits);
          primary_screen_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 primary_screen_height = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_primary_screen_height(&has_bits);
          primary_screen_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.Hardware.Graphics gpu = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_gpu(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float max_dpi_x = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_max_dpi_x(&has_bits);
          max_dpi_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float max_dpi_y = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_max_dpi_y(&has_bits);
          max_dpi_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float primary_screen_scale_factor = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _Internal::set_has_primary_screen_scale_factor(&has_bits);
          primary_screen_scale_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.Hardware.CPU cpu = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_cpu(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool internal_display_supports_touch = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_internal_display_supports_touch(&has_bits);
          internal_display_supports_touch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.Hardware.Drive app_drive = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_app_drive(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.Hardware.Drive user_data_drive = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_user_data_drive(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string full_hardware_class = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          auto str = _internal_mutable_full_hardware_class();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .metrics.SystemProfileProto.Hardware.InternalStorageDevice internal_storage_devices = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_internal_storage_devices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string app_cpu_architecture = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_app_cpu_architecture();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.Hardware.FormFactor form_factor = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_Hardware_FormFactor_IsValid(val))) {
            _internal_set_form_factor(static_cast<::metrics::SystemProfileProto_Hardware_FormFactor>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(22, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.Hardware.TpmType tpm_type = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_Hardware_TpmType_IsValid(val))) {
            _internal_set_tpm_type(static_cast<::metrics::SystemProfileProto_Hardware_TpmType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(23, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string cellular_device_variant = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          auto str = _internal_mutable_cellular_device_variant();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.Hardware.Motherboard motherboard = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_motherboard(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 tpm_firmware_version = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_tpm_firmware_version(&has_bits);
          tpm_firmware_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string tpm_rw_firmware_version = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          auto str = _internal_mutable_tpm_rw_firmware_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto_Hardware::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto.Hardware)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string cpu_architecture = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_cpu_architecture(), target);
  }

  // optional int64 system_ram_mb = 2;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_system_ram_mb(), target);
  }

  // optional int64 dll_base = 3;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_dll_base(), target);
  }

  // optional string hardware_class = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_hardware_class(), target);
  }

  // optional int32 screen_count = 5;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_screen_count(), target);
  }

  // optional int32 primary_screen_width = 6;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_primary_screen_width(), target);
  }

  // optional int32 primary_screen_height = 7;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_primary_screen_height(), target);
  }

  // optional .metrics.SystemProfileProto.Hardware.Graphics gpu = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::gpu(this),
        _Internal::gpu(this).GetCachedSize(), target, stream);
  }

  // optional float max_dpi_x = 9;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_max_dpi_x(), target);
  }

  // optional float max_dpi_y = 10;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_max_dpi_y(), target);
  }

  // optional float primary_screen_scale_factor = 12;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(12, this->_internal_primary_screen_scale_factor(), target);
  }

  // optional .metrics.SystemProfileProto.Hardware.CPU cpu = 13;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::cpu(this),
        _Internal::cpu(this).GetCachedSize(), target, stream);
  }

  // optional bool internal_display_supports_touch = 14;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_internal_display_supports_touch(), target);
  }

  // optional .metrics.SystemProfileProto.Hardware.Drive app_drive = 16;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::app_drive(this),
        _Internal::app_drive(this).GetCachedSize(), target, stream);
  }

  // optional .metrics.SystemProfileProto.Hardware.Drive user_data_drive = 17;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::user_data_drive(this),
        _Internal::user_data_drive(this).GetCachedSize(), target, stream);
  }

  // optional string full_hardware_class = 18;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        18, this->_internal_full_hardware_class(), target);
  }

  // repeated .metrics.SystemProfileProto.Hardware.InternalStorageDevice internal_storage_devices = 20;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_internal_storage_devices_size()); i < n; i++) {
    const auto& repfield = this->_internal_internal_storage_devices(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(20, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string app_cpu_architecture = 21;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        21, this->_internal_app_cpu_architecture(), target);
  }

  // optional .metrics.SystemProfileProto.Hardware.FormFactor form_factor = 22;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      22, this->_internal_form_factor(), target);
  }

  // optional .metrics.SystemProfileProto.Hardware.TpmType tpm_type = 23;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      23, this->_internal_tpm_type(), target);
  }

  // optional string cellular_device_variant = 24;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        24, this->_internal_cellular_device_variant(), target);
  }

  // optional .metrics.SystemProfileProto.Hardware.Motherboard motherboard = 25;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(25, _Internal::motherboard(this),
        _Internal::motherboard(this).GetCachedSize(), target, stream);
  }

  // optional uint64 tpm_firmware_version = 26;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(26, this->_internal_tpm_firmware_version(), target);
  }

  // optional string tpm_rw_firmware_version = 27;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        27, this->_internal_tpm_rw_firmware_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto.Hardware)
  return target;
}

size_t SystemProfileProto_Hardware::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto.Hardware)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .metrics.SystemProfileProto.Hardware.InternalStorageDevice internal_storage_devices = 20;
  total_size += 2UL * this->_internal_internal_storage_devices_size();
  for (const auto& msg : this->internal_storage_devices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string cpu_architecture = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cpu_architecture());
    }

    // optional string hardware_class = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hardware_class());
    }

    // optional string full_hardware_class = 18;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_full_hardware_class());
    }

    // optional string app_cpu_architecture = 21;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_app_cpu_architecture());
    }

    // optional string cellular_device_variant = 24;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cellular_device_variant());
    }

    // optional string tpm_rw_firmware_version = 27;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tpm_rw_firmware_version());
    }

    // optional .metrics.SystemProfileProto.Hardware.Graphics gpu = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gpu_);
    }

    // optional .metrics.SystemProfileProto.Hardware.CPU cpu = 13;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cpu_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .metrics.SystemProfileProto.Hardware.Drive app_drive = 16;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *app_drive_);
    }

    // optional .metrics.SystemProfileProto.Hardware.Drive user_data_drive = 17;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *user_data_drive_);
    }

    // optional .metrics.SystemProfileProto.Hardware.Motherboard motherboard = 25;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *motherboard_);
    }

    // optional int64 system_ram_mb = 2;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_system_ram_mb());
    }

    // optional int64 dll_base = 3;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_dll_base());
    }

    // optional int32 screen_count = 5;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_screen_count());
    }

    // optional int32 primary_screen_width = 6;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_primary_screen_width());
    }

    // optional int32 primary_screen_height = 7;
    if (cached_has_bits & 0x00008000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_primary_screen_height());
    }

  }
  if (cached_has_bits & 0x007f0000u) {
    // optional float max_dpi_x = 9;
    if (cached_has_bits & 0x00010000u) {
      total_size += 1 + 4;
    }

    // optional float max_dpi_y = 10;
    if (cached_has_bits & 0x00020000u) {
      total_size += 1 + 4;
    }

    // optional float primary_screen_scale_factor = 12;
    if (cached_has_bits & 0x00040000u) {
      total_size += 1 + 4;
    }

    // optional bool internal_display_supports_touch = 14;
    if (cached_has_bits & 0x00080000u) {
      total_size += 1 + 1;
    }

    // optional .metrics.SystemProfileProto.Hardware.FormFactor form_factor = 22;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_form_factor());
    }

    // optional uint64 tpm_firmware_version = 26;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_tpm_firmware_version());
    }

    // optional .metrics.SystemProfileProto.Hardware.TpmType tpm_type = 23;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_tpm_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto_Hardware::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto_Hardware*>(
      &from));
}

void SystemProfileProto_Hardware::MergeFrom(const SystemProfileProto_Hardware& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto.Hardware)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  internal_storage_devices_.MergeFrom(from.internal_storage_devices_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_cpu_architecture(from._internal_cpu_architecture());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_hardware_class(from._internal_hardware_class());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_full_hardware_class(from._internal_full_hardware_class());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_app_cpu_architecture(from._internal_app_cpu_architecture());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_cellular_device_variant(from._internal_cellular_device_variant());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_tpm_rw_firmware_version(from._internal_tpm_rw_firmware_version());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_gpu()->::metrics::SystemProfileProto_Hardware_Graphics::MergeFrom(from._internal_gpu());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_cpu()->::metrics::SystemProfileProto_Hardware_CPU::MergeFrom(from._internal_cpu());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_app_drive()->::metrics::SystemProfileProto_Hardware_Drive::MergeFrom(from._internal_app_drive());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_mutable_user_data_drive()->::metrics::SystemProfileProto_Hardware_Drive::MergeFrom(from._internal_user_data_drive());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_mutable_motherboard()->::metrics::SystemProfileProto_Hardware_Motherboard::MergeFrom(from._internal_motherboard());
    }
    if (cached_has_bits & 0x00000800u) {
      system_ram_mb_ = from.system_ram_mb_;
    }
    if (cached_has_bits & 0x00001000u) {
      dll_base_ = from.dll_base_;
    }
    if (cached_has_bits & 0x00002000u) {
      screen_count_ = from.screen_count_;
    }
    if (cached_has_bits & 0x00004000u) {
      primary_screen_width_ = from.primary_screen_width_;
    }
    if (cached_has_bits & 0x00008000u) {
      primary_screen_height_ = from.primary_screen_height_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x007f0000u) {
    if (cached_has_bits & 0x00010000u) {
      max_dpi_x_ = from.max_dpi_x_;
    }
    if (cached_has_bits & 0x00020000u) {
      max_dpi_y_ = from.max_dpi_y_;
    }
    if (cached_has_bits & 0x00040000u) {
      primary_screen_scale_factor_ = from.primary_screen_scale_factor_;
    }
    if (cached_has_bits & 0x00080000u) {
      internal_display_supports_touch_ = from.internal_display_supports_touch_;
    }
    if (cached_has_bits & 0x00100000u) {
      form_factor_ = from.form_factor_;
    }
    if (cached_has_bits & 0x00200000u) {
      tpm_firmware_version_ = from.tpm_firmware_version_;
    }
    if (cached_has_bits & 0x00400000u) {
      tpm_type_ = from.tpm_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto_Hardware::CopyFrom(const SystemProfileProto_Hardware& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto.Hardware)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto_Hardware::IsInitialized() const {
  return true;
}

void SystemProfileProto_Hardware::InternalSwap(SystemProfileProto_Hardware* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  internal_storage_devices_.InternalSwap(&other->internal_storage_devices_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &cpu_architecture_, lhs_arena,
      &other->cpu_architecture_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &hardware_class_, lhs_arena,
      &other->hardware_class_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &full_hardware_class_, lhs_arena,
      &other->full_hardware_class_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &app_cpu_architecture_, lhs_arena,
      &other->app_cpu_architecture_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &cellular_device_variant_, lhs_arena,
      &other->cellular_device_variant_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &tpm_rw_firmware_version_, lhs_arena,
      &other->tpm_rw_firmware_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemProfileProto_Hardware, tpm_type_)
      + sizeof(SystemProfileProto_Hardware::tpm_type_)
      - PROTOBUF_FIELD_OFFSET(SystemProfileProto_Hardware, gpu_)>(
          reinterpret_cast<char*>(&gpu_),
          reinterpret_cast<char*>(&other->gpu_));
}

std::string SystemProfileProto_Hardware::GetTypeName() const {
  return "metrics.SystemProfileProto.Hardware";
}


// ===================================================================

class SystemProfileProto_Network::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto_Network>()._has_bits_);
  static void set_has_connection_type_is_ambiguous(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_connection_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_wifi_phy_layer_protocol_is_ambiguous(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_wifi_phy_layer_protocol(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_min_effective_connection_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_max_effective_connection_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

SystemProfileProto_Network::SystemProfileProto_Network(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto.Network)
}
SystemProfileProto_Network::SystemProfileProto_Network(const SystemProfileProto_Network& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&connection_type_, &from.connection_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_effective_connection_type_) -
    reinterpret_cast<char*>(&connection_type_)) + sizeof(max_effective_connection_type_));
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto.Network)
}

inline void SystemProfileProto_Network::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&connection_type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&max_effective_connection_type_) -
    reinterpret_cast<char*>(&connection_type_)) + sizeof(max_effective_connection_type_));
}

SystemProfileProto_Network::~SystemProfileProto_Network() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto.Network)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto_Network::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SystemProfileProto_Network::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto_Network::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto.Network)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&connection_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_effective_connection_type_) -
        reinterpret_cast<char*>(&connection_type_)) + sizeof(max_effective_connection_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto_Network::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool connection_type_is_ambiguous = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_connection_type_is_ambiguous(&has_bits);
          connection_type_is_ambiguous_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.Network.ConnectionType connection_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_Network_ConnectionType_IsValid(val))) {
            _internal_set_connection_type(static_cast<::metrics::SystemProfileProto_Network_ConnectionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool wifi_phy_layer_protocol_is_ambiguous = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_wifi_phy_layer_protocol_is_ambiguous(&has_bits);
          wifi_phy_layer_protocol_is_ambiguous_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.Network.WifiPHYLayerProtocol wifi_phy_layer_protocol = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_Network_WifiPHYLayerProtocol_IsValid(val))) {
            _internal_set_wifi_phy_layer_protocol(static_cast<::metrics::SystemProfileProto_Network_WifiPHYLayerProtocol>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.Network.EffectiveConnectionType min_effective_connection_type = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_Network_EffectiveConnectionType_IsValid(val))) {
            _internal_set_min_effective_connection_type(static_cast<::metrics::SystemProfileProto_Network_EffectiveConnectionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.Network.EffectiveConnectionType max_effective_connection_type = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_Network_EffectiveConnectionType_IsValid(val))) {
            _internal_set_max_effective_connection_type(static_cast<::metrics::SystemProfileProto_Network_EffectiveConnectionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto_Network::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto.Network)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool connection_type_is_ambiguous = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_connection_type_is_ambiguous(), target);
  }

  // optional .metrics.SystemProfileProto.Network.ConnectionType connection_type = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_connection_type(), target);
  }

  // optional bool wifi_phy_layer_protocol_is_ambiguous = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_wifi_phy_layer_protocol_is_ambiguous(), target);
  }

  // optional .metrics.SystemProfileProto.Network.WifiPHYLayerProtocol wifi_phy_layer_protocol = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_wifi_phy_layer_protocol(), target);
  }

  // optional .metrics.SystemProfileProto.Network.EffectiveConnectionType min_effective_connection_type = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_min_effective_connection_type(), target);
  }

  // optional .metrics.SystemProfileProto.Network.EffectiveConnectionType max_effective_connection_type = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_max_effective_connection_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto.Network)
  return target;
}

size_t SystemProfileProto_Network::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto.Network)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .metrics.SystemProfileProto.Network.ConnectionType connection_type = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_connection_type());
    }

    // optional bool connection_type_is_ambiguous = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool wifi_phy_layer_protocol_is_ambiguous = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional .metrics.SystemProfileProto.Network.WifiPHYLayerProtocol wifi_phy_layer_protocol = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_wifi_phy_layer_protocol());
    }

    // optional .metrics.SystemProfileProto.Network.EffectiveConnectionType min_effective_connection_type = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_min_effective_connection_type());
    }

    // optional .metrics.SystemProfileProto.Network.EffectiveConnectionType max_effective_connection_type = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_max_effective_connection_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto_Network::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto_Network*>(
      &from));
}

void SystemProfileProto_Network::MergeFrom(const SystemProfileProto_Network& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto.Network)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      connection_type_ = from.connection_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      connection_type_is_ambiguous_ = from.connection_type_is_ambiguous_;
    }
    if (cached_has_bits & 0x00000004u) {
      wifi_phy_layer_protocol_is_ambiguous_ = from.wifi_phy_layer_protocol_is_ambiguous_;
    }
    if (cached_has_bits & 0x00000008u) {
      wifi_phy_layer_protocol_ = from.wifi_phy_layer_protocol_;
    }
    if (cached_has_bits & 0x00000010u) {
      min_effective_connection_type_ = from.min_effective_connection_type_;
    }
    if (cached_has_bits & 0x00000020u) {
      max_effective_connection_type_ = from.max_effective_connection_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto_Network::CopyFrom(const SystemProfileProto_Network& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto.Network)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto_Network::IsInitialized() const {
  return true;
}

void SystemProfileProto_Network::InternalSwap(SystemProfileProto_Network* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemProfileProto_Network, max_effective_connection_type_)
      + sizeof(SystemProfileProto_Network::max_effective_connection_type_)
      - PROTOBUF_FIELD_OFFSET(SystemProfileProto_Network, connection_type_)>(
          reinterpret_cast<char*>(&connection_type_),
          reinterpret_cast<char*>(&other->connection_type_));
}

std::string SystemProfileProto_Network::GetTypeName() const {
  return "metrics.SystemProfileProto.Network";
}


// ===================================================================

class SystemProfileProto_GoogleUpdate_ProductInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto_GoogleUpdate_ProductInfo>()._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_last_update_success_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_last_result(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_last_error(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_last_extra_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

SystemProfileProto_GoogleUpdate_ProductInfo::SystemProfileProto_GoogleUpdate_ProductInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto.GoogleUpdate.ProductInfo)
}
SystemProfileProto_GoogleUpdate_ProductInfo::SystemProfileProto_GoogleUpdate_ProductInfo(const SystemProfileProto_GoogleUpdate_ProductInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version()) {
    version_.Set(from._internal_version(), 
      GetArenaForAllocation());
  }
  ::memcpy(&last_update_success_timestamp_, &from.last_update_success_timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&last_extra_error_) -
    reinterpret_cast<char*>(&last_update_success_timestamp_)) + sizeof(last_extra_error_));
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto.GoogleUpdate.ProductInfo)
}

inline void SystemProfileProto_GoogleUpdate_ProductInfo::SharedCtor() {
version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&last_update_success_timestamp_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&last_extra_error_) -
    reinterpret_cast<char*>(&last_update_success_timestamp_)) + sizeof(last_extra_error_));
}

SystemProfileProto_GoogleUpdate_ProductInfo::~SystemProfileProto_GoogleUpdate_ProductInfo() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto.GoogleUpdate.ProductInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto_GoogleUpdate_ProductInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  version_.Destroy();
}

void SystemProfileProto_GoogleUpdate_ProductInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto_GoogleUpdate_ProductInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto.GoogleUpdate.ProductInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    version_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&last_update_success_timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&last_extra_error_) -
        reinterpret_cast<char*>(&last_update_success_timestamp_)) + sizeof(last_extra_error_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto_GoogleUpdate_ProductInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 last_update_success_timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_last_update_success_timestamp(&has_bits);
          last_update_success_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.GoogleUpdate.ProductInfo.InstallResult last_result = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult_IsValid(val))) {
            _internal_set_last_result(static_cast<::metrics::SystemProfileProto_GoogleUpdate_ProductInfo_InstallResult>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 last_error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_last_error(&has_bits);
          last_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 last_extra_error = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_last_extra_error(&has_bits);
          last_extra_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto_GoogleUpdate_ProductInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto.GoogleUpdate.ProductInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_version(), target);
  }

  // optional int64 last_update_success_timestamp = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_last_update_success_timestamp(), target);
  }

  // optional .metrics.SystemProfileProto.GoogleUpdate.ProductInfo.InstallResult last_result = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_last_result(), target);
  }

  // optional int32 last_error = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_last_error(), target);
  }

  // optional int32 last_extra_error = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_last_extra_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto.GoogleUpdate.ProductInfo)
  return target;
}

size_t SystemProfileProto_GoogleUpdate_ProductInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto.GoogleUpdate.ProductInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string version = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version());
    }

    // optional int64 last_update_success_timestamp = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_last_update_success_timestamp());
    }

    // optional .metrics.SystemProfileProto.GoogleUpdate.ProductInfo.InstallResult last_result = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_last_result());
    }

    // optional int32 last_error = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_last_error());
    }

    // optional int32 last_extra_error = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_last_extra_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto_GoogleUpdate_ProductInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto_GoogleUpdate_ProductInfo*>(
      &from));
}

void SystemProfileProto_GoogleUpdate_ProductInfo::MergeFrom(const SystemProfileProto_GoogleUpdate_ProductInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto.GoogleUpdate.ProductInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000002u) {
      last_update_success_timestamp_ = from.last_update_success_timestamp_;
    }
    if (cached_has_bits & 0x00000004u) {
      last_result_ = from.last_result_;
    }
    if (cached_has_bits & 0x00000008u) {
      last_error_ = from.last_error_;
    }
    if (cached_has_bits & 0x00000010u) {
      last_extra_error_ = from.last_extra_error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto_GoogleUpdate_ProductInfo::CopyFrom(const SystemProfileProto_GoogleUpdate_ProductInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto.GoogleUpdate.ProductInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto_GoogleUpdate_ProductInfo::IsInitialized() const {
  return true;
}

void SystemProfileProto_GoogleUpdate_ProductInfo::InternalSwap(SystemProfileProto_GoogleUpdate_ProductInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &version_, lhs_arena,
      &other->version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemProfileProto_GoogleUpdate_ProductInfo, last_extra_error_)
      + sizeof(SystemProfileProto_GoogleUpdate_ProductInfo::last_extra_error_)
      - PROTOBUF_FIELD_OFFSET(SystemProfileProto_GoogleUpdate_ProductInfo, last_update_success_timestamp_)>(
          reinterpret_cast<char*>(&last_update_success_timestamp_),
          reinterpret_cast<char*>(&other->last_update_success_timestamp_));
}

std::string SystemProfileProto_GoogleUpdate_ProductInfo::GetTypeName() const {
  return "metrics.SystemProfileProto.GoogleUpdate.ProductInfo";
}


// ===================================================================

class SystemProfileProto_GoogleUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto_GoogleUpdate>()._has_bits_);
  static void set_has_is_system_install(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_last_automatic_start_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_last_update_check_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::metrics::SystemProfileProto_GoogleUpdate_ProductInfo& google_update_status(const SystemProfileProto_GoogleUpdate* msg);
  static void set_has_google_update_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::metrics::SystemProfileProto_GoogleUpdate_ProductInfo& client_status(const SystemProfileProto_GoogleUpdate* msg);
  static void set_has_client_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::metrics::SystemProfileProto_GoogleUpdate_ProductInfo&
SystemProfileProto_GoogleUpdate::_Internal::google_update_status(const SystemProfileProto_GoogleUpdate* msg) {
  return *msg->google_update_status_;
}
const ::metrics::SystemProfileProto_GoogleUpdate_ProductInfo&
SystemProfileProto_GoogleUpdate::_Internal::client_status(const SystemProfileProto_GoogleUpdate* msg) {
  return *msg->client_status_;
}
SystemProfileProto_GoogleUpdate::SystemProfileProto_GoogleUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto.GoogleUpdate)
}
SystemProfileProto_GoogleUpdate::SystemProfileProto_GoogleUpdate(const SystemProfileProto_GoogleUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_google_update_status()) {
    google_update_status_ = new ::metrics::SystemProfileProto_GoogleUpdate_ProductInfo(*from.google_update_status_);
  } else {
    google_update_status_ = nullptr;
  }
  if (from._internal_has_client_status()) {
    client_status_ = new ::metrics::SystemProfileProto_GoogleUpdate_ProductInfo(*from.client_status_);
  } else {
    client_status_ = nullptr;
  }
  ::memcpy(&last_automatic_start_timestamp_, &from.last_automatic_start_timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_system_install_) -
    reinterpret_cast<char*>(&last_automatic_start_timestamp_)) + sizeof(is_system_install_));
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto.GoogleUpdate)
}

inline void SystemProfileProto_GoogleUpdate::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&google_update_status_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_system_install_) -
    reinterpret_cast<char*>(&google_update_status_)) + sizeof(is_system_install_));
}

SystemProfileProto_GoogleUpdate::~SystemProfileProto_GoogleUpdate() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto.GoogleUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto_GoogleUpdate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete google_update_status_;
  if (this != internal_default_instance()) delete client_status_;
}

void SystemProfileProto_GoogleUpdate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto_GoogleUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto.GoogleUpdate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(google_update_status_ != nullptr);
      google_update_status_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(client_status_ != nullptr);
      client_status_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&last_automatic_start_timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_system_install_) -
        reinterpret_cast<char*>(&last_automatic_start_timestamp_)) + sizeof(is_system_install_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto_GoogleUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool is_system_install = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_is_system_install(&has_bits);
          is_system_install_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 last_automatic_start_timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_last_automatic_start_timestamp(&has_bits);
          last_automatic_start_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 last_update_check_timestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_last_update_check_timestamp(&has_bits);
          last_update_check_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.GoogleUpdate.ProductInfo google_update_status = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_google_update_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.GoogleUpdate.ProductInfo client_status = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto_GoogleUpdate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto.GoogleUpdate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool is_system_install = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_is_system_install(), target);
  }

  // optional int64 last_automatic_start_timestamp = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_last_automatic_start_timestamp(), target);
  }

  // optional int64 last_update_check_timestamp = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_last_update_check_timestamp(), target);
  }

  // optional .metrics.SystemProfileProto.GoogleUpdate.ProductInfo google_update_status = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::google_update_status(this),
        _Internal::google_update_status(this).GetCachedSize(), target, stream);
  }

  // optional .metrics.SystemProfileProto.GoogleUpdate.ProductInfo client_status = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::client_status(this),
        _Internal::client_status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto.GoogleUpdate)
  return target;
}

size_t SystemProfileProto_GoogleUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto.GoogleUpdate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .metrics.SystemProfileProto.GoogleUpdate.ProductInfo google_update_status = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *google_update_status_);
    }

    // optional .metrics.SystemProfileProto.GoogleUpdate.ProductInfo client_status = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_status_);
    }

    // optional int64 last_automatic_start_timestamp = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_last_automatic_start_timestamp());
    }

    // optional int64 last_update_check_timestamp = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_last_update_check_timestamp());
    }

    // optional bool is_system_install = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto_GoogleUpdate::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto_GoogleUpdate*>(
      &from));
}

void SystemProfileProto_GoogleUpdate::MergeFrom(const SystemProfileProto_GoogleUpdate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto.GoogleUpdate)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_google_update_status()->::metrics::SystemProfileProto_GoogleUpdate_ProductInfo::MergeFrom(from._internal_google_update_status());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_client_status()->::metrics::SystemProfileProto_GoogleUpdate_ProductInfo::MergeFrom(from._internal_client_status());
    }
    if (cached_has_bits & 0x00000004u) {
      last_automatic_start_timestamp_ = from.last_automatic_start_timestamp_;
    }
    if (cached_has_bits & 0x00000008u) {
      last_update_check_timestamp_ = from.last_update_check_timestamp_;
    }
    if (cached_has_bits & 0x00000010u) {
      is_system_install_ = from.is_system_install_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto_GoogleUpdate::CopyFrom(const SystemProfileProto_GoogleUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto.GoogleUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto_GoogleUpdate::IsInitialized() const {
  return true;
}

void SystemProfileProto_GoogleUpdate::InternalSwap(SystemProfileProto_GoogleUpdate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemProfileProto_GoogleUpdate, is_system_install_)
      + sizeof(SystemProfileProto_GoogleUpdate::is_system_install_)
      - PROTOBUF_FIELD_OFFSET(SystemProfileProto_GoogleUpdate, google_update_status_)>(
          reinterpret_cast<char*>(&google_update_status_),
          reinterpret_cast<char*>(&other->google_update_status_));
}

std::string SystemProfileProto_GoogleUpdate::GetTypeName() const {
  return "metrics.SystemProfileProto.GoogleUpdate";
}


// ===================================================================

class SystemProfileProto_Stability::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto_Stability>()._has_bits_);
  static void set_has_incremental_uptime_sec(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_uptime_sec(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_page_load_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_renderer_launch_count(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_other_user_crash_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_kernel_crash_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_unclean_system_shutdown_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_launch_count(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_crash_count_due_to_gms_core_update(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_from_previous_run(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

SystemProfileProto_Stability::SystemProfileProto_Stability(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto.Stability)
}
SystemProfileProto_Stability::SystemProfileProto_Stability(const SystemProfileProto_Stability& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&incremental_uptime_sec_, &from.incremental_uptime_sec_,
    static_cast<size_t>(reinterpret_cast<char*>(&crash_count_due_to_gms_core_update_) -
    reinterpret_cast<char*>(&incremental_uptime_sec_)) + sizeof(crash_count_due_to_gms_core_update_));
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto.Stability)
}

inline void SystemProfileProto_Stability::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&incremental_uptime_sec_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&crash_count_due_to_gms_core_update_) -
    reinterpret_cast<char*>(&incremental_uptime_sec_)) + sizeof(crash_count_due_to_gms_core_update_));
}

SystemProfileProto_Stability::~SystemProfileProto_Stability() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto.Stability)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto_Stability::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SystemProfileProto_Stability::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto_Stability::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto.Stability)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&incremental_uptime_sec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&uptime_sec_) -
        reinterpret_cast<char*>(&incremental_uptime_sec_)) + sizeof(uptime_sec_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&from_previous_run_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&crash_count_due_to_gms_core_update_) -
        reinterpret_cast<char*>(&from_previous_run_)) + sizeof(crash_count_due_to_gms_core_update_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto_Stability::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 incremental_uptime_sec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_incremental_uptime_sec(&has_bits);
          incremental_uptime_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 page_load_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_page_load_count(&has_bits);
          page_load_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 other_user_crash_count = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_other_user_crash_count(&has_bits);
          other_user_crash_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 kernel_crash_count = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_kernel_crash_count(&has_bits);
          kernel_crash_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 unclean_system_shutdown_count = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_unclean_system_shutdown_count(&has_bits);
          unclean_system_shutdown_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 launch_count = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_launch_count(&has_bits);
          launch_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 uptime_sec = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_uptime_sec(&has_bits);
          uptime_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 renderer_launch_count = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_renderer_launch_count(&has_bits);
          renderer_launch_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool from_previous_run = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_from_previous_run(&has_bits);
          from_previous_run_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 crash_count_due_to_gms_core_update = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_crash_count_due_to_gms_core_update(&has_bits);
          crash_count_due_to_gms_core_update_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto_Stability::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto.Stability)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 incremental_uptime_sec = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_incremental_uptime_sec(), target);
  }

  // optional int32 page_load_count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_page_load_count(), target);
  }

  // optional int32 other_user_crash_count = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_other_user_crash_count(), target);
  }

  // optional int32 kernel_crash_count = 8;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_kernel_crash_count(), target);
  }

  // optional int32 unclean_system_shutdown_count = 9;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_unclean_system_shutdown_count(), target);
  }

  // optional int32 launch_count = 15;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(15, this->_internal_launch_count(), target);
  }

  // optional int64 uptime_sec = 23;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(23, this->_internal_uptime_sec(), target);
  }

  // optional int32 renderer_launch_count = 26;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(26, this->_internal_renderer_launch_count(), target);
  }

  // optional bool from_previous_run = 29;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(29, this->_internal_from_previous_run(), target);
  }

  // optional int32 crash_count_due_to_gms_core_update = 30;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(30, this->_internal_crash_count_due_to_gms_core_update(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto.Stability)
  return target;
}

size_t SystemProfileProto_Stability::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto.Stability)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional int64 incremental_uptime_sec = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_incremental_uptime_sec());
    }

    // optional int32 page_load_count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_page_load_count());
    }

    // optional int32 other_user_crash_count = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_other_user_crash_count());
    }

    // optional int32 kernel_crash_count = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_kernel_crash_count());
    }

    // optional int32 unclean_system_shutdown_count = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_unclean_system_shutdown_count());
    }

    // optional int32 launch_count = 15;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_launch_count());
    }

    // optional int32 renderer_launch_count = 26;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_renderer_launch_count());
    }

    // optional int64 uptime_sec = 23;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_uptime_sec());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional bool from_previous_run = 29;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 + 1;
    }

    // optional int32 crash_count_due_to_gms_core_update = 30;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_crash_count_due_to_gms_core_update());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto_Stability::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto_Stability*>(
      &from));
}

void SystemProfileProto_Stability::MergeFrom(const SystemProfileProto_Stability& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto.Stability)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      incremental_uptime_sec_ = from.incremental_uptime_sec_;
    }
    if (cached_has_bits & 0x00000002u) {
      page_load_count_ = from.page_load_count_;
    }
    if (cached_has_bits & 0x00000004u) {
      other_user_crash_count_ = from.other_user_crash_count_;
    }
    if (cached_has_bits & 0x00000008u) {
      kernel_crash_count_ = from.kernel_crash_count_;
    }
    if (cached_has_bits & 0x00000010u) {
      unclean_system_shutdown_count_ = from.unclean_system_shutdown_count_;
    }
    if (cached_has_bits & 0x00000020u) {
      launch_count_ = from.launch_count_;
    }
    if (cached_has_bits & 0x00000040u) {
      renderer_launch_count_ = from.renderer_launch_count_;
    }
    if (cached_has_bits & 0x00000080u) {
      uptime_sec_ = from.uptime_sec_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      from_previous_run_ = from.from_previous_run_;
    }
    if (cached_has_bits & 0x00000200u) {
      crash_count_due_to_gms_core_update_ = from.crash_count_due_to_gms_core_update_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto_Stability::CopyFrom(const SystemProfileProto_Stability& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto.Stability)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto_Stability::IsInitialized() const {
  return true;
}

void SystemProfileProto_Stability::InternalSwap(SystemProfileProto_Stability* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemProfileProto_Stability, crash_count_due_to_gms_core_update_)
      + sizeof(SystemProfileProto_Stability::crash_count_due_to_gms_core_update_)
      - PROTOBUF_FIELD_OFFSET(SystemProfileProto_Stability, incremental_uptime_sec_)>(
          reinterpret_cast<char*>(&incremental_uptime_sec_),
          reinterpret_cast<char*>(&other->incremental_uptime_sec_));
}

std::string SystemProfileProto_Stability::GetTypeName() const {
  return "metrics.SystemProfileProto.Stability";
}


// ===================================================================

class SystemProfileProto_FieldTrial::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto_FieldTrial>()._has_bits_);
  static void set_has_name_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

SystemProfileProto_FieldTrial::SystemProfileProto_FieldTrial(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto.FieldTrial)
}
SystemProfileProto_FieldTrial::SystemProfileProto_FieldTrial(const SystemProfileProto_FieldTrial& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&name_id_, &from.name_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&group_id_) -
    reinterpret_cast<char*>(&name_id_)) + sizeof(group_id_));
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto.FieldTrial)
}

inline void SystemProfileProto_FieldTrial::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&name_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&group_id_) -
    reinterpret_cast<char*>(&name_id_)) + sizeof(group_id_));
}

SystemProfileProto_FieldTrial::~SystemProfileProto_FieldTrial() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto.FieldTrial)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto_FieldTrial::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SystemProfileProto_FieldTrial::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto_FieldTrial::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto.FieldTrial)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&name_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&group_id_) -
        reinterpret_cast<char*>(&name_id_)) + sizeof(group_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto_FieldTrial::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 name_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_name_id(&has_bits);
          name_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 group_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_group_id(&has_bits);
          group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto_FieldTrial::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto.FieldTrial)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed32 name_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_name_id(), target);
  }

  // optional fixed32 group_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_group_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto.FieldTrial)
  return target;
}

size_t SystemProfileProto_FieldTrial::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto.FieldTrial)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional fixed32 name_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional fixed32 group_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto_FieldTrial::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto_FieldTrial*>(
      &from));
}

void SystemProfileProto_FieldTrial::MergeFrom(const SystemProfileProto_FieldTrial& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto.FieldTrial)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_id_ = from.name_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      group_id_ = from.group_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto_FieldTrial::CopyFrom(const SystemProfileProto_FieldTrial& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto.FieldTrial)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto_FieldTrial::IsInitialized() const {
  return true;
}

void SystemProfileProto_FieldTrial::InternalSwap(SystemProfileProto_FieldTrial* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemProfileProto_FieldTrial, group_id_)
      + sizeof(SystemProfileProto_FieldTrial::group_id_)
      - PROTOBUF_FIELD_OFFSET(SystemProfileProto_FieldTrial, name_id_)>(
          reinterpret_cast<char*>(&name_id_),
          reinterpret_cast<char*>(&other->name_id_));
}

std::string SystemProfileProto_FieldTrial::GetTypeName() const {
  return "metrics.SystemProfileProto.FieldTrial";
}


// ===================================================================

class SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto_ExternalAudioVideoDevice_AudioDescription>()._has_bits_);
  static void set_has_audio_format(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_bit_rate_per_second(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bit_depth(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_output_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::SystemProfileProto_ExternalAudioVideoDevice_AudioDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  sample_frequency_hz_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto.ExternalAudioVideoDevice.AudioDescription)
}
SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::SystemProfileProto_ExternalAudioVideoDevice_AudioDescription(const SystemProfileProto_ExternalAudioVideoDevice_AudioDescription& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      sample_frequency_hz_(from.sample_frequency_hz_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&audio_format_, &from.audio_format_,
    static_cast<size_t>(reinterpret_cast<char*>(&output_mode_) -
    reinterpret_cast<char*>(&audio_format_)) + sizeof(output_mode_));
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto.ExternalAudioVideoDevice.AudioDescription)
}

inline void SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&audio_format_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&output_mode_) -
    reinterpret_cast<char*>(&audio_format_)) + sizeof(output_mode_));
}

SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::~SystemProfileProto_ExternalAudioVideoDevice_AudioDescription() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto.ExternalAudioVideoDevice.AudioDescription)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto.ExternalAudioVideoDevice.AudioDescription)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sample_frequency_hz_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&audio_format_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&output_mode_) -
        reinterpret_cast<char*>(&audio_format_)) + sizeof(output_mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .metrics.SystemProfileProto.ExternalAudioVideoDevice.AudioDescription.AudioFormat audio_format = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat_IsValid(val))) {
            _internal_set_audio_format(static_cast<::metrics::SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_AudioFormat>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_channels = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_num_channels(&has_bits);
          num_channels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 sample_frequency_hz = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_sample_frequency_hz(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_sample_frequency_hz(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 max_bit_rate_per_second = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_max_bit_rate_per_second(&has_bits);
          max_bit_rate_per_second_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 bit_depth = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_bit_depth(&has_bits);
          bit_depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.ExternalAudioVideoDevice.AudioDescription.OutputMode output_mode = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode_IsValid(val))) {
            _internal_set_output_mode(static_cast<::metrics::SystemProfileProto_ExternalAudioVideoDevice_AudioDescription_OutputMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto.ExternalAudioVideoDevice.AudioDescription)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .metrics.SystemProfileProto.ExternalAudioVideoDevice.AudioDescription.AudioFormat audio_format = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_audio_format(), target);
  }

  // optional int32 num_channels = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_num_channels(), target);
  }

  // repeated int32 sample_frequency_hz = 3;
  for (int i = 0, n = this->_internal_sample_frequency_hz_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_sample_frequency_hz(i), target);
  }

  // optional int32 max_bit_rate_per_second = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_max_bit_rate_per_second(), target);
  }

  // optional int32 bit_depth = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_bit_depth(), target);
  }

  // optional .metrics.SystemProfileProto.ExternalAudioVideoDevice.AudioDescription.OutputMode output_mode = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_output_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto.ExternalAudioVideoDevice.AudioDescription)
  return target;
}

size_t SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto.ExternalAudioVideoDevice.AudioDescription)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 sample_frequency_hz = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->sample_frequency_hz_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_sample_frequency_hz_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .metrics.SystemProfileProto.ExternalAudioVideoDevice.AudioDescription.AudioFormat audio_format = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_audio_format());
    }

    // optional int32 num_channels = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_channels());
    }

    // optional int32 max_bit_rate_per_second = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_bit_rate_per_second());
    }

    // optional int32 bit_depth = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_bit_depth());
    }

    // optional .metrics.SystemProfileProto.ExternalAudioVideoDevice.AudioDescription.OutputMode output_mode = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_output_mode());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto_ExternalAudioVideoDevice_AudioDescription*>(
      &from));
}

void SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::MergeFrom(const SystemProfileProto_ExternalAudioVideoDevice_AudioDescription& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto.ExternalAudioVideoDevice.AudioDescription)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  sample_frequency_hz_.MergeFrom(from.sample_frequency_hz_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      audio_format_ = from.audio_format_;
    }
    if (cached_has_bits & 0x00000002u) {
      num_channels_ = from.num_channels_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_bit_rate_per_second_ = from.max_bit_rate_per_second_;
    }
    if (cached_has_bits & 0x00000008u) {
      bit_depth_ = from.bit_depth_;
    }
    if (cached_has_bits & 0x00000010u) {
      output_mode_ = from.output_mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::CopyFrom(const SystemProfileProto_ExternalAudioVideoDevice_AudioDescription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto.ExternalAudioVideoDevice.AudioDescription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::IsInitialized() const {
  return true;
}

void SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::InternalSwap(SystemProfileProto_ExternalAudioVideoDevice_AudioDescription* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  sample_frequency_hz_.InternalSwap(&other->sample_frequency_hz_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemProfileProto_ExternalAudioVideoDevice_AudioDescription, output_mode_)
      + sizeof(SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::output_mode_)
      - PROTOBUF_FIELD_OFFSET(SystemProfileProto_ExternalAudioVideoDevice_AudioDescription, audio_format_)>(
          reinterpret_cast<char*>(&audio_format_),
          reinterpret_cast<char*>(&other->audio_format_));
}

std::string SystemProfileProto_ExternalAudioVideoDevice_AudioDescription::GetTypeName() const {
  return "metrics.SystemProfileProto.ExternalAudioVideoDevice.AudioDescription";
}


// ===================================================================

class SystemProfileProto_ExternalAudioVideoDevice_CECCommand::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto_ExternalAudioVideoDevice_CECCommand>()._has_bits_);
  static void set_has_opcode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_received_direct(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_received_broadcast(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_num_sent_direct(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_num_sent_broadcast(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_num_aborted_unknown_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_num_aborted_unrecognized(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

SystemProfileProto_ExternalAudioVideoDevice_CECCommand::SystemProfileProto_ExternalAudioVideoDevice_CECCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto.ExternalAudioVideoDevice.CECCommand)
}
SystemProfileProto_ExternalAudioVideoDevice_CECCommand::SystemProfileProto_ExternalAudioVideoDevice_CECCommand(const SystemProfileProto_ExternalAudioVideoDevice_CECCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&opcode_, &from.opcode_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_aborted_unrecognized_) -
    reinterpret_cast<char*>(&opcode_)) + sizeof(num_aborted_unrecognized_));
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto.ExternalAudioVideoDevice.CECCommand)
}

inline void SystemProfileProto_ExternalAudioVideoDevice_CECCommand::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&opcode_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&num_aborted_unrecognized_) -
    reinterpret_cast<char*>(&opcode_)) + sizeof(num_aborted_unrecognized_));
}

SystemProfileProto_ExternalAudioVideoDevice_CECCommand::~SystemProfileProto_ExternalAudioVideoDevice_CECCommand() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto.ExternalAudioVideoDevice.CECCommand)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto_ExternalAudioVideoDevice_CECCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SystemProfileProto_ExternalAudioVideoDevice_CECCommand::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto_ExternalAudioVideoDevice_CECCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto.ExternalAudioVideoDevice.CECCommand)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&opcode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&num_aborted_unrecognized_) -
        reinterpret_cast<char*>(&opcode_)) + sizeof(num_aborted_unrecognized_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto_ExternalAudioVideoDevice_CECCommand::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 opcode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_opcode(&has_bits);
          opcode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_received_direct = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_num_received_direct(&has_bits);
          num_received_direct_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_received_broadcast = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_num_received_broadcast(&has_bits);
          num_received_broadcast_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_sent_direct = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_num_sent_direct(&has_bits);
          num_sent_direct_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_sent_broadcast = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_num_sent_broadcast(&has_bits);
          num_sent_broadcast_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_aborted_unknown_reason = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_num_aborted_unknown_reason(&has_bits);
          num_aborted_unknown_reason_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_aborted_unrecognized = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_num_aborted_unrecognized(&has_bits);
          num_aborted_unrecognized_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto_ExternalAudioVideoDevice_CECCommand::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto.ExternalAudioVideoDevice.CECCommand)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 opcode = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_opcode(), target);
  }

  // optional int32 num_received_direct = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_num_received_direct(), target);
  }

  // optional int32 num_received_broadcast = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_num_received_broadcast(), target);
  }

  // optional int32 num_sent_direct = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_num_sent_direct(), target);
  }

  // optional int32 num_sent_broadcast = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_num_sent_broadcast(), target);
  }

  // optional int32 num_aborted_unknown_reason = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_num_aborted_unknown_reason(), target);
  }

  // optional int32 num_aborted_unrecognized = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_num_aborted_unrecognized(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto.ExternalAudioVideoDevice.CECCommand)
  return target;
}

size_t SystemProfileProto_ExternalAudioVideoDevice_CECCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto.ExternalAudioVideoDevice.CECCommand)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional int32 opcode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_opcode());
    }

    // optional int32 num_received_direct = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_received_direct());
    }

    // optional int32 num_received_broadcast = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_received_broadcast());
    }

    // optional int32 num_sent_direct = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_sent_direct());
    }

    // optional int32 num_sent_broadcast = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_sent_broadcast());
    }

    // optional int32 num_aborted_unknown_reason = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_aborted_unknown_reason());
    }

    // optional int32 num_aborted_unrecognized = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_aborted_unrecognized());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto_ExternalAudioVideoDevice_CECCommand::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto_ExternalAudioVideoDevice_CECCommand*>(
      &from));
}

void SystemProfileProto_ExternalAudioVideoDevice_CECCommand::MergeFrom(const SystemProfileProto_ExternalAudioVideoDevice_CECCommand& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto.ExternalAudioVideoDevice.CECCommand)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      opcode_ = from.opcode_;
    }
    if (cached_has_bits & 0x00000002u) {
      num_received_direct_ = from.num_received_direct_;
    }
    if (cached_has_bits & 0x00000004u) {
      num_received_broadcast_ = from.num_received_broadcast_;
    }
    if (cached_has_bits & 0x00000008u) {
      num_sent_direct_ = from.num_sent_direct_;
    }
    if (cached_has_bits & 0x00000010u) {
      num_sent_broadcast_ = from.num_sent_broadcast_;
    }
    if (cached_has_bits & 0x00000020u) {
      num_aborted_unknown_reason_ = from.num_aborted_unknown_reason_;
    }
    if (cached_has_bits & 0x00000040u) {
      num_aborted_unrecognized_ = from.num_aborted_unrecognized_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto_ExternalAudioVideoDevice_CECCommand::CopyFrom(const SystemProfileProto_ExternalAudioVideoDevice_CECCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto.ExternalAudioVideoDevice.CECCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto_ExternalAudioVideoDevice_CECCommand::IsInitialized() const {
  return true;
}

void SystemProfileProto_ExternalAudioVideoDevice_CECCommand::InternalSwap(SystemProfileProto_ExternalAudioVideoDevice_CECCommand* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemProfileProto_ExternalAudioVideoDevice_CECCommand, num_aborted_unrecognized_)
      + sizeof(SystemProfileProto_ExternalAudioVideoDevice_CECCommand::num_aborted_unrecognized_)
      - PROTOBUF_FIELD_OFFSET(SystemProfileProto_ExternalAudioVideoDevice_CECCommand, opcode_)>(
          reinterpret_cast<char*>(&opcode_),
          reinterpret_cast<char*>(&other->opcode_));
}

std::string SystemProfileProto_ExternalAudioVideoDevice_CECCommand::GetTypeName() const {
  return "metrics.SystemProfileProto.ExternalAudioVideoDevice.CECCommand";
}


// ===================================================================

class SystemProfileProto_ExternalAudioVideoDevice::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto_ExternalAudioVideoDevice>()._has_bits_);
  static void set_has_manufacturer_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_model_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_product_code(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_manufacture_year(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_manufacture_week(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_horizontal_resolution(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_vertical_resolution(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_position_in_setup(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_is_in_path_to_tv(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_cec_version(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_frame_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_color_encoding(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_bit_depth(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_tmds(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_hdr10_support(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_dolby_vision_support(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_eotf_support(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_yuv_support(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_yuv_420_support(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_maximum_supported_hdcp_version(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_current_hdcp_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
};

SystemProfileProto_ExternalAudioVideoDevice::SystemProfileProto_ExternalAudioVideoDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  av_device_type_(arena),
  audio_description_(arena),
  cec_command_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto.ExternalAudioVideoDevice)
}
SystemProfileProto_ExternalAudioVideoDevice::SystemProfileProto_ExternalAudioVideoDevice(const SystemProfileProto_ExternalAudioVideoDevice& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      av_device_type_(from.av_device_type_),
      audio_description_(from.audio_description_),
      cec_command_(from.cec_command_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  manufacturer_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    manufacturer_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_manufacturer_name()) {
    manufacturer_name_.Set(from._internal_manufacturer_name(), 
      GetArenaForAllocation());
  }
  model_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model_name()) {
    model_name_.Set(from._internal_model_name(), 
      GetArenaForAllocation());
  }
  product_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    product_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_product_code()) {
    product_code_.Set(from._internal_product_code(), 
      GetArenaForAllocation());
  }
  ::memcpy(&manufacture_year_, &from.manufacture_year_,
    static_cast<size_t>(reinterpret_cast<char*>(&current_hdcp_version_) -
    reinterpret_cast<char*>(&manufacture_year_)) + sizeof(current_hdcp_version_));
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto.ExternalAudioVideoDevice)
}

inline void SystemProfileProto_ExternalAudioVideoDevice::SharedCtor() {
manufacturer_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  manufacturer_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
model_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
product_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  product_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&manufacture_year_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&current_hdcp_version_) -
    reinterpret_cast<char*>(&manufacture_year_)) + sizeof(current_hdcp_version_));
}

SystemProfileProto_ExternalAudioVideoDevice::~SystemProfileProto_ExternalAudioVideoDevice() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto.ExternalAudioVideoDevice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto_ExternalAudioVideoDevice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  manufacturer_name_.Destroy();
  model_name_.Destroy();
  product_code_.Destroy();
}

void SystemProfileProto_ExternalAudioVideoDevice::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto_ExternalAudioVideoDevice::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto.ExternalAudioVideoDevice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  av_device_type_.Clear();
  audio_description_.Clear();
  cec_command_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      manufacturer_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      model_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      product_code_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&manufacture_year_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&position_in_setup_) -
        reinterpret_cast<char*>(&manufacture_year_)) + sizeof(position_in_setup_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&cec_version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&dolby_vision_support_) -
        reinterpret_cast<char*>(&cec_version_)) + sizeof(dolby_vision_support_));
  }
  if (cached_has_bits & 0x001f0000u) {
    ::memset(&yuv_support_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&current_hdcp_version_) -
        reinterpret_cast<char*>(&yuv_support_)) + sizeof(current_hdcp_version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto_ExternalAudioVideoDevice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string manufacturer_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_manufacturer_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string model_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_model_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string product_code = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_product_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .metrics.SystemProfileProto.ExternalAudioVideoDevice.AVDeviceType av_device_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType_IsValid(val))) {
              _internal_add_av_device_type(static_cast<::metrics::SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_av_device_type(), ptr, ctx, ::metrics::SystemProfileProto_ExternalAudioVideoDevice_AVDeviceType_IsValid, &_internal_metadata_, 4);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 manufacture_year = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_manufacture_year(&has_bits);
          manufacture_year_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 manufacture_week = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_manufacture_week(&has_bits);
          manufacture_week_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 horizontal_resolution = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_horizontal_resolution(&has_bits);
          horizontal_resolution_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 vertical_resolution = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_vertical_resolution(&has_bits);
          vertical_resolution_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .metrics.SystemProfileProto.ExternalAudioVideoDevice.AudioDescription audio_description = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_audio_description(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 position_in_setup = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_position_in_setup(&has_bits);
          position_in_setup_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_in_path_to_tv = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_is_in_path_to_tv(&has_bits);
          is_in_path_to_tv_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 cec_version = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_cec_version(&has_bits);
          cec_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .metrics.SystemProfileProto.ExternalAudioVideoDevice.CECCommand cec_command = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cec_command(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 frame_rate = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_frame_rate(&has_bits);
          frame_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.ExternalAudioVideoDevice.ColorEncoding color_encoding = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding_IsValid(val))) {
            _internal_set_color_encoding(static_cast<::metrics::SystemProfileProto_ExternalAudioVideoDevice_ColorEncoding>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(15, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 bit_depth = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_bit_depth(&has_bits);
          bit_depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 tmds = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_tmds(&has_bits);
          tmds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool hdr10_support = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_hdr10_support(&has_bits);
          hdr10_support_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool dolby_vision_support = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_dolby_vision_support(&has_bits);
          dolby_vision_support_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 eotf_support = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_eotf_support(&has_bits);
          eotf_support_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool yuv_support = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_yuv_support(&has_bits);
          yuv_support_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool yuv_420_support = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_yuv_420_support(&has_bits);
          yuv_420_support_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 maximum_supported_hdcp_version = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_maximum_supported_hdcp_version(&has_bits);
          maximum_supported_hdcp_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 current_hdcp_version = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_current_hdcp_version(&has_bits);
          current_hdcp_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto_ExternalAudioVideoDevice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto.ExternalAudioVideoDevice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string manufacturer_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_manufacturer_name(), target);
  }

  // optional string model_name = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_model_name(), target);
  }

  // optional string product_code = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_product_code(), target);
  }

  // repeated .metrics.SystemProfileProto.ExternalAudioVideoDevice.AVDeviceType av_device_type = 4;
  for (int i = 0, n = this->_internal_av_device_type_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_av_device_type(i), target);
  }

  // optional int32 manufacture_year = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_manufacture_year(), target);
  }

  // optional int32 manufacture_week = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_manufacture_week(), target);
  }

  // optional int32 horizontal_resolution = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_horizontal_resolution(), target);
  }

  // optional int32 vertical_resolution = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_vertical_resolution(), target);
  }

  // repeated .metrics.SystemProfileProto.ExternalAudioVideoDevice.AudioDescription audio_description = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_audio_description_size()); i < n; i++) {
    const auto& repfield = this->_internal_audio_description(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int32 position_in_setup = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_position_in_setup(), target);
  }

  // optional bool is_in_path_to_tv = 11;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_is_in_path_to_tv(), target);
  }

  // optional int32 cec_version = 12;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_cec_version(), target);
  }

  // repeated .metrics.SystemProfileProto.ExternalAudioVideoDevice.CECCommand cec_command = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_cec_command_size()); i < n; i++) {
    const auto& repfield = this->_internal_cec_command(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int32 frame_rate = 14;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(14, this->_internal_frame_rate(), target);
  }

  // optional .metrics.SystemProfileProto.ExternalAudioVideoDevice.ColorEncoding color_encoding = 15;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      15, this->_internal_color_encoding(), target);
  }

  // optional int32 bit_depth = 16;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(16, this->_internal_bit_depth(), target);
  }

  // optional int32 tmds = 17;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(17, this->_internal_tmds(), target);
  }

  // optional bool hdr10_support = 18;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_hdr10_support(), target);
  }

  // optional bool dolby_vision_support = 19;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(19, this->_internal_dolby_vision_support(), target);
  }

  // optional int32 eotf_support = 20;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(20, this->_internal_eotf_support(), target);
  }

  // optional bool yuv_support = 21;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(21, this->_internal_yuv_support(), target);
  }

  // optional bool yuv_420_support = 22;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_yuv_420_support(), target);
  }

  // optional int32 maximum_supported_hdcp_version = 23;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(23, this->_internal_maximum_supported_hdcp_version(), target);
  }

  // optional int32 current_hdcp_version = 24;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(24, this->_internal_current_hdcp_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto.ExternalAudioVideoDevice)
  return target;
}

size_t SystemProfileProto_ExternalAudioVideoDevice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto.ExternalAudioVideoDevice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .metrics.SystemProfileProto.ExternalAudioVideoDevice.AVDeviceType av_device_type = 4;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_av_device_type_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_av_device_type(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .metrics.SystemProfileProto.ExternalAudioVideoDevice.AudioDescription audio_description = 9;
  total_size += 1UL * this->_internal_audio_description_size();
  for (const auto& msg : this->audio_description_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .metrics.SystemProfileProto.ExternalAudioVideoDevice.CECCommand cec_command = 13;
  total_size += 1UL * this->_internal_cec_command_size();
  for (const auto& msg : this->cec_command_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string manufacturer_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_manufacturer_name());
    }

    // optional string model_name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model_name());
    }

    // optional string product_code = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_product_code());
    }

    // optional int32 manufacture_year = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_manufacture_year());
    }

    // optional int32 manufacture_week = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_manufacture_week());
    }

    // optional int32 horizontal_resolution = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_horizontal_resolution());
    }

    // optional int32 vertical_resolution = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_vertical_resolution());
    }

    // optional int32 position_in_setup = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_position_in_setup());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional int32 cec_version = 12;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cec_version());
    }

    // optional int32 frame_rate = 14;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_frame_rate());
    }

    // optional .metrics.SystemProfileProto.ExternalAudioVideoDevice.ColorEncoding color_encoding = 15;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_color_encoding());
    }

    // optional int32 bit_depth = 16;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_bit_depth());
    }

    // optional int32 tmds = 17;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_tmds());
    }

    // optional bool is_in_path_to_tv = 11;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool hdr10_support = 18;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional bool dolby_vision_support = 19;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x001f0000u) {
    // optional bool yuv_support = 21;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional int32 eotf_support = 20;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_eotf_support());
    }

    // optional bool yuv_420_support = 22;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 1;
    }

    // optional int32 maximum_supported_hdcp_version = 23;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_maximum_supported_hdcp_version());
    }

    // optional int32 current_hdcp_version = 24;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_current_hdcp_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto_ExternalAudioVideoDevice::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto_ExternalAudioVideoDevice*>(
      &from));
}

void SystemProfileProto_ExternalAudioVideoDevice::MergeFrom(const SystemProfileProto_ExternalAudioVideoDevice& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto.ExternalAudioVideoDevice)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  av_device_type_.MergeFrom(from.av_device_type_);
  audio_description_.MergeFrom(from.audio_description_);
  cec_command_.MergeFrom(from.cec_command_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_manufacturer_name(from._internal_manufacturer_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_model_name(from._internal_model_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_product_code(from._internal_product_code());
    }
    if (cached_has_bits & 0x00000008u) {
      manufacture_year_ = from.manufacture_year_;
    }
    if (cached_has_bits & 0x00000010u) {
      manufacture_week_ = from.manufacture_week_;
    }
    if (cached_has_bits & 0x00000020u) {
      horizontal_resolution_ = from.horizontal_resolution_;
    }
    if (cached_has_bits & 0x00000040u) {
      vertical_resolution_ = from.vertical_resolution_;
    }
    if (cached_has_bits & 0x00000080u) {
      position_in_setup_ = from.position_in_setup_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      cec_version_ = from.cec_version_;
    }
    if (cached_has_bits & 0x00000200u) {
      frame_rate_ = from.frame_rate_;
    }
    if (cached_has_bits & 0x00000400u) {
      color_encoding_ = from.color_encoding_;
    }
    if (cached_has_bits & 0x00000800u) {
      bit_depth_ = from.bit_depth_;
    }
    if (cached_has_bits & 0x00001000u) {
      tmds_ = from.tmds_;
    }
    if (cached_has_bits & 0x00002000u) {
      is_in_path_to_tv_ = from.is_in_path_to_tv_;
    }
    if (cached_has_bits & 0x00004000u) {
      hdr10_support_ = from.hdr10_support_;
    }
    if (cached_has_bits & 0x00008000u) {
      dolby_vision_support_ = from.dolby_vision_support_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x001f0000u) {
    if (cached_has_bits & 0x00010000u) {
      yuv_support_ = from.yuv_support_;
    }
    if (cached_has_bits & 0x00020000u) {
      eotf_support_ = from.eotf_support_;
    }
    if (cached_has_bits & 0x00040000u) {
      yuv_420_support_ = from.yuv_420_support_;
    }
    if (cached_has_bits & 0x00080000u) {
      maximum_supported_hdcp_version_ = from.maximum_supported_hdcp_version_;
    }
    if (cached_has_bits & 0x00100000u) {
      current_hdcp_version_ = from.current_hdcp_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto_ExternalAudioVideoDevice::CopyFrom(const SystemProfileProto_ExternalAudioVideoDevice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto.ExternalAudioVideoDevice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto_ExternalAudioVideoDevice::IsInitialized() const {
  return true;
}

void SystemProfileProto_ExternalAudioVideoDevice::InternalSwap(SystemProfileProto_ExternalAudioVideoDevice* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  av_device_type_.InternalSwap(&other->av_device_type_);
  audio_description_.InternalSwap(&other->audio_description_);
  cec_command_.InternalSwap(&other->cec_command_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &manufacturer_name_, lhs_arena,
      &other->manufacturer_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &model_name_, lhs_arena,
      &other->model_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &product_code_, lhs_arena,
      &other->product_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemProfileProto_ExternalAudioVideoDevice, current_hdcp_version_)
      + sizeof(SystemProfileProto_ExternalAudioVideoDevice::current_hdcp_version_)
      - PROTOBUF_FIELD_OFFSET(SystemProfileProto_ExternalAudioVideoDevice, manufacture_year_)>(
          reinterpret_cast<char*>(&manufacture_year_),
          reinterpret_cast<char*>(&other->manufacture_year_));
}

std::string SystemProfileProto_ExternalAudioVideoDevice::GetTypeName() const {
  return "metrics.SystemProfileProto.ExternalAudioVideoDevice";
}


// ===================================================================

class SystemProfileProto_ExternalAccessPoint::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto_ExternalAccessPoint>()._has_bits_);
  static void set_has_manufacturer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_model_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_model_number(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_device_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SystemProfileProto_ExternalAccessPoint::SystemProfileProto_ExternalAccessPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto.ExternalAccessPoint)
}
SystemProfileProto_ExternalAccessPoint::SystemProfileProto_ExternalAccessPoint(const SystemProfileProto_ExternalAccessPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  manufacturer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    manufacturer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_manufacturer()) {
    manufacturer_.Set(from._internal_manufacturer(), 
      GetArenaForAllocation());
  }
  model_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model_name()) {
    model_name_.Set(from._internal_model_name(), 
      GetArenaForAllocation());
  }
  model_number_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_number_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model_number()) {
    model_number_.Set(from._internal_model_number(), 
      GetArenaForAllocation());
  }
  device_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_name()) {
    device_name_.Set(from._internal_device_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto.ExternalAccessPoint)
}

inline void SystemProfileProto_ExternalAccessPoint::SharedCtor() {
manufacturer_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  manufacturer_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
model_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
model_number_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_number_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
device_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SystemProfileProto_ExternalAccessPoint::~SystemProfileProto_ExternalAccessPoint() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto.ExternalAccessPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto_ExternalAccessPoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  manufacturer_.Destroy();
  model_name_.Destroy();
  model_number_.Destroy();
  device_name_.Destroy();
}

void SystemProfileProto_ExternalAccessPoint::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto_ExternalAccessPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto.ExternalAccessPoint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      manufacturer_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      model_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      model_number_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      device_name_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto_ExternalAccessPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string manufacturer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_manufacturer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string model_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_model_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string model_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_model_number();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string device_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_device_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto_ExternalAccessPoint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto.ExternalAccessPoint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string manufacturer = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_manufacturer(), target);
  }

  // optional string model_name = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_model_name(), target);
  }

  // optional string model_number = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_model_number(), target);
  }

  // optional string device_name = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_device_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto.ExternalAccessPoint)
  return target;
}

size_t SystemProfileProto_ExternalAccessPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto.ExternalAccessPoint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string manufacturer = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_manufacturer());
    }

    // optional string model_name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model_name());
    }

    // optional string model_number = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model_number());
    }

    // optional string device_name = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_name());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto_ExternalAccessPoint::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto_ExternalAccessPoint*>(
      &from));
}

void SystemProfileProto_ExternalAccessPoint::MergeFrom(const SystemProfileProto_ExternalAccessPoint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto.ExternalAccessPoint)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_manufacturer(from._internal_manufacturer());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_model_name(from._internal_model_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_model_number(from._internal_model_number());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_device_name(from._internal_device_name());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto_ExternalAccessPoint::CopyFrom(const SystemProfileProto_ExternalAccessPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto.ExternalAccessPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto_ExternalAccessPoint::IsInitialized() const {
  return true;
}

void SystemProfileProto_ExternalAccessPoint::InternalSwap(SystemProfileProto_ExternalAccessPoint* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &manufacturer_, lhs_arena,
      &other->manufacturer_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &model_name_, lhs_arena,
      &other->model_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &model_number_, lhs_arena,
      &other->model_number_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &device_name_, lhs_arena,
      &other->device_name_, rhs_arena
  );
}

std::string SystemProfileProto_ExternalAccessPoint::GetTypeName() const {
  return "metrics.SystemProfileProto.ExternalAccessPoint";
}


// ===================================================================

class SystemProfileProto_AntiVirusProduct::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto_AntiVirusProduct>()._has_bits_);
  static void set_has_product_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_product_name_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_product_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_product_version_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_product_state(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

SystemProfileProto_AntiVirusProduct::SystemProfileProto_AntiVirusProduct(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto.AntiVirusProduct)
}
SystemProfileProto_AntiVirusProduct::SystemProfileProto_AntiVirusProduct(const SystemProfileProto_AntiVirusProduct& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  product_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    product_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_product_name()) {
    product_name_.Set(from._internal_product_name(), 
      GetArenaForAllocation());
  }
  product_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    product_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_product_version()) {
    product_version_.Set(from._internal_product_version(), 
      GetArenaForAllocation());
  }
  ::memcpy(&product_name_hash_, &from.product_name_hash_,
    static_cast<size_t>(reinterpret_cast<char*>(&product_state_) -
    reinterpret_cast<char*>(&product_name_hash_)) + sizeof(product_state_));
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto.AntiVirusProduct)
}

inline void SystemProfileProto_AntiVirusProduct::SharedCtor() {
product_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  product_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
product_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  product_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&product_name_hash_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&product_state_) -
    reinterpret_cast<char*>(&product_name_hash_)) + sizeof(product_state_));
}

SystemProfileProto_AntiVirusProduct::~SystemProfileProto_AntiVirusProduct() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto.AntiVirusProduct)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto_AntiVirusProduct::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  product_name_.Destroy();
  product_version_.Destroy();
}

void SystemProfileProto_AntiVirusProduct::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto_AntiVirusProduct::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto.AntiVirusProduct)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      product_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      product_version_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&product_name_hash_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&product_state_) -
        reinterpret_cast<char*>(&product_name_hash_)) + sizeof(product_state_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto_AntiVirusProduct::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string product_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_product_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 product_name_hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_product_name_hash(&has_bits);
          product_name_hash_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional string product_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_product_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 product_version_hash = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_product_version_hash(&has_bits);
          product_version_hash_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.AntiVirusState product_state = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_AntiVirusState_IsValid(val))) {
            _internal_set_product_state(static_cast<::metrics::SystemProfileProto_AntiVirusState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto_AntiVirusProduct::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto.AntiVirusProduct)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string product_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_product_name(), target);
  }

  // optional fixed32 product_name_hash = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_product_name_hash(), target);
  }

  // optional string product_version = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_product_version(), target);
  }

  // optional fixed32 product_version_hash = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(4, this->_internal_product_version_hash(), target);
  }

  // optional .metrics.SystemProfileProto.AntiVirusState product_state = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_product_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto.AntiVirusProduct)
  return target;
}

size_t SystemProfileProto_AntiVirusProduct::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto.AntiVirusProduct)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string product_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_product_name());
    }

    // optional string product_version = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_product_version());
    }

    // optional fixed32 product_name_hash = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional fixed32 product_version_hash = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional .metrics.SystemProfileProto.AntiVirusState product_state = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_product_state());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto_AntiVirusProduct::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto_AntiVirusProduct*>(
      &from));
}

void SystemProfileProto_AntiVirusProduct::MergeFrom(const SystemProfileProto_AntiVirusProduct& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto.AntiVirusProduct)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_product_name(from._internal_product_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_product_version(from._internal_product_version());
    }
    if (cached_has_bits & 0x00000004u) {
      product_name_hash_ = from.product_name_hash_;
    }
    if (cached_has_bits & 0x00000008u) {
      product_version_hash_ = from.product_version_hash_;
    }
    if (cached_has_bits & 0x00000010u) {
      product_state_ = from.product_state_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto_AntiVirusProduct::CopyFrom(const SystemProfileProto_AntiVirusProduct& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto.AntiVirusProduct)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto_AntiVirusProduct::IsInitialized() const {
  return true;
}

void SystemProfileProto_AntiVirusProduct::InternalSwap(SystemProfileProto_AntiVirusProduct* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &product_name_, lhs_arena,
      &other->product_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &product_version_, lhs_arena,
      &other->product_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemProfileProto_AntiVirusProduct, product_state_)
      + sizeof(SystemProfileProto_AntiVirusProduct::product_state_)
      - PROTOBUF_FIELD_OFFSET(SystemProfileProto_AntiVirusProduct, product_name_hash_)>(
          reinterpret_cast<char*>(&product_name_hash_),
          reinterpret_cast<char*>(&other->product_name_hash_));
}

std::string SystemProfileProto_AntiVirusProduct::GetTypeName() const {
  return "metrics.SystemProfileProto.AntiVirusProduct";
}


// ===================================================================

class SystemProfileProto_ChromeComponent::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto_ChromeComponent>()._has_bits_);
  static void set_has_component_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_omaha_fingerprint(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cohort_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SystemProfileProto_ChromeComponent::SystemProfileProto_ChromeComponent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto.ChromeComponent)
}
SystemProfileProto_ChromeComponent::SystemProfileProto_ChromeComponent(const SystemProfileProto_ChromeComponent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version()) {
    version_.Set(from._internal_version(), 
      GetArenaForAllocation());
  }
  ::memcpy(&omaha_fingerprint_, &from.omaha_fingerprint_,
    static_cast<size_t>(reinterpret_cast<char*>(&component_id_) -
    reinterpret_cast<char*>(&omaha_fingerprint_)) + sizeof(component_id_));
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto.ChromeComponent)
}

inline void SystemProfileProto_ChromeComponent::SharedCtor() {
version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&omaha_fingerprint_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&cohort_hash_) -
    reinterpret_cast<char*>(&omaha_fingerprint_)) + sizeof(cohort_hash_));
component_id_ = 1;
}

SystemProfileProto_ChromeComponent::~SystemProfileProto_ChromeComponent() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto.ChromeComponent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto_ChromeComponent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  version_.Destroy();
}

void SystemProfileProto_ChromeComponent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto_ChromeComponent::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto.ChromeComponent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    version_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&omaha_fingerprint_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cohort_hash_) -
        reinterpret_cast<char*>(&omaha_fingerprint_)) + sizeof(cohort_hash_));
    component_id_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto_ChromeComponent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .metrics.SystemProfileProto.ComponentId component_id = 1 [default = UNKNOWN];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_ComponentId_IsValid(val))) {
            _internal_set_component_id(static_cast<::metrics::SystemProfileProto_ComponentId>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 omaha_fingerprint = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_omaha_fingerprint(&has_bits);
          omaha_fingerprint_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 cohort_hash = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_cohort_hash(&has_bits);
          cohort_hash_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto_ChromeComponent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto.ChromeComponent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .metrics.SystemProfileProto.ComponentId component_id = 1 [default = UNKNOWN];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_component_id(), target);
  }

  // optional string version = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_version(), target);
  }

  // optional fixed32 omaha_fingerprint = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(3, this->_internal_omaha_fingerprint(), target);
  }

  // optional fixed32 cohort_hash = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(4, this->_internal_cohort_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto.ChromeComponent)
  return target;
}

size_t SystemProfileProto_ChromeComponent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto.ChromeComponent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string version = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version());
    }

    // optional fixed32 omaha_fingerprint = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional fixed32 cohort_hash = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional .metrics.SystemProfileProto.ComponentId component_id = 1 [default = UNKNOWN];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_component_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto_ChromeComponent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto_ChromeComponent*>(
      &from));
}

void SystemProfileProto_ChromeComponent::MergeFrom(const SystemProfileProto_ChromeComponent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto.ChromeComponent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000002u) {
      omaha_fingerprint_ = from.omaha_fingerprint_;
    }
    if (cached_has_bits & 0x00000004u) {
      cohort_hash_ = from.cohort_hash_;
    }
    if (cached_has_bits & 0x00000008u) {
      component_id_ = from.component_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto_ChromeComponent::CopyFrom(const SystemProfileProto_ChromeComponent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto.ChromeComponent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto_ChromeComponent::IsInitialized() const {
  return true;
}

void SystemProfileProto_ChromeComponent::InternalSwap(SystemProfileProto_ChromeComponent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &version_, lhs_arena,
      &other->version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemProfileProto_ChromeComponent, cohort_hash_)
      + sizeof(SystemProfileProto_ChromeComponent::cohort_hash_)
      - PROTOBUF_FIELD_OFFSET(SystemProfileProto_ChromeComponent, omaha_fingerprint_)>(
          reinterpret_cast<char*>(&omaha_fingerprint_),
          reinterpret_cast<char*>(&other->omaha_fingerprint_));
  swap(component_id_, other->component_id_);
}

std::string SystemProfileProto_ChromeComponent::GetTypeName() const {
  return "metrics.SystemProfileProto.ChromeComponent";
}


// ===================================================================

class SystemProfileProto_LinkedAndroidPhoneData::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto_LinkedAndroidPhoneData>()._has_bits_);
  static void set_has_phone_model_name_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_smartlock_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_instant_tethering_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_messages_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SystemProfileProto_LinkedAndroidPhoneData::SystemProfileProto_LinkedAndroidPhoneData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto.LinkedAndroidPhoneData)
}
SystemProfileProto_LinkedAndroidPhoneData::SystemProfileProto_LinkedAndroidPhoneData(const SystemProfileProto_LinkedAndroidPhoneData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&phone_model_name_hash_, &from.phone_model_name_hash_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_messages_enabled_) -
    reinterpret_cast<char*>(&phone_model_name_hash_)) + sizeof(is_messages_enabled_));
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto.LinkedAndroidPhoneData)
}

inline void SystemProfileProto_LinkedAndroidPhoneData::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&phone_model_name_hash_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_messages_enabled_) -
    reinterpret_cast<char*>(&phone_model_name_hash_)) + sizeof(is_messages_enabled_));
}

SystemProfileProto_LinkedAndroidPhoneData::~SystemProfileProto_LinkedAndroidPhoneData() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto.LinkedAndroidPhoneData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto_LinkedAndroidPhoneData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SystemProfileProto_LinkedAndroidPhoneData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto_LinkedAndroidPhoneData::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto.LinkedAndroidPhoneData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&phone_model_name_hash_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_messages_enabled_) -
        reinterpret_cast<char*>(&phone_model_name_hash_)) + sizeof(is_messages_enabled_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto_LinkedAndroidPhoneData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 phone_model_name_hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_phone_model_name_hash(&has_bits);
          phone_model_name_hash_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_smartlock_enabled = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_smartlock_enabled(&has_bits);
          is_smartlock_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_instant_tethering_enabled = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_instant_tethering_enabled(&has_bits);
          is_instant_tethering_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_messages_enabled = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_messages_enabled(&has_bits);
          is_messages_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto_LinkedAndroidPhoneData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto.LinkedAndroidPhoneData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed32 phone_model_name_hash = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_phone_model_name_hash(), target);
  }

  // optional bool is_smartlock_enabled = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_smartlock_enabled(), target);
  }

  // optional bool is_instant_tethering_enabled = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_instant_tethering_enabled(), target);
  }

  // optional bool is_messages_enabled = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_messages_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto.LinkedAndroidPhoneData)
  return target;
}

size_t SystemProfileProto_LinkedAndroidPhoneData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto.LinkedAndroidPhoneData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional fixed32 phone_model_name_hash = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional bool is_smartlock_enabled = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool is_instant_tethering_enabled = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool is_messages_enabled = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto_LinkedAndroidPhoneData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto_LinkedAndroidPhoneData*>(
      &from));
}

void SystemProfileProto_LinkedAndroidPhoneData::MergeFrom(const SystemProfileProto_LinkedAndroidPhoneData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto.LinkedAndroidPhoneData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      phone_model_name_hash_ = from.phone_model_name_hash_;
    }
    if (cached_has_bits & 0x00000002u) {
      is_smartlock_enabled_ = from.is_smartlock_enabled_;
    }
    if (cached_has_bits & 0x00000004u) {
      is_instant_tethering_enabled_ = from.is_instant_tethering_enabled_;
    }
    if (cached_has_bits & 0x00000008u) {
      is_messages_enabled_ = from.is_messages_enabled_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto_LinkedAndroidPhoneData::CopyFrom(const SystemProfileProto_LinkedAndroidPhoneData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto.LinkedAndroidPhoneData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto_LinkedAndroidPhoneData::IsInitialized() const {
  return true;
}

void SystemProfileProto_LinkedAndroidPhoneData::InternalSwap(SystemProfileProto_LinkedAndroidPhoneData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemProfileProto_LinkedAndroidPhoneData, is_messages_enabled_)
      + sizeof(SystemProfileProto_LinkedAndroidPhoneData::is_messages_enabled_)
      - PROTOBUF_FIELD_OFFSET(SystemProfileProto_LinkedAndroidPhoneData, phone_model_name_hash_)>(
          reinterpret_cast<char*>(&phone_model_name_hash_),
          reinterpret_cast<char*>(&other->phone_model_name_hash_));
}

std::string SystemProfileProto_LinkedAndroidPhoneData::GetTypeName() const {
  return "metrics.SystemProfileProto.LinkedAndroidPhoneData";
}


// ===================================================================

class SystemProfileProto_DemoModeDimensions_Retailer::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto_DemoModeDimensions_Retailer>()._has_bits_);
  static void set_has_retailer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_store_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

SystemProfileProto_DemoModeDimensions_Retailer::SystemProfileProto_DemoModeDimensions_Retailer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto.DemoModeDimensions.Retailer)
}
SystemProfileProto_DemoModeDimensions_Retailer::SystemProfileProto_DemoModeDimensions_Retailer(const SystemProfileProto_DemoModeDimensions_Retailer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  retailer_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    retailer_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_retailer_id()) {
    retailer_id_.Set(from._internal_retailer_id(), 
      GetArenaForAllocation());
  }
  store_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    store_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_store_id()) {
    store_id_.Set(from._internal_store_id(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto.DemoModeDimensions.Retailer)
}

inline void SystemProfileProto_DemoModeDimensions_Retailer::SharedCtor() {
retailer_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  retailer_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
store_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  store_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SystemProfileProto_DemoModeDimensions_Retailer::~SystemProfileProto_DemoModeDimensions_Retailer() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto.DemoModeDimensions.Retailer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto_DemoModeDimensions_Retailer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  retailer_id_.Destroy();
  store_id_.Destroy();
}

void SystemProfileProto_DemoModeDimensions_Retailer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto_DemoModeDimensions_Retailer::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto.DemoModeDimensions.Retailer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      retailer_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      store_id_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto_DemoModeDimensions_Retailer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string retailer_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_retailer_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string store_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_store_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto_DemoModeDimensions_Retailer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto.DemoModeDimensions.Retailer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string retailer_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_retailer_id(), target);
  }

  // optional string store_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_store_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto.DemoModeDimensions.Retailer)
  return target;
}

size_t SystemProfileProto_DemoModeDimensions_Retailer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto.DemoModeDimensions.Retailer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string retailer_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_retailer_id());
    }

    // optional string store_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_store_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto_DemoModeDimensions_Retailer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto_DemoModeDimensions_Retailer*>(
      &from));
}

void SystemProfileProto_DemoModeDimensions_Retailer::MergeFrom(const SystemProfileProto_DemoModeDimensions_Retailer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto.DemoModeDimensions.Retailer)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_retailer_id(from._internal_retailer_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_store_id(from._internal_store_id());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto_DemoModeDimensions_Retailer::CopyFrom(const SystemProfileProto_DemoModeDimensions_Retailer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto.DemoModeDimensions.Retailer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto_DemoModeDimensions_Retailer::IsInitialized() const {
  return true;
}

void SystemProfileProto_DemoModeDimensions_Retailer::InternalSwap(SystemProfileProto_DemoModeDimensions_Retailer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &retailer_id_, lhs_arena,
      &other->retailer_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &store_id_, lhs_arena,
      &other->store_id_, rhs_arena
  );
}

std::string SystemProfileProto_DemoModeDimensions_Retailer::GetTypeName() const {
  return "metrics.SystemProfileProto.DemoModeDimensions.Retailer";
}


// ===================================================================

class SystemProfileProto_DemoModeDimensions::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto_DemoModeDimensions>()._has_bits_);
  static void set_has_country(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::metrics::SystemProfileProto_DemoModeDimensions_Retailer& retailer(const SystemProfileProto_DemoModeDimensions* msg);
  static void set_has_retailer(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::metrics::SystemProfileProto_DemoModeDimensions_Retailer&
SystemProfileProto_DemoModeDimensions::_Internal::retailer(const SystemProfileProto_DemoModeDimensions* msg) {
  return *msg->retailer_;
}
SystemProfileProto_DemoModeDimensions::SystemProfileProto_DemoModeDimensions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  customization_facet_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto.DemoModeDimensions)
}
SystemProfileProto_DemoModeDimensions::SystemProfileProto_DemoModeDimensions(const SystemProfileProto_DemoModeDimensions& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      customization_facet_(from.customization_facet_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  country_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    country_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_country()) {
    country_.Set(from._internal_country(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_retailer()) {
    retailer_ = new ::metrics::SystemProfileProto_DemoModeDimensions_Retailer(*from.retailer_);
  } else {
    retailer_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto.DemoModeDimensions)
}

inline void SystemProfileProto_DemoModeDimensions::SharedCtor() {
country_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  country_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
retailer_ = nullptr;
}

SystemProfileProto_DemoModeDimensions::~SystemProfileProto_DemoModeDimensions() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto.DemoModeDimensions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto_DemoModeDimensions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  country_.Destroy();
  if (this != internal_default_instance()) delete retailer_;
}

void SystemProfileProto_DemoModeDimensions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto_DemoModeDimensions::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto.DemoModeDimensions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  customization_facet_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      country_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(retailer_ != nullptr);
      retailer_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto_DemoModeDimensions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string country = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_country();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.DemoModeDimensions.Retailer retailer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_retailer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .metrics.SystemProfileProto.DemoModeDimensions.CustomizationFacet customization_facet = 3 [packed = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_customization_facet(), ptr, ctx, ::metrics::SystemProfileProto_DemoModeDimensions_CustomizationFacet_IsValid, &_internal_metadata_, 3);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_DemoModeDimensions_CustomizationFacet_IsValid(val))) {
            _internal_add_customization_facet(static_cast<::metrics::SystemProfileProto_DemoModeDimensions_CustomizationFacet>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto_DemoModeDimensions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto.DemoModeDimensions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string country = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_country(), target);
  }

  // optional .metrics.SystemProfileProto.DemoModeDimensions.Retailer retailer = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::retailer(this),
        _Internal::retailer(this).GetCachedSize(), target, stream);
  }

  // repeated .metrics.SystemProfileProto.DemoModeDimensions.CustomizationFacet customization_facet = 3 [packed = true];
  {
    int byte_size = _customization_facet_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          3, customization_facet_, byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto.DemoModeDimensions)
  return target;
}

size_t SystemProfileProto_DemoModeDimensions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto.DemoModeDimensions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .metrics.SystemProfileProto.DemoModeDimensions.CustomizationFacet customization_facet = 3 [packed = true];
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_customization_facet_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_customization_facet(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _customization_facet_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string country = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_country());
    }

    // optional .metrics.SystemProfileProto.DemoModeDimensions.Retailer retailer = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *retailer_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto_DemoModeDimensions::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto_DemoModeDimensions*>(
      &from));
}

void SystemProfileProto_DemoModeDimensions::MergeFrom(const SystemProfileProto_DemoModeDimensions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto.DemoModeDimensions)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  customization_facet_.MergeFrom(from.customization_facet_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_country(from._internal_country());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_retailer()->::metrics::SystemProfileProto_DemoModeDimensions_Retailer::MergeFrom(from._internal_retailer());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto_DemoModeDimensions::CopyFrom(const SystemProfileProto_DemoModeDimensions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto.DemoModeDimensions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto_DemoModeDimensions::IsInitialized() const {
  return true;
}

void SystemProfileProto_DemoModeDimensions::InternalSwap(SystemProfileProto_DemoModeDimensions* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  customization_facet_.InternalSwap(&other->customization_facet_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &country_, lhs_arena,
      &other->country_, rhs_arena
  );
  swap(retailer_, other->retailer_);
}

std::string SystemProfileProto_DemoModeDimensions::GetTypeName() const {
  return "metrics.SystemProfileProto.DemoModeDimensions";
}


// ===================================================================

class SystemProfileProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SystemProfileProto>()._has_bits_);
  static void set_has_build_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_app_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_log_written_by_app_version(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_brand_code(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_is_extended_stable_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_is_instrumented_build(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_uma_enabled_date(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_install_date(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static const ::metrics::SystemProfileProto_ClonedInstallInfo& cloned_install_info(const SystemProfileProto* msg);
  static void set_has_cloned_install_info(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_low_entropy_source(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_old_low_entropy_source(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_pseudo_low_entropy_source(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_application_locale(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::metrics::SystemProfileProto_OS& os(const SystemProfileProto* msg);
  static void set_has_os(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::metrics::SystemProfileProto_Hardware& hardware(const SystemProfileProto* msg);
  static void set_has_hardware(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::metrics::SystemProfileProto_Network& network(const SystemProfileProto* msg);
  static void set_has_network(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::metrics::SystemProfileProto_GoogleUpdate& google_update(const SystemProfileProto* msg);
  static void set_has_google_update(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::metrics::SystemProfileProto_Stability& stability(const SystemProfileProto* msg);
  static void set_has_stability(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_variations_seed_version(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_client_id_was_used_for_trial_assignment(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_client_uuid(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::metrics::SystemProfileProto_ExternalAccessPoint& external_access_point(const SystemProfileProto* msg);
  static void set_has_external_access_point(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_multi_profile_user_count(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_offstore_extensions_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_uma_default_state(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_app_package_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_app_package_name_allowlist_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_client_side_sampling_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_metrics_filtering_status(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_installer_package(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static const ::metrics::SystemProfileProto_LinkedAndroidPhoneData& linked_android_phone_data(const SystemProfileProto* msg);
  static void set_has_linked_android_phone_data(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::metrics::SystemProfileProto_DemoModeDimensions& demo_mode_dimensions(const SystemProfileProto* msg);
  static void set_has_demo_mode_dimensions(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_lts_channel(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
};

const ::metrics::SystemProfileProto_ClonedInstallInfo&
SystemProfileProto::_Internal::cloned_install_info(const SystemProfileProto* msg) {
  return *msg->cloned_install_info_;
}
const ::metrics::SystemProfileProto_OS&
SystemProfileProto::_Internal::os(const SystemProfileProto* msg) {
  return *msg->os_;
}
const ::metrics::SystemProfileProto_Hardware&
SystemProfileProto::_Internal::hardware(const SystemProfileProto* msg) {
  return *msg->hardware_;
}
const ::metrics::SystemProfileProto_Network&
SystemProfileProto::_Internal::network(const SystemProfileProto* msg) {
  return *msg->network_;
}
const ::metrics::SystemProfileProto_GoogleUpdate&
SystemProfileProto::_Internal::google_update(const SystemProfileProto* msg) {
  return *msg->google_update_;
}
const ::metrics::SystemProfileProto_Stability&
SystemProfileProto::_Internal::stability(const SystemProfileProto* msg) {
  return *msg->stability_;
}
const ::metrics::SystemProfileProto_ExternalAccessPoint&
SystemProfileProto::_Internal::external_access_point(const SystemProfileProto* msg) {
  return *msg->external_access_point_;
}
const ::metrics::SystemProfileProto_LinkedAndroidPhoneData&
SystemProfileProto::_Internal::linked_android_phone_data(const SystemProfileProto* msg) {
  return *msg->linked_android_phone_data_;
}
const ::metrics::SystemProfileProto_DemoModeDimensions&
SystemProfileProto::_Internal::demo_mode_dimensions(const SystemProfileProto* msg) {
  return *msg->demo_mode_dimensions_;
}
void SystemProfileProto::clear_extension_install() {
  extension_install_.Clear();
}
SystemProfileProto::SystemProfileProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  field_trial_(arena),
  external_audio_video_device_(arena),
  occupied_extension_bucket_(arena),
  antivirus_product_(arena),
  chrome_component_(arena),
  extension_install_(arena),
  command_line_key_hash_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:metrics.SystemProfileProto)
}
SystemProfileProto::SystemProfileProto(const SystemProfileProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      field_trial_(from.field_trial_),
      external_audio_video_device_(from.external_audio_video_device_),
      occupied_extension_bucket_(from.occupied_extension_bucket_),
      antivirus_product_(from.antivirus_product_),
      chrome_component_(from.chrome_component_),
      extension_install_(from.extension_install_),
      command_line_key_hash_(from.command_line_key_hash_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  app_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    app_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_app_version()) {
    app_version_.Set(from._internal_app_version(), 
      GetArenaForAllocation());
  }
  application_locale_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    application_locale_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_application_locale()) {
    application_locale_.Set(from._internal_application_locale(), 
      GetArenaForAllocation());
  }
  brand_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    brand_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_brand_code()) {
    brand_code_.Set(from._internal_brand_code(), 
      GetArenaForAllocation());
  }
  app_package_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    app_package_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_app_package_name()) {
    app_package_name_.Set(from._internal_app_package_name(), 
      GetArenaForAllocation());
  }
  variations_seed_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    variations_seed_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_variations_seed_version()) {
    variations_seed_version_.Set(from._internal_variations_seed_version(), 
      GetArenaForAllocation());
  }
  client_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    client_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_client_uuid()) {
    client_uuid_.Set(from._internal_client_uuid(), 
      GetArenaForAllocation());
  }
  log_written_by_app_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    log_written_by_app_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_log_written_by_app_version()) {
    log_written_by_app_version_.Set(from._internal_log_written_by_app_version(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_os()) {
    os_ = new ::metrics::SystemProfileProto_OS(*from.os_);
  } else {
    os_ = nullptr;
  }
  if (from._internal_has_hardware()) {
    hardware_ = new ::metrics::SystemProfileProto_Hardware(*from.hardware_);
  } else {
    hardware_ = nullptr;
  }
  if (from._internal_has_stability()) {
    stability_ = new ::metrics::SystemProfileProto_Stability(*from.stability_);
  } else {
    stability_ = nullptr;
  }
  if (from._internal_has_google_update()) {
    google_update_ = new ::metrics::SystemProfileProto_GoogleUpdate(*from.google_update_);
  } else {
    google_update_ = nullptr;
  }
  if (from._internal_has_network()) {
    network_ = new ::metrics::SystemProfileProto_Network(*from.network_);
  } else {
    network_ = nullptr;
  }
  if (from._internal_has_external_access_point()) {
    external_access_point_ = new ::metrics::SystemProfileProto_ExternalAccessPoint(*from.external_access_point_);
  } else {
    external_access_point_ = nullptr;
  }
  if (from._internal_has_linked_android_phone_data()) {
    linked_android_phone_data_ = new ::metrics::SystemProfileProto_LinkedAndroidPhoneData(*from.linked_android_phone_data_);
  } else {
    linked_android_phone_data_ = nullptr;
  }
  if (from._internal_has_cloned_install_info()) {
    cloned_install_info_ = new ::metrics::SystemProfileProto_ClonedInstallInfo(*from.cloned_install_info_);
  } else {
    cloned_install_info_ = nullptr;
  }
  if (from._internal_has_demo_mode_dimensions()) {
    demo_mode_dimensions_ = new ::metrics::SystemProfileProto_DemoModeDimensions(*from.demo_mode_dimensions_);
  } else {
    demo_mode_dimensions_ = nullptr;
  }
  ::memcpy(&build_timestamp_, &from.build_timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&lts_channel_) -
    reinterpret_cast<char*>(&build_timestamp_)) + sizeof(lts_channel_));
  // @@protoc_insertion_point(copy_constructor:metrics.SystemProfileProto)
}

inline void SystemProfileProto::SharedCtor() {
app_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  app_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
application_locale_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  application_locale_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
brand_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  brand_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
app_package_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  app_package_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
variations_seed_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  variations_seed_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
client_uuid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  client_uuid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
log_written_by_app_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  log_written_by_app_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&os_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&lts_channel_) -
    reinterpret_cast<char*>(&os_)) + sizeof(lts_channel_));
}

SystemProfileProto::~SystemProfileProto() {
  // @@protoc_insertion_point(destructor:metrics.SystemProfileProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemProfileProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  app_version_.Destroy();
  application_locale_.Destroy();
  brand_code_.Destroy();
  app_package_name_.Destroy();
  variations_seed_version_.Destroy();
  client_uuid_.Destroy();
  log_written_by_app_version_.Destroy();
  if (this != internal_default_instance()) delete os_;
  if (this != internal_default_instance()) delete hardware_;
  if (this != internal_default_instance()) delete stability_;
  if (this != internal_default_instance()) delete google_update_;
  if (this != internal_default_instance()) delete network_;
  if (this != internal_default_instance()) delete external_access_point_;
  if (this != internal_default_instance()) delete linked_android_phone_data_;
  if (this != internal_default_instance()) delete cloned_install_info_;
  if (this != internal_default_instance()) delete demo_mode_dimensions_;
}

void SystemProfileProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SystemProfileProto::Clear() {
// @@protoc_insertion_point(message_clear_start:metrics.SystemProfileProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  field_trial_.Clear();
  external_audio_video_device_.Clear();
  occupied_extension_bucket_.Clear();
  antivirus_product_.Clear();
  chrome_component_.Clear();
  extension_install_.Clear();
  command_line_key_hash_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      app_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      application_locale_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      brand_code_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      app_package_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      variations_seed_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      client_uuid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      log_written_by_app_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(os_ != nullptr);
      os_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(hardware_ != nullptr);
      hardware_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(stability_ != nullptr);
      stability_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(google_update_ != nullptr);
      google_update_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(network_ != nullptr);
      network_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(external_access_point_ != nullptr);
      external_access_point_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(linked_android_phone_data_ != nullptr);
      linked_android_phone_data_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(cloned_install_info_ != nullptr);
      cloned_install_info_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(demo_mode_dimensions_ != nullptr);
      demo_mode_dimensions_->Clear();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&build_timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_extended_stable_channel_) -
        reinterpret_cast<char*>(&build_timestamp_)) + sizeof(is_extended_stable_channel_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&is_instrumented_build_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&client_side_sampling_status_) -
        reinterpret_cast<char*>(&is_instrumented_build_)) + sizeof(client_side_sampling_status_));
  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&metrics_filtering_status_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lts_channel_) -
        reinterpret_cast<char*>(&metrics_filtering_status_)) + sizeof(lts_channel_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SystemProfileProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 build_timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_build_timestamp(&_has_bits_);
          build_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string app_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_app_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 uma_enabled_date = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_uma_enabled_date(&_has_bits_);
          uma_enabled_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string application_locale = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_application_locale();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.OS os = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_os(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.Hardware hardware = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_hardware(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.Stability stability = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_stability(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .metrics.SystemProfileProto.FieldTrial field_trial = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_field_trial(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.Channel channel = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_Channel_IsValid(val))) {
            _internal_set_channel(static_cast<::metrics::SystemProfileProto_Channel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.GoogleUpdate google_update = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_google_update(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string brand_code = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_brand_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.Network network = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_network(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .metrics.SystemProfileProto.ExternalAudioVideoDevice external_audio_video_device = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_external_audio_video_device(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.ExternalAccessPoint external_access_point = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_external_access_point(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 install_date = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_install_date(&_has_bits_);
          install_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 multi_profile_user_count = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_multi_profile_user_count(&_has_bits_);
          multi_profile_user_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 occupied_extension_bucket = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_occupied_extension_bucket(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<144>(ptr));
        } else if (static_cast<uint8_t>(tag) == 146) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_occupied_extension_bucket(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.ExtensionsState offstore_extensions_state = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_ExtensionsState_IsValid(val))) {
            _internal_set_offstore_extensions_state(static_cast<::metrics::SystemProfileProto_ExtensionsState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(19, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool is_instrumented_build = 20 [default = false];
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_is_instrumented_build(&_has_bits_);
          is_instrumented_build_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.UmaDefaultState uma_default_state = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_UmaDefaultState_IsValid(val))) {
            _internal_set_uma_default_state(static_cast<::metrics::SystemProfileProto_UmaDefaultState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(22, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .metrics.SystemProfileProto.AntiVirusProduct antivirus_product = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_antivirus_product(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<186>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .metrics.SystemProfileProto.ChromeComponent chrome_component = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_chrome_component(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<194>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .metrics.ExtensionInstallProto extension_install = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_extension_install(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<202>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string app_package_name = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          auto str = _internal_mutable_app_package_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string variations_seed_version = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          auto str = _internal_mutable_variations_seed_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.LinkedAndroidPhoneData linked_android_phone_data = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_linked_android_phone_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 low_entropy_source = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_low_entropy_source(&_has_bits_);
          low_entropy_source_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 old_low_entropy_source = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _Internal::set_has_old_low_entropy_source(&_has_bits_);
          old_low_entropy_source_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool client_id_was_used_for_trial_assignment = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_client_id_was_used_for_trial_assignment(&_has_bits_);
          client_id_was_used_for_trial_assignment_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string client_uuid = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_client_uuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.InstallerPackage installer_package = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_InstallerPackage_IsValid(val))) {
            _internal_set_installer_package(static_cast<::metrics::SystemProfileProto_InstallerPackage>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(35, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool is_extended_stable_channel = 36 [default = false];
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_extended_stable_channel(&_has_bits_);
          is_extended_stable_channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pseudo_low_entropy_source = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_pseudo_low_entropy_source(&_has_bits_);
          pseudo_low_entropy_source_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated fixed32 command_line_key_hash = 38 [packed = true];
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_command_line_key_hash(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 53) {
          _internal_add_command_line_key_hash(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.ClonedInstallInfo cloned_install_info = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_cloned_install_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string log_written_by_app_version = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_log_written_by_app_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.DemoModeDimensions demo_mode_dimensions = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_demo_mode_dimensions(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.AppPackageNameAllowlistFilter app_package_name_allowlist_filter = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_AppPackageNameAllowlistFilter_IsValid(val))) {
            _internal_set_app_package_name_allowlist_filter(static_cast<::metrics::SystemProfileProto_AppPackageNameAllowlistFilter>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(42, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.ClientSideSamplingStatus client_side_sampling_status = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_ClientSideSamplingStatus_IsValid(val))) {
            _internal_set_client_side_sampling_status(static_cast<::metrics::SystemProfileProto_ClientSideSamplingStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(43, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.MetricsFilteringStatus metrics_filtering_status = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_MetricsFilteringStatus_IsValid(val))) {
            _internal_set_metrics_filtering_status(static_cast<::metrics::SystemProfileProto_MetricsFilteringStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(44, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .metrics.SystemProfileProto.LTSChannel lts_channel = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::metrics::SystemProfileProto_LTSChannel_IsValid(val))) {
            _internal_set_lts_channel(static_cast<::metrics::SystemProfileProto_LTSChannel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(45, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemProfileProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:metrics.SystemProfileProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 build_timestamp = 1;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_build_timestamp(), target);
  }

  // optional string app_version = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_app_version(), target);
  }

  // optional int64 uma_enabled_date = 3;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_uma_enabled_date(), target);
  }

  // optional string application_locale = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_application_locale(), target);
  }

  // optional .metrics.SystemProfileProto.OS os = 5;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::os(this),
        _Internal::os(this).GetCachedSize(), target, stream);
  }

  // optional .metrics.SystemProfileProto.Hardware hardware = 6;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::hardware(this),
        _Internal::hardware(this).GetCachedSize(), target, stream);
  }

  // optional .metrics.SystemProfileProto.Stability stability = 8;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::stability(this),
        _Internal::stability(this).GetCachedSize(), target, stream);
  }

  // repeated .metrics.SystemProfileProto.FieldTrial field_trial = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_field_trial_size()); i < n; i++) {
    const auto& repfield = this->_internal_field_trial(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .metrics.SystemProfileProto.Channel channel = 10;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_channel(), target);
  }

  // optional .metrics.SystemProfileProto.GoogleUpdate google_update = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::google_update(this),
        _Internal::google_update(this).GetCachedSize(), target, stream);
  }

  // optional string brand_code = 12;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_brand_code(), target);
  }

  // optional .metrics.SystemProfileProto.Network network = 13;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::network(this),
        _Internal::network(this).GetCachedSize(), target, stream);
  }

  // repeated .metrics.SystemProfileProto.ExternalAudioVideoDevice external_audio_video_device = 14;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_external_audio_video_device_size()); i < n; i++) {
    const auto& repfield = this->_internal_external_audio_video_device(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .metrics.SystemProfileProto.ExternalAccessPoint external_access_point = 15;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::external_access_point(this),
        _Internal::external_access_point(this).GetCachedSize(), target, stream);
  }

  // optional int64 install_date = 16;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(16, this->_internal_install_date(), target);
  }

  // optional uint32 multi_profile_user_count = 17;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_multi_profile_user_count(), target);
  }

  // repeated int32 occupied_extension_bucket = 18;
  for (int i = 0, n = this->_internal_occupied_extension_bucket_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(18, this->_internal_occupied_extension_bucket(i), target);
  }

  // optional .metrics.SystemProfileProto.ExtensionsState offstore_extensions_state = 19;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      19, this->_internal_offstore_extensions_state(), target);
  }

  // optional bool is_instrumented_build = 20 [default = false];
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_is_instrumented_build(), target);
  }

  // optional .metrics.SystemProfileProto.UmaDefaultState uma_default_state = 22;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      22, this->_internal_uma_default_state(), target);
  }

  // repeated .metrics.SystemProfileProto.AntiVirusProduct antivirus_product = 23;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_antivirus_product_size()); i < n; i++) {
    const auto& repfield = this->_internal_antivirus_product(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(23, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .metrics.SystemProfileProto.ChromeComponent chrome_component = 24;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_chrome_component_size()); i < n; i++) {
    const auto& repfield = this->_internal_chrome_component(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(24, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .metrics.ExtensionInstallProto extension_install = 25;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extension_install_size()); i < n; i++) {
    const auto& repfield = this->_internal_extension_install(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(25, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string app_package_name = 26;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        26, this->_internal_app_package_name(), target);
  }

  // optional string variations_seed_version = 28;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        28, this->_internal_variations_seed_version(), target);
  }

  // optional .metrics.SystemProfileProto.LinkedAndroidPhoneData linked_android_phone_data = 29;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(29, _Internal::linked_android_phone_data(this),
        _Internal::linked_android_phone_data(this).GetCachedSize(), target, stream);
  }

  // optional int32 low_entropy_source = 31;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(31, this->_internal_low_entropy_source(), target);
  }

  // optional int32 old_low_entropy_source = 32;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(32, this->_internal_old_low_entropy_source(), target);
  }

  // optional bool client_id_was_used_for_trial_assignment = 33;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(33, this->_internal_client_id_was_used_for_trial_assignment(), target);
  }

  // optional string client_uuid = 34;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        34, this->_internal_client_uuid(), target);
  }

  // optional .metrics.SystemProfileProto.InstallerPackage installer_package = 35;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      35, this->_internal_installer_package(), target);
  }

  // optional bool is_extended_stable_channel = 36 [default = false];
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(36, this->_internal_is_extended_stable_channel(), target);
  }

  // optional int32 pseudo_low_entropy_source = 37;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(37, this->_internal_pseudo_low_entropy_source(), target);
  }

  // repeated fixed32 command_line_key_hash = 38 [packed = true];
  if (this->_internal_command_line_key_hash_size() > 0) {
    target = stream->WriteFixedPacked(38, _internal_command_line_key_hash(), target);
  }

  // optional .metrics.SystemProfileProto.ClonedInstallInfo cloned_install_info = 39;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(39, _Internal::cloned_install_info(this),
        _Internal::cloned_install_info(this).GetCachedSize(), target, stream);
  }

  // optional string log_written_by_app_version = 40;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteStringMaybeAliased(
        40, this->_internal_log_written_by_app_version(), target);
  }

  // optional .metrics.SystemProfileProto.DemoModeDimensions demo_mode_dimensions = 41;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(41, _Internal::demo_mode_dimensions(this),
        _Internal::demo_mode_dimensions(this).GetCachedSize(), target, stream);
  }

  // optional .metrics.SystemProfileProto.AppPackageNameAllowlistFilter app_package_name_allowlist_filter = 42;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      42, this->_internal_app_package_name_allowlist_filter(), target);
  }

  // optional .metrics.SystemProfileProto.ClientSideSamplingStatus client_side_sampling_status = 43;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      43, this->_internal_client_side_sampling_status(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional .metrics.SystemProfileProto.MetricsFilteringStatus metrics_filtering_status = 44;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      44, this->_internal_metrics_filtering_status(), target);
  }

  // optional .metrics.SystemProfileProto.LTSChannel lts_channel = 45;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      45, this->_internal_lts_channel(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:metrics.SystemProfileProto)
  return target;
}

size_t SystemProfileProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:metrics.SystemProfileProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .metrics.SystemProfileProto.FieldTrial field_trial = 9;
  total_size += 1UL * this->_internal_field_trial_size();
  for (const auto& msg : this->field_trial_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .metrics.SystemProfileProto.ExternalAudioVideoDevice external_audio_video_device = 14;
  total_size += 1UL * this->_internal_external_audio_video_device_size();
  for (const auto& msg : this->external_audio_video_device_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated int32 occupied_extension_bucket = 18;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->occupied_extension_bucket_);
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_occupied_extension_bucket_size());
    total_size += data_size;
  }

  // repeated .metrics.SystemProfileProto.AntiVirusProduct antivirus_product = 23;
  total_size += 2UL * this->_internal_antivirus_product_size();
  for (const auto& msg : this->antivirus_product_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .metrics.SystemProfileProto.ChromeComponent chrome_component = 24;
  total_size += 2UL * this->_internal_chrome_component_size();
  for (const auto& msg : this->chrome_component_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .metrics.ExtensionInstallProto extension_install = 25;
  total_size += 2UL * this->_internal_extension_install_size();
  for (const auto& msg : this->extension_install_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated fixed32 command_line_key_hash = 38 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_command_line_key_hash_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string app_version = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_app_version());
    }

    // optional string application_locale = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_application_locale());
    }

    // optional string brand_code = 12;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_brand_code());
    }

    // optional string app_package_name = 26;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_app_package_name());
    }

    // optional string variations_seed_version = 28;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_variations_seed_version());
    }

    // optional string client_uuid = 34;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_uuid());
    }

    // optional string log_written_by_app_version = 40;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_log_written_by_app_version());
    }

    // optional .metrics.SystemProfileProto.OS os = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *os_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .metrics.SystemProfileProto.Hardware hardware = 6;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *hardware_);
    }

    // optional .metrics.SystemProfileProto.Stability stability = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *stability_);
    }

    // optional .metrics.SystemProfileProto.GoogleUpdate google_update = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *google_update_);
    }

    // optional .metrics.SystemProfileProto.Network network = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *network_);
    }

    // optional .metrics.SystemProfileProto.ExternalAccessPoint external_access_point = 15;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *external_access_point_);
    }

    // optional .metrics.SystemProfileProto.LinkedAndroidPhoneData linked_android_phone_data = 29;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *linked_android_phone_data_);
    }

    // optional .metrics.SystemProfileProto.ClonedInstallInfo cloned_install_info = 39;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cloned_install_info_);
    }

    // optional .metrics.SystemProfileProto.DemoModeDimensions demo_mode_dimensions = 41;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *demo_mode_dimensions_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional int64 build_timestamp = 1;
    if (cached_has_bits & 0x00010000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_build_timestamp());
    }

    // optional int64 uma_enabled_date = 3;
    if (cached_has_bits & 0x00020000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_uma_enabled_date());
    }

    // optional .metrics.SystemProfileProto.Channel channel = 10;
    if (cached_has_bits & 0x00040000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_channel());
    }

    // optional uint32 multi_profile_user_count = 17;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_multi_profile_user_count());
    }

    // optional int64 install_date = 16;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_install_date());
    }

    // optional .metrics.SystemProfileProto.ExtensionsState offstore_extensions_state = 19;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_offstore_extensions_state());
    }

    // optional .metrics.SystemProfileProto.UmaDefaultState uma_default_state = 22;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_uma_default_state());
    }

    // optional bool is_extended_stable_channel = 36 [default = false];
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional bool is_instrumented_build = 20 [default = false];
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 1;
    }

    // optional bool client_id_was_used_for_trial_assignment = 33;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 1;
    }

    // optional int32 low_entropy_source = 31;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_low_entropy_source());
    }

    // optional int32 old_low_entropy_source = 32;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_old_low_entropy_source());
    }

    // optional .metrics.SystemProfileProto.InstallerPackage installer_package = 35;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_installer_package());
    }

    // optional int32 pseudo_low_entropy_source = 37;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_pseudo_low_entropy_source());
    }

    // optional .metrics.SystemProfileProto.AppPackageNameAllowlistFilter app_package_name_allowlist_filter = 42;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_app_package_name_allowlist_filter());
    }

    // optional .metrics.SystemProfileProto.ClientSideSamplingStatus client_side_sampling_status = 43;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_client_side_sampling_status());
    }

  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x00000003u) {
    // optional .metrics.SystemProfileProto.MetricsFilteringStatus metrics_filtering_status = 44;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_metrics_filtering_status());
    }

    // optional .metrics.SystemProfileProto.LTSChannel lts_channel = 45;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_lts_channel());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SystemProfileProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SystemProfileProto*>(
      &from));
}

void SystemProfileProto::MergeFrom(const SystemProfileProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:metrics.SystemProfileProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  field_trial_.MergeFrom(from.field_trial_);
  external_audio_video_device_.MergeFrom(from.external_audio_video_device_);
  occupied_extension_bucket_.MergeFrom(from.occupied_extension_bucket_);
  antivirus_product_.MergeFrom(from.antivirus_product_);
  chrome_component_.MergeFrom(from.chrome_component_);
  extension_install_.MergeFrom(from.extension_install_);
  command_line_key_hash_.MergeFrom(from.command_line_key_hash_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_app_version(from._internal_app_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_application_locale(from._internal_application_locale());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_brand_code(from._internal_brand_code());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_app_package_name(from._internal_app_package_name());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_variations_seed_version(from._internal_variations_seed_version());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_client_uuid(from._internal_client_uuid());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_log_written_by_app_version(from._internal_log_written_by_app_version());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_os()->::metrics::SystemProfileProto_OS::MergeFrom(from._internal_os());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_hardware()->::metrics::SystemProfileProto_Hardware::MergeFrom(from._internal_hardware());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_mutable_stability()->::metrics::SystemProfileProto_Stability::MergeFrom(from._internal_stability());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_mutable_google_update()->::metrics::SystemProfileProto_GoogleUpdate::MergeFrom(from._internal_google_update());
    }
    if (cached_has_bits & 0x00000800u) {
      _internal_mutable_network()->::metrics::SystemProfileProto_Network::MergeFrom(from._internal_network());
    }
    if (cached_has_bits & 0x00001000u) {
      _internal_mutable_external_access_point()->::metrics::SystemProfileProto_ExternalAccessPoint::MergeFrom(from._internal_external_access_point());
    }
    if (cached_has_bits & 0x00002000u) {
      _internal_mutable_linked_android_phone_data()->::metrics::SystemProfileProto_LinkedAndroidPhoneData::MergeFrom(from._internal_linked_android_phone_data());
    }
    if (cached_has_bits & 0x00004000u) {
      _internal_mutable_cloned_install_info()->::metrics::SystemProfileProto_ClonedInstallInfo::MergeFrom(from._internal_cloned_install_info());
    }
    if (cached_has_bits & 0x00008000u) {
      _internal_mutable_demo_mode_dimensions()->::metrics::SystemProfileProto_DemoModeDimensions::MergeFrom(from._internal_demo_mode_dimensions());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      build_timestamp_ = from.build_timestamp_;
    }
    if (cached_has_bits & 0x00020000u) {
      uma_enabled_date_ = from.uma_enabled_date_;
    }
    if (cached_has_bits & 0x00040000u) {
      channel_ = from.channel_;
    }
    if (cached_has_bits & 0x00080000u) {
      multi_profile_user_count_ = from.multi_profile_user_count_;
    }
    if (cached_has_bits & 0x00100000u) {
      install_date_ = from.install_date_;
    }
    if (cached_has_bits & 0x00200000u) {
      offstore_extensions_state_ = from.offstore_extensions_state_;
    }
    if (cached_has_bits & 0x00400000u) {
      uma_default_state_ = from.uma_default_state_;
    }
    if (cached_has_bits & 0x00800000u) {
      is_extended_stable_channel_ = from.is_extended_stable_channel_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      is_instrumented_build_ = from.is_instrumented_build_;
    }
    if (cached_has_bits & 0x02000000u) {
      client_id_was_used_for_trial_assignment_ = from.client_id_was_used_for_trial_assignment_;
    }
    if (cached_has_bits & 0x04000000u) {
      low_entropy_source_ = from.low_entropy_source_;
    }
    if (cached_has_bits & 0x08000000u) {
      old_low_entropy_source_ = from.old_low_entropy_source_;
    }
    if (cached_has_bits & 0x10000000u) {
      installer_package_ = from.installer_package_;
    }
    if (cached_has_bits & 0x20000000u) {
      pseudo_low_entropy_source_ = from.pseudo_low_entropy_source_;
    }
    if (cached_has_bits & 0x40000000u) {
      app_package_name_allowlist_filter_ = from.app_package_name_allowlist_filter_;
    }
    if (cached_has_bits & 0x80000000u) {
      client_side_sampling_status_ = from.client_side_sampling_status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._has_bits_[1];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      metrics_filtering_status_ = from.metrics_filtering_status_;
    }
    if (cached_has_bits & 0x00000002u) {
      lts_channel_ = from.lts_channel_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemProfileProto::CopyFrom(const SystemProfileProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:metrics.SystemProfileProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemProfileProto::IsInitialized() const {
  return true;
}

void SystemProfileProto::InternalSwap(SystemProfileProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(_has_bits_[1], other->_has_bits_[1]);
  field_trial_.InternalSwap(&other->field_trial_);
  external_audio_video_device_.InternalSwap(&other->external_audio_video_device_);
  occupied_extension_bucket_.InternalSwap(&other->occupied_extension_bucket_);
  antivirus_product_.InternalSwap(&other->antivirus_product_);
  chrome_component_.InternalSwap(&other->chrome_component_);
  extension_install_.InternalSwap(&other->extension_install_);
  command_line_key_hash_.InternalSwap(&other->command_line_key_hash_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &app_version_, lhs_arena,
      &other->app_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &application_locale_, lhs_arena,
      &other->application_locale_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &brand_code_, lhs_arena,
      &other->brand_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &app_package_name_, lhs_arena,
      &other->app_package_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &variations_seed_version_, lhs_arena,
      &other->variations_seed_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &client_uuid_, lhs_arena,
      &other->client_uuid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &log_written_by_app_version_, lhs_arena,
      &other->log_written_by_app_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemProfileProto, lts_channel_)
      + sizeof(SystemProfileProto::lts_channel_)
      - PROTOBUF_FIELD_OFFSET(SystemProfileProto, os_)>(
          reinterpret_cast<char*>(&os_),
          reinterpret_cast<char*>(&other->os_));
}

std::string SystemProfileProto::GetTypeName() const {
  return "metrics.SystemProfileProto";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace metrics
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto_ClonedInstallInfo*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto_ClonedInstallInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto_ClonedInstallInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto_OS_Arc*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto_OS_Arc >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto_OS_Arc >(arena);
}
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto_OS*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto_OS >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto_OS >(arena);
}
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto_Hardware_CPU*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto_Hardware_CPU >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto_Hardware_CPU >(arena);
}
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto_Hardware_Motherboard*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto_Hardware_Motherboard >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto_Hardware_Motherboard >(arena);
}
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto_Hardware_Graphics*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto_Hardware_Graphics >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto_Hardware_Graphics >(arena);
}
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto_Hardware_InternalStorageDevice*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto_Hardware_InternalStorageDevice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto_Hardware_InternalStorageDevice >(arena);
}
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto_Hardware_Drive*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto_Hardware_Drive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto_Hardware_Drive >(arena);
}
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto_Hardware*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto_Hardware >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto_Hardware >(arena);
}
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto_Network*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto_Network >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto_Network >(arena);
}
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto_GoogleUpdate_ProductInfo*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto_GoogleUpdate_ProductInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto_GoogleUpdate_ProductInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto_GoogleUpdate*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto_GoogleUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto_GoogleUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto_Stability*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto_Stability >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto_Stability >(arena);
}
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto_FieldTrial*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto_FieldTrial >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto_FieldTrial >(arena);
}
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto_ExternalAudioVideoDevice_AudioDescription*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto_ExternalAudioVideoDevice_AudioDescription >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto_ExternalAudioVideoDevice_AudioDescription >(arena);
}
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto_ExternalAudioVideoDevice_CECCommand*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto_ExternalAudioVideoDevice_CECCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto_ExternalAudioVideoDevice_CECCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto_ExternalAudioVideoDevice*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto_ExternalAudioVideoDevice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto_ExternalAudioVideoDevice >(arena);
}
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto_ExternalAccessPoint*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto_ExternalAccessPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto_ExternalAccessPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto_AntiVirusProduct*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto_AntiVirusProduct >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto_AntiVirusProduct >(arena);
}
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto_ChromeComponent*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto_ChromeComponent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto_ChromeComponent >(arena);
}
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto_LinkedAndroidPhoneData*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto_LinkedAndroidPhoneData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto_LinkedAndroidPhoneData >(arena);
}
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto_DemoModeDimensions_Retailer*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto_DemoModeDimensions_Retailer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto_DemoModeDimensions_Retailer >(arena);
}
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto_DemoModeDimensions*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto_DemoModeDimensions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto_DemoModeDimensions >(arena);
}
template<> PROTOBUF_NOINLINE ::metrics::SystemProfileProto*
Arena::CreateMaybeMessage< ::metrics::SystemProfileProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::metrics::SystemProfileProto >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
