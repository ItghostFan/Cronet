// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: execution_context.proto

#include "execution_context.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace metrics {
}  // namespace metrics
namespace metrics {
bool Process_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Process_strings[11] = {};

static const char Process_names[] =
  "BROWSER_PROCESS"
  "GPU_PROCESS"
  "NETWORK_SERVICE_PROCESS"
  "OTHER_PROCESS"
  "PPAPI_BROKER_PROCESS"
  "PPAPI_PLUGIN_PROCESS"
  "RENDERER_PROCESS"
  "SANDBOX_HELPER_PROCESS"
  "UNKNOWN_PROCESS"
  "UTILITY_PROCESS"
  "ZYGOTE_PROCESS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Process_entries[] = {
  { {Process_names + 0, 15}, 1 },
  { {Process_names + 15, 11}, 3 },
  { {Process_names + 26, 23}, 10 },
  { {Process_names + 49, 13}, 9 },
  { {Process_names + 62, 20}, 8 },
  { {Process_names + 82, 20}, 7 },
  { {Process_names + 102, 16}, 2 },
  { {Process_names + 118, 22}, 6 },
  { {Process_names + 140, 15}, 0 },
  { {Process_names + 155, 15}, 4 },
  { {Process_names + 170, 14}, 5 },
};

static const int Process_entries_by_number[] = {
  8, // 0 -> UNKNOWN_PROCESS
  0, // 1 -> BROWSER_PROCESS
  6, // 2 -> RENDERER_PROCESS
  1, // 3 -> GPU_PROCESS
  9, // 4 -> UTILITY_PROCESS
  10, // 5 -> ZYGOTE_PROCESS
  7, // 6 -> SANDBOX_HELPER_PROCESS
  5, // 7 -> PPAPI_PLUGIN_PROCESS
  4, // 8 -> PPAPI_BROKER_PROCESS
  3, // 9 -> OTHER_PROCESS
  2, // 10 -> NETWORK_SERVICE_PROCESS
};

const std::string& Process_Name(
    Process value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Process_entries,
          Process_entries_by_number,
          11, Process_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Process_entries,
      Process_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Process_strings[idx].get();
}
bool Process_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Process* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Process_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<Process>(int_value);
  }
  return success;
}
bool Thread_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Thread_strings[26] = {};

static const char Thread_names[] =
  "AUDIO_DEVICE_THREAD"
  "AUDIO_THREAD"
  "CACHE_THREAD"
  "COMPOSITOR_THREAD"
  "COMPOSITOR_TILE_WORKER_THREAD"
  "DAV1D_WORKER_THREAD"
  "DB_THREAD"
  "DEDICATED_WORKER_THREAD"
  "DRM_THREAD"
  "FILE_THREAD"
  "FILE_USER_BLOCKING_THREAD"
  "GPU_MAIN_THREAD"
  "GPU_MEMORY_THREAD"
  "IO_THREAD"
  "MAIN_THREAD"
  "MEDIA_THREAD"
  "MEMORY_INFRA_THREAD"
  "OTHER_THREAD"
  "PROCESS_LAUNCHER_THREAD"
  "RENDER_THREAD"
  "SCHEDULER_WORKER_THREAD"
  "SERVICE_WORKER_THREAD"
  "THREAD_POOL_THREAD"
  "UNKNOWN_THREAD"
  "UTILITY_THREAD"
  "WEBRTC_THREAD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Thread_entries[] = {
  { {Thread_names + 0, 19}, 23 },
  { {Thread_names + 19, 12}, 24 },
  { {Thread_names + 31, 12}, 5 },
  { {Thread_names + 43, 17}, 11 },
  { {Thread_names + 60, 29}, 14 },
  { {Thread_names + 89, 19}, 25 },
  { {Thread_names + 108, 9}, 7 },
  { {Thread_names + 117, 23}, 18 },
  { {Thread_names + 140, 10}, 22 },
  { {Thread_names + 150, 11}, 2 },
  { {Thread_names + 161, 25}, 3 },
  { {Thread_names + 186, 15}, 8 },
  { {Thread_names + 201, 17}, 17 },
  { {Thread_names + 218, 9}, 6 },
  { {Thread_names + 227, 11}, 1 },
  { {Thread_names + 238, 12}, 20 },
  { {Thread_names + 250, 19}, 19 },
  { {Thread_names + 269, 12}, 12 },
  { {Thread_names + 281, 23}, 4 },
  { {Thread_names + 304, 13}, 9 },
  { {Thread_names + 317, 23}, 13 },
  { {Thread_names + 340, 21}, 15 },
  { {Thread_names + 361, 18}, 16 },
  { {Thread_names + 379, 14}, 0 },
  { {Thread_names + 393, 14}, 10 },
  { {Thread_names + 407, 13}, 21 },
};

static const int Thread_entries_by_number[] = {
  23, // 0 -> UNKNOWN_THREAD
  14, // 1 -> MAIN_THREAD
  9, // 2 -> FILE_THREAD
  10, // 3 -> FILE_USER_BLOCKING_THREAD
  18, // 4 -> PROCESS_LAUNCHER_THREAD
  2, // 5 -> CACHE_THREAD
  13, // 6 -> IO_THREAD
  6, // 7 -> DB_THREAD
  11, // 8 -> GPU_MAIN_THREAD
  19, // 9 -> RENDER_THREAD
  24, // 10 -> UTILITY_THREAD
  3, // 11 -> COMPOSITOR_THREAD
  17, // 12 -> OTHER_THREAD
  20, // 13 -> SCHEDULER_WORKER_THREAD
  4, // 14 -> COMPOSITOR_TILE_WORKER_THREAD
  21, // 15 -> SERVICE_WORKER_THREAD
  22, // 16 -> THREAD_POOL_THREAD
  12, // 17 -> GPU_MEMORY_THREAD
  7, // 18 -> DEDICATED_WORKER_THREAD
  16, // 19 -> MEMORY_INFRA_THREAD
  15, // 20 -> MEDIA_THREAD
  25, // 21 -> WEBRTC_THREAD
  8, // 22 -> DRM_THREAD
  0, // 23 -> AUDIO_DEVICE_THREAD
  1, // 24 -> AUDIO_THREAD
  5, // 25 -> DAV1D_WORKER_THREAD
};

const std::string& Thread_Name(
    Thread value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Thread_entries,
          Thread_entries_by_number,
          26, Thread_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Thread_entries,
      Thread_entries_by_number,
      26, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Thread_strings[idx].get();
}
bool Thread_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Thread* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Thread_entries, 26, name, &int_value);
  if (success) {
    *value = static_cast<Thread>(int_value);
  }
  return success;
}
bool ProcessPhase_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ProcessPhase_strings[5] = {};

static const char ProcessPhase_names[] =
  "FIRST_NONEMPTY_PAINT"
  "MAIN_LOOP_START"
  "MAIN_NAVIGATION_FINISHED"
  "MAIN_NAVIGATION_START"
  "SHUTDOWN_START";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ProcessPhase_entries[] = {
  { {ProcessPhase_names + 0, 20}, 3 },
  { {ProcessPhase_names + 20, 15}, 0 },
  { {ProcessPhase_names + 35, 24}, 2 },
  { {ProcessPhase_names + 59, 21}, 1 },
  { {ProcessPhase_names + 80, 14}, 4 },
};

static const int ProcessPhase_entries_by_number[] = {
  1, // 0 -> MAIN_LOOP_START
  3, // 1 -> MAIN_NAVIGATION_START
  2, // 2 -> MAIN_NAVIGATION_FINISHED
  0, // 3 -> FIRST_NONEMPTY_PAINT
  4, // 4 -> SHUTDOWN_START
};

const std::string& ProcessPhase_Name(
    ProcessPhase value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ProcessPhase_entries,
          ProcessPhase_entries_by_number,
          5, ProcessPhase_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ProcessPhase_entries,
      ProcessPhase_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ProcessPhase_strings[idx].get();
}
bool ProcessPhase_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProcessPhase* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ProcessPhase_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ProcessPhase>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace metrics
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
