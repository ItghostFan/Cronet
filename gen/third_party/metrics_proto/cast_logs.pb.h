// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cast_logs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_cast_5flogs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_cast_5flogs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_cast_5flogs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_cast_5flogs_2eproto {
  static const uint32_t offsets[];
};
namespace metrics {
class CastLogsProto;
struct CastLogsProtoDefaultTypeInternal;
extern CastLogsProtoDefaultTypeInternal _CastLogsProto_default_instance_;
class CastLogsProto_CastConnectionInfo;
struct CastLogsProto_CastConnectionInfoDefaultTypeInternal;
extern CastLogsProto_CastConnectionInfoDefaultTypeInternal _CastLogsProto_CastConnectionInfo_default_instance_;
class CastLogsProto_CastConnectionInfo_SenderInfo;
struct CastLogsProto_CastConnectionInfo_SenderInfoDefaultTypeInternal;
extern CastLogsProto_CastConnectionInfo_SenderInfoDefaultTypeInternal _CastLogsProto_CastConnectionInfo_SenderInfo_default_instance_;
class CastLogsProto_CastDeviceInfo;
struct CastLogsProto_CastDeviceInfoDefaultTypeInternal;
extern CastLogsProto_CastDeviceInfoDefaultTypeInternal _CastLogsProto_CastDeviceInfo_default_instance_;
class CastLogsProto_CastDeviceInfo_HardwareInfo;
struct CastLogsProto_CastDeviceInfo_HardwareInfoDefaultTypeInternal;
extern CastLogsProto_CastDeviceInfo_HardwareInfoDefaultTypeInternal _CastLogsProto_CastDeviceInfo_HardwareInfo_default_instance_;
class CastLogsProto_CastDeviceMutableInfo;
struct CastLogsProto_CastDeviceMutableInfoDefaultTypeInternal;
extern CastLogsProto_CastDeviceMutableInfoDefaultTypeInternal _CastLogsProto_CastDeviceMutableInfo_default_instance_;
class CastLogsProto_CastEventProto;
struct CastLogsProto_CastEventProtoDefaultTypeInternal;
extern CastLogsProto_CastEventProtoDefaultTypeInternal _CastLogsProto_CastEventProto_default_instance_;
class CastLogsProto_CastEventProto_Metadata;
struct CastLogsProto_CastEventProto_MetadataDefaultTypeInternal;
extern CastLogsProto_CastEventProto_MetadataDefaultTypeInternal _CastLogsProto_CastEventProto_Metadata_default_instance_;
}  // namespace metrics
PROTOBUF_NAMESPACE_OPEN
template<> ::metrics::CastLogsProto* Arena::CreateMaybeMessage<::metrics::CastLogsProto>(Arena*);
template<> ::metrics::CastLogsProto_CastConnectionInfo* Arena::CreateMaybeMessage<::metrics::CastLogsProto_CastConnectionInfo>(Arena*);
template<> ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo* Arena::CreateMaybeMessage<::metrics::CastLogsProto_CastConnectionInfo_SenderInfo>(Arena*);
template<> ::metrics::CastLogsProto_CastDeviceInfo* Arena::CreateMaybeMessage<::metrics::CastLogsProto_CastDeviceInfo>(Arena*);
template<> ::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo* Arena::CreateMaybeMessage<::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo>(Arena*);
template<> ::metrics::CastLogsProto_CastDeviceMutableInfo* Arena::CreateMaybeMessage<::metrics::CastLogsProto_CastDeviceMutableInfo>(Arena*);
template<> ::metrics::CastLogsProto_CastEventProto* Arena::CreateMaybeMessage<::metrics::CastLogsProto_CastEventProto>(Arena*);
template<> ::metrics::CastLogsProto_CastEventProto_Metadata* Arena::CreateMaybeMessage<::metrics::CastLogsProto_CastEventProto_Metadata>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace metrics {

enum CastLogsProto_CastDeviceInfo_CastProductType : int {
  CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_UNKNOWN = 0,
  CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_CHROMECAST = 1,
  CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_TV = 2,
  CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_AUDIO = 3,
  CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_ANDROID_TV = 4,
  CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_ASSISTANT = 5,
  CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_ANDROID_THINGS = 6,
  CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_CHROME_OS = 7,
  CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_FUCHSIA_OS = 8,
  CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_LITE = 9,
  CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_CORE = 10,
  CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_11 = 11,
  CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_ANDROID_AUTOMOTIVE = 12
};
bool CastLogsProto_CastDeviceInfo_CastProductType_IsValid(int value);
constexpr CastLogsProto_CastDeviceInfo_CastProductType CastLogsProto_CastDeviceInfo_CastProductType_CastProductType_MIN = CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_UNKNOWN;
constexpr CastLogsProto_CastDeviceInfo_CastProductType CastLogsProto_CastDeviceInfo_CastProductType_CastProductType_MAX = CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_ANDROID_AUTOMOTIVE;
constexpr int CastLogsProto_CastDeviceInfo_CastProductType_CastProductType_ARRAYSIZE = CastLogsProto_CastDeviceInfo_CastProductType_CastProductType_MAX + 1;

const std::string& CastLogsProto_CastDeviceInfo_CastProductType_Name(CastLogsProto_CastDeviceInfo_CastProductType value);
template<typename T>
inline const std::string& CastLogsProto_CastDeviceInfo_CastProductType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CastLogsProto_CastDeviceInfo_CastProductType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CastLogsProto_CastDeviceInfo_CastProductType_Name.");
  return CastLogsProto_CastDeviceInfo_CastProductType_Name(static_cast<CastLogsProto_CastDeviceInfo_CastProductType>(enum_t_value));
}
bool CastLogsProto_CastDeviceInfo_CastProductType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CastLogsProto_CastDeviceInfo_CastProductType* value);
enum CastLogsProto_CastConnectionInfo_SenderInfo_SDKType : int {
  CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_SDK_UNKNOWN = 0,
  CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_SDK_NATIVE = 1,
  CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_SDK_CHROME_EXTENSION = 2
};
bool CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_IsValid(int value);
constexpr CastLogsProto_CastConnectionInfo_SenderInfo_SDKType CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_SDKType_MIN = CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_SDK_UNKNOWN;
constexpr CastLogsProto_CastConnectionInfo_SenderInfo_SDKType CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_SDKType_MAX = CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_SDK_CHROME_EXTENSION;
constexpr int CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_SDKType_ARRAYSIZE = CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_SDKType_MAX + 1;

const std::string& CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_Name(CastLogsProto_CastConnectionInfo_SenderInfo_SDKType value);
template<typename T>
inline const std::string& CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CastLogsProto_CastConnectionInfo_SenderInfo_SDKType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_Name.");
  return CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_Name(static_cast<CastLogsProto_CastConnectionInfo_SenderInfo_SDKType>(enum_t_value));
}
bool CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CastLogsProto_CastConnectionInfo_SenderInfo_SDKType* value);
enum CastLogsProto_CastConnectionInfo_SenderInfo_Platform : int {
  CastLogsProto_CastConnectionInfo_SenderInfo_Platform_PLATFORM_OTHER = 0,
  CastLogsProto_CastConnectionInfo_SenderInfo_Platform_PLATFORM_ANDROID = 1,
  CastLogsProto_CastConnectionInfo_SenderInfo_Platform_PLATFORM_IOS = 2,
  CastLogsProto_CastConnectionInfo_SenderInfo_Platform_PLATFORM_WINDOWS = 3,
  CastLogsProto_CastConnectionInfo_SenderInfo_Platform_PLATFORM_OSX = 4,
  CastLogsProto_CastConnectionInfo_SenderInfo_Platform_PLATFORM_CHROMEOS = 5,
  CastLogsProto_CastConnectionInfo_SenderInfo_Platform_PLATFORM_LINUX = 6,
  CastLogsProto_CastConnectionInfo_SenderInfo_Platform_PLATFORM_CAST = 7
};
bool CastLogsProto_CastConnectionInfo_SenderInfo_Platform_IsValid(int value);
constexpr CastLogsProto_CastConnectionInfo_SenderInfo_Platform CastLogsProto_CastConnectionInfo_SenderInfo_Platform_Platform_MIN = CastLogsProto_CastConnectionInfo_SenderInfo_Platform_PLATFORM_OTHER;
constexpr CastLogsProto_CastConnectionInfo_SenderInfo_Platform CastLogsProto_CastConnectionInfo_SenderInfo_Platform_Platform_MAX = CastLogsProto_CastConnectionInfo_SenderInfo_Platform_PLATFORM_CAST;
constexpr int CastLogsProto_CastConnectionInfo_SenderInfo_Platform_Platform_ARRAYSIZE = CastLogsProto_CastConnectionInfo_SenderInfo_Platform_Platform_MAX + 1;

const std::string& CastLogsProto_CastConnectionInfo_SenderInfo_Platform_Name(CastLogsProto_CastConnectionInfo_SenderInfo_Platform value);
template<typename T>
inline const std::string& CastLogsProto_CastConnectionInfo_SenderInfo_Platform_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CastLogsProto_CastConnectionInfo_SenderInfo_Platform>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CastLogsProto_CastConnectionInfo_SenderInfo_Platform_Name.");
  return CastLogsProto_CastConnectionInfo_SenderInfo_Platform_Name(static_cast<CastLogsProto_CastConnectionInfo_SenderInfo_Platform>(enum_t_value));
}
bool CastLogsProto_CastConnectionInfo_SenderInfo_Platform_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CastLogsProto_CastConnectionInfo_SenderInfo_Platform* value);
enum CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType : int {
  CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_CONNECTION_TYPE_UNKNOWN = 0,
  CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_CONNECTION_TYPE_LOCAL = 1,
  CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_CONNECTION_TYPE_RELAY = 2,
  CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_CONNECTION_TYPE_INTERNAL = 3
};
bool CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_IsValid(int value);
constexpr CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_ConnectionType_MIN = CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_CONNECTION_TYPE_UNKNOWN;
constexpr CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_ConnectionType_MAX = CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_CONNECTION_TYPE_INTERNAL;
constexpr int CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_ConnectionType_ARRAYSIZE = CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_ConnectionType_MAX + 1;

const std::string& CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_Name(CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType value);
template<typename T>
inline const std::string& CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_Name.");
  return CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_Name(static_cast<CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType>(enum_t_value));
}
bool CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType* value);
enum CastLogsProto_CastEventProto_LaunchFrom : int {
  CastLogsProto_CastEventProto_LaunchFrom_FROM_UNKNOWN = 0,
  CastLogsProto_CastEventProto_LaunchFrom_FROM_LOCAL = 1,
  CastLogsProto_CastEventProto_LaunchFrom_FROM_DIAL = 2,
  CastLogsProto_CastEventProto_LaunchFrom_FROM_CAST_V2 = 3,
  CastLogsProto_CastEventProto_LaunchFrom_FROM_CCS = 4
};
bool CastLogsProto_CastEventProto_LaunchFrom_IsValid(int value);
constexpr CastLogsProto_CastEventProto_LaunchFrom CastLogsProto_CastEventProto_LaunchFrom_LaunchFrom_MIN = CastLogsProto_CastEventProto_LaunchFrom_FROM_UNKNOWN;
constexpr CastLogsProto_CastEventProto_LaunchFrom CastLogsProto_CastEventProto_LaunchFrom_LaunchFrom_MAX = CastLogsProto_CastEventProto_LaunchFrom_FROM_CCS;
constexpr int CastLogsProto_CastEventProto_LaunchFrom_LaunchFrom_ARRAYSIZE = CastLogsProto_CastEventProto_LaunchFrom_LaunchFrom_MAX + 1;

const std::string& CastLogsProto_CastEventProto_LaunchFrom_Name(CastLogsProto_CastEventProto_LaunchFrom value);
template<typename T>
inline const std::string& CastLogsProto_CastEventProto_LaunchFrom_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CastLogsProto_CastEventProto_LaunchFrom>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CastLogsProto_CastEventProto_LaunchFrom_Name.");
  return CastLogsProto_CastEventProto_LaunchFrom_Name(static_cast<CastLogsProto_CastEventProto_LaunchFrom>(enum_t_value));
}
bool CastLogsProto_CastEventProto_LaunchFrom_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CastLogsProto_CastEventProto_LaunchFrom* value);
enum CastLogsProto_CastEventProto_RuntimeType : int {
  CastLogsProto_CastEventProto_RuntimeType_RUNTIME_TYPE_UNKNOWN = 0,
  CastLogsProto_CastEventProto_RuntimeType_RUNTIME_TYPE_CAST_WEB = 1,
  CastLogsProto_CastEventProto_RuntimeType_RUNTIME_TYPE_CAST_LITE = 2,
  CastLogsProto_CastEventProto_RuntimeType_RUNTIME_TYPE_NATIVE = 3
};
bool CastLogsProto_CastEventProto_RuntimeType_IsValid(int value);
constexpr CastLogsProto_CastEventProto_RuntimeType CastLogsProto_CastEventProto_RuntimeType_RuntimeType_MIN = CastLogsProto_CastEventProto_RuntimeType_RUNTIME_TYPE_UNKNOWN;
constexpr CastLogsProto_CastEventProto_RuntimeType CastLogsProto_CastEventProto_RuntimeType_RuntimeType_MAX = CastLogsProto_CastEventProto_RuntimeType_RUNTIME_TYPE_NATIVE;
constexpr int CastLogsProto_CastEventProto_RuntimeType_RuntimeType_ARRAYSIZE = CastLogsProto_CastEventProto_RuntimeType_RuntimeType_MAX + 1;

const std::string& CastLogsProto_CastEventProto_RuntimeType_Name(CastLogsProto_CastEventProto_RuntimeType value);
template<typename T>
inline const std::string& CastLogsProto_CastEventProto_RuntimeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CastLogsProto_CastEventProto_RuntimeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CastLogsProto_CastEventProto_RuntimeType_Name.");
  return CastLogsProto_CastEventProto_RuntimeType_Name(static_cast<CastLogsProto_CastEventProto_RuntimeType>(enum_t_value));
}
bool CastLogsProto_CastEventProto_RuntimeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CastLogsProto_CastEventProto_RuntimeType* value);
enum CastLogsProto_CastDeviceMutableInfo_RebootType : int {
  CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_UNKNOWN = 0,
  CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_FORCED = 1,
  CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_API = 2,
  CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_NIGHTLY = 3,
  CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_OTA = 4,
  CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_WATCHDOG = 5,
  CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_PROCESS_MANAGER = 6,
  CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_CRASH_UPLOADER = 7,
  CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_FDR = 8,
  CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_HW_WATCHDOG = 9,
  CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_SW_OTHER = 10,
  CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_OVERHEAT = 11,
  CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_REGENERATE_CLOUD_ID = 12,
  CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_REPEATED_OOM = 13,
  CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_UTILITY_PROCESS_CRASH = 14,
  CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_GRACEFUL_RESTART = 15,
  CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_UNGRACEFUL_RESTART = 16,
  CastLogsProto_CastDeviceMutableInfo_RebootType_MULTI_SERVICE_BUG = 17,
  CastLogsProto_CastDeviceMutableInfo_RebootType_POWER_MANAGER = 18,
  CastLogsProto_CastDeviceMutableInfo_RebootType_EXPERIMENT_CHANGE = 19,
  CastLogsProto_CastDeviceMutableInfo_RebootType_ANOMALY_DETECTION = 20,
  CastLogsProto_CastDeviceMutableInfo_RebootType_KERNEL_PANIC = 21
};
bool CastLogsProto_CastDeviceMutableInfo_RebootType_IsValid(int value);
constexpr CastLogsProto_CastDeviceMutableInfo_RebootType CastLogsProto_CastDeviceMutableInfo_RebootType_RebootType_MIN = CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_UNKNOWN;
constexpr CastLogsProto_CastDeviceMutableInfo_RebootType CastLogsProto_CastDeviceMutableInfo_RebootType_RebootType_MAX = CastLogsProto_CastDeviceMutableInfo_RebootType_KERNEL_PANIC;
constexpr int CastLogsProto_CastDeviceMutableInfo_RebootType_RebootType_ARRAYSIZE = CastLogsProto_CastDeviceMutableInfo_RebootType_RebootType_MAX + 1;

const std::string& CastLogsProto_CastDeviceMutableInfo_RebootType_Name(CastLogsProto_CastDeviceMutableInfo_RebootType value);
template<typename T>
inline const std::string& CastLogsProto_CastDeviceMutableInfo_RebootType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CastLogsProto_CastDeviceMutableInfo_RebootType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CastLogsProto_CastDeviceMutableInfo_RebootType_Name.");
  return CastLogsProto_CastDeviceMutableInfo_RebootType_Name(static_cast<CastLogsProto_CastDeviceMutableInfo_RebootType>(enum_t_value));
}
bool CastLogsProto_CastDeviceMutableInfo_RebootType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CastLogsProto_CastDeviceMutableInfo_RebootType* value);
enum CastLogsProto_CastDeviceMutableInfo_NetifIPVersion : int {
  CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_IP_UNKNOWN = 0,
  CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_IP_V4 = 1,
  CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_IP_V6 = 2,
  CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_IP_DUAL_STACK = 3
};
bool CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_IsValid(int value);
constexpr CastLogsProto_CastDeviceMutableInfo_NetifIPVersion CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_NetifIPVersion_MIN = CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_IP_UNKNOWN;
constexpr CastLogsProto_CastDeviceMutableInfo_NetifIPVersion CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_NetifIPVersion_MAX = CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_IP_DUAL_STACK;
constexpr int CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_NetifIPVersion_ARRAYSIZE = CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_NetifIPVersion_MAX + 1;

const std::string& CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_Name(CastLogsProto_CastDeviceMutableInfo_NetifIPVersion value);
template<typename T>
inline const std::string& CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CastLogsProto_CastDeviceMutableInfo_NetifIPVersion>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_Name.");
  return CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_Name(static_cast<CastLogsProto_CastDeviceMutableInfo_NetifIPVersion>(enum_t_value));
}
bool CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CastLogsProto_CastDeviceMutableInfo_NetifIPVersion* value);
// ===================================================================

class CastLogsProto_CastDeviceInfo_HardwareInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo) */ {
 public:
  inline CastLogsProto_CastDeviceInfo_HardwareInfo() : CastLogsProto_CastDeviceInfo_HardwareInfo(nullptr) {}
  ~CastLogsProto_CastDeviceInfo_HardwareInfo() override;
  explicit PROTOBUF_CONSTEXPR CastLogsProto_CastDeviceInfo_HardwareInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CastLogsProto_CastDeviceInfo_HardwareInfo(const CastLogsProto_CastDeviceInfo_HardwareInfo& from);
  CastLogsProto_CastDeviceInfo_HardwareInfo(CastLogsProto_CastDeviceInfo_HardwareInfo&& from) noexcept
    : CastLogsProto_CastDeviceInfo_HardwareInfo() {
    *this = ::std::move(from);
  }

  inline CastLogsProto_CastDeviceInfo_HardwareInfo& operator=(const CastLogsProto_CastDeviceInfo_HardwareInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CastLogsProto_CastDeviceInfo_HardwareInfo& operator=(CastLogsProto_CastDeviceInfo_HardwareInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CastLogsProto_CastDeviceInfo_HardwareInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CastLogsProto_CastDeviceInfo_HardwareInfo* internal_default_instance() {
    return reinterpret_cast<const CastLogsProto_CastDeviceInfo_HardwareInfo*>(
               &_CastLogsProto_CastDeviceInfo_HardwareInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CastLogsProto_CastDeviceInfo_HardwareInfo& a, CastLogsProto_CastDeviceInfo_HardwareInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CastLogsProto_CastDeviceInfo_HardwareInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CastLogsProto_CastDeviceInfo_HardwareInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CastLogsProto_CastDeviceInfo_HardwareInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CastLogsProto_CastDeviceInfo_HardwareInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CastLogsProto_CastDeviceInfo_HardwareInfo& from);
  void MergeFrom(const CastLogsProto_CastDeviceInfo_HardwareInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CastLogsProto_CastDeviceInfo_HardwareInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "metrics.CastLogsProto.CastDeviceInfo.HardwareInfo";
  }
  protected:
  explicit CastLogsProto_CastDeviceInfo_HardwareInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
    kMicFieldNumber = 2,
    kMemoryFieldNumber = 3,
    kNandFieldNumber = 4,
    kMfgDateFieldNumber = 5,
    kBuildNameFieldNumber = 6,
    kConfigFieldNumber = 7,
    kEmmcFieldNumber = 8,
    kDisplayFieldNumber = 9,
    kAmpFieldNumber = 10,
    kBoardNameFieldNumber = 11,
  };
  // optional string color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const std::string& color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* color);
  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(const std::string& value);
  std::string* _internal_mutable_color();
  public:

  // optional string mic = 2;
  bool has_mic() const;
  private:
  bool _internal_has_mic() const;
  public:
  void clear_mic();
  const std::string& mic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mic();
  PROTOBUF_NODISCARD std::string* release_mic();
  void set_allocated_mic(std::string* mic);
  private:
  const std::string& _internal_mic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mic(const std::string& value);
  std::string* _internal_mutable_mic();
  public:

  // optional string memory = 3;
  bool has_memory() const;
  private:
  bool _internal_has_memory() const;
  public:
  void clear_memory();
  const std::string& memory() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_memory(ArgT0&& arg0, ArgT... args);
  std::string* mutable_memory();
  PROTOBUF_NODISCARD std::string* release_memory();
  void set_allocated_memory(std::string* memory);
  private:
  const std::string& _internal_memory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memory(const std::string& value);
  std::string* _internal_mutable_memory();
  public:

  // optional string nand = 4;
  bool has_nand() const;
  private:
  bool _internal_has_nand() const;
  public:
  void clear_nand();
  const std::string& nand() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nand(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nand();
  PROTOBUF_NODISCARD std::string* release_nand();
  void set_allocated_nand(std::string* nand);
  private:
  const std::string& _internal_nand() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nand(const std::string& value);
  std::string* _internal_mutable_nand();
  public:

  // optional string mfg_date = 5;
  bool has_mfg_date() const;
  private:
  bool _internal_has_mfg_date() const;
  public:
  void clear_mfg_date();
  const std::string& mfg_date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mfg_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mfg_date();
  PROTOBUF_NODISCARD std::string* release_mfg_date();
  void set_allocated_mfg_date(std::string* mfg_date);
  private:
  const std::string& _internal_mfg_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mfg_date(const std::string& value);
  std::string* _internal_mutable_mfg_date();
  public:

  // optional string build_name = 6;
  bool has_build_name() const;
  private:
  bool _internal_has_build_name() const;
  public:
  void clear_build_name();
  const std::string& build_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_build_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_build_name();
  PROTOBUF_NODISCARD std::string* release_build_name();
  void set_allocated_build_name(std::string* build_name);
  private:
  const std::string& _internal_build_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_build_name(const std::string& value);
  std::string* _internal_mutable_build_name();
  public:

  // optional string config = 7;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const std::string& config() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_config(ArgT0&& arg0, ArgT... args);
  std::string* mutable_config();
  PROTOBUF_NODISCARD std::string* release_config();
  void set_allocated_config(std::string* config);
  private:
  const std::string& _internal_config() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config(const std::string& value);
  std::string* _internal_mutable_config();
  public:

  // optional string emmc = 8;
  bool has_emmc() const;
  private:
  bool _internal_has_emmc() const;
  public:
  void clear_emmc();
  const std::string& emmc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_emmc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_emmc();
  PROTOBUF_NODISCARD std::string* release_emmc();
  void set_allocated_emmc(std::string* emmc);
  private:
  const std::string& _internal_emmc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_emmc(const std::string& value);
  std::string* _internal_mutable_emmc();
  public:

  // optional string display = 9;
  bool has_display() const;
  private:
  bool _internal_has_display() const;
  public:
  void clear_display();
  const std::string& display() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display();
  PROTOBUF_NODISCARD std::string* release_display();
  void set_allocated_display(std::string* display);
  private:
  const std::string& _internal_display() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display(const std::string& value);
  std::string* _internal_mutable_display();
  public:

  // optional string amp = 10;
  bool has_amp() const;
  private:
  bool _internal_has_amp() const;
  public:
  void clear_amp();
  const std::string& amp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amp();
  PROTOBUF_NODISCARD std::string* release_amp();
  void set_allocated_amp(std::string* amp);
  private:
  const std::string& _internal_amp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amp(const std::string& value);
  std::string* _internal_mutable_amp();
  public:

  // optional string board_name = 11;
  bool has_board_name() const;
  private:
  bool _internal_has_board_name() const;
  public:
  void clear_board_name();
  const std::string& board_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_board_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_board_name();
  PROTOBUF_NODISCARD std::string* release_board_name();
  void set_allocated_board_name(std::string* board_name);
  private:
  const std::string& _internal_board_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_board_name(const std::string& value);
  std::string* _internal_mutable_board_name();
  public:

  // @@protoc_insertion_point(class_scope:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mic_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memory_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nand_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mfg_date_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr build_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr emmc_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amp_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr board_name_;
  friend struct ::TableStruct_cast_5flogs_2eproto;
};
// -------------------------------------------------------------------

class CastLogsProto_CastDeviceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:metrics.CastLogsProto.CastDeviceInfo) */ {
 public:
  inline CastLogsProto_CastDeviceInfo() : CastLogsProto_CastDeviceInfo(nullptr) {}
  ~CastLogsProto_CastDeviceInfo() override;
  explicit PROTOBUF_CONSTEXPR CastLogsProto_CastDeviceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CastLogsProto_CastDeviceInfo(const CastLogsProto_CastDeviceInfo& from);
  CastLogsProto_CastDeviceInfo(CastLogsProto_CastDeviceInfo&& from) noexcept
    : CastLogsProto_CastDeviceInfo() {
    *this = ::std::move(from);
  }

  inline CastLogsProto_CastDeviceInfo& operator=(const CastLogsProto_CastDeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CastLogsProto_CastDeviceInfo& operator=(CastLogsProto_CastDeviceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CastLogsProto_CastDeviceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CastLogsProto_CastDeviceInfo* internal_default_instance() {
    return reinterpret_cast<const CastLogsProto_CastDeviceInfo*>(
               &_CastLogsProto_CastDeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CastLogsProto_CastDeviceInfo& a, CastLogsProto_CastDeviceInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CastLogsProto_CastDeviceInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CastLogsProto_CastDeviceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CastLogsProto_CastDeviceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CastLogsProto_CastDeviceInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CastLogsProto_CastDeviceInfo& from);
  void MergeFrom(const CastLogsProto_CastDeviceInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CastLogsProto_CastDeviceInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "metrics.CastLogsProto.CastDeviceInfo";
  }
  protected:
  explicit CastLogsProto_CastDeviceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CastLogsProto_CastDeviceInfo_HardwareInfo HardwareInfo;

  typedef CastLogsProto_CastDeviceInfo_CastProductType CastProductType;
  static constexpr CastProductType CAST_PRODUCT_TYPE_UNKNOWN =
    CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_UNKNOWN;
  static constexpr CastProductType CAST_PRODUCT_TYPE_CHROMECAST =
    CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_CHROMECAST;
  static constexpr CastProductType CAST_PRODUCT_TYPE_TV =
    CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_TV;
  static constexpr CastProductType CAST_PRODUCT_TYPE_AUDIO =
    CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_AUDIO;
  static constexpr CastProductType CAST_PRODUCT_TYPE_ANDROID_TV =
    CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_ANDROID_TV;
  static constexpr CastProductType CAST_PRODUCT_TYPE_ASSISTANT =
    CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_ASSISTANT;
  static constexpr CastProductType CAST_PRODUCT_TYPE_ANDROID_THINGS =
    CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_ANDROID_THINGS;
  static constexpr CastProductType CAST_PRODUCT_TYPE_CHROME_OS =
    CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_CHROME_OS;
  static constexpr CastProductType CAST_PRODUCT_TYPE_FUCHSIA_OS =
    CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_FUCHSIA_OS;
  static constexpr CastProductType CAST_PRODUCT_TYPE_LITE =
    CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_LITE;
  static constexpr CastProductType CAST_PRODUCT_TYPE_CORE =
    CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_CORE;
  static constexpr CastProductType CAST_PRODUCT_TYPE_11 =
    CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_11;
  static constexpr CastProductType CAST_PRODUCT_TYPE_ANDROID_AUTOMOTIVE =
    CastLogsProto_CastDeviceInfo_CastProductType_CAST_PRODUCT_TYPE_ANDROID_AUTOMOTIVE;
  static inline bool CastProductType_IsValid(int value) {
    return CastLogsProto_CastDeviceInfo_CastProductType_IsValid(value);
  }
  static constexpr CastProductType CastProductType_MIN =
    CastLogsProto_CastDeviceInfo_CastProductType_CastProductType_MIN;
  static constexpr CastProductType CastProductType_MAX =
    CastLogsProto_CastDeviceInfo_CastProductType_CastProductType_MAX;
  static constexpr int CastProductType_ARRAYSIZE =
    CastLogsProto_CastDeviceInfo_CastProductType_CastProductType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& CastProductType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CastProductType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CastProductType_Name.");
    return CastLogsProto_CastDeviceInfo_CastProductType_Name(enum_t_value);
  }
  static inline bool CastProductType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CastProductType* value) {
    return CastLogsProto_CastDeviceInfo_CastProductType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHardwareRevisionFieldNumber = 2,
    kManufacturerFieldNumber = 3,
    kModelFieldNumber = 4,
    kSerialNumberFieldNumber = 5,
    kHardwareInfoFieldNumber = 6,
    kTypeFieldNumber = 1,
  };
  // optional string hardware_revision = 2;
  bool has_hardware_revision() const;
  private:
  bool _internal_has_hardware_revision() const;
  public:
  void clear_hardware_revision();
  const std::string& hardware_revision() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hardware_revision(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hardware_revision();
  PROTOBUF_NODISCARD std::string* release_hardware_revision();
  void set_allocated_hardware_revision(std::string* hardware_revision);
  private:
  const std::string& _internal_hardware_revision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hardware_revision(const std::string& value);
  std::string* _internal_mutable_hardware_revision();
  public:

  // optional string manufacturer = 3;
  bool has_manufacturer() const;
  private:
  bool _internal_has_manufacturer() const;
  public:
  void clear_manufacturer();
  const std::string& manufacturer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_manufacturer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_manufacturer();
  PROTOBUF_NODISCARD std::string* release_manufacturer();
  void set_allocated_manufacturer(std::string* manufacturer);
  private:
  const std::string& _internal_manufacturer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manufacturer(const std::string& value);
  std::string* _internal_mutable_manufacturer();
  public:

  // optional string model = 4;
  bool has_model() const;
  private:
  bool _internal_has_model() const;
  public:
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // optional string serial_number = 5;
  bool has_serial_number() const;
  private:
  bool _internal_has_serial_number() const;
  public:
  void clear_serial_number();
  const std::string& serial_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial_number();
  PROTOBUF_NODISCARD std::string* release_serial_number();
  void set_allocated_serial_number(std::string* serial_number);
  private:
  const std::string& _internal_serial_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial_number(const std::string& value);
  std::string* _internal_mutable_serial_number();
  public:

  // optional .metrics.CastLogsProto.CastDeviceInfo.HardwareInfo hardware_info = 6;
  bool has_hardware_info() const;
  private:
  bool _internal_has_hardware_info() const;
  public:
  void clear_hardware_info();
  const ::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo& hardware_info() const;
  PROTOBUF_NODISCARD ::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo* release_hardware_info();
  ::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo* mutable_hardware_info();
  void set_allocated_hardware_info(::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo* hardware_info);
  private:
  const ::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo& _internal_hardware_info() const;
  ::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo* _internal_mutable_hardware_info();
  public:
  void unsafe_arena_set_allocated_hardware_info(
      ::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo* hardware_info);
  ::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo* unsafe_arena_release_hardware_info();

  // optional .metrics.CastLogsProto.CastDeviceInfo.CastProductType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::metrics::CastLogsProto_CastDeviceInfo_CastProductType type() const;
  void set_type(::metrics::CastLogsProto_CastDeviceInfo_CastProductType value);
  private:
  ::metrics::CastLogsProto_CastDeviceInfo_CastProductType _internal_type() const;
  void _internal_set_type(::metrics::CastLogsProto_CastDeviceInfo_CastProductType value);
  public:

  // @@protoc_insertion_point(class_scope:metrics.CastLogsProto.CastDeviceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hardware_revision_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacturer_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_number_;
  ::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo* hardware_info_;
  int type_;
  friend struct ::TableStruct_cast_5flogs_2eproto;
};
// -------------------------------------------------------------------

class CastLogsProto_CastConnectionInfo_SenderInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:metrics.CastLogsProto.CastConnectionInfo.SenderInfo) */ {
 public:
  inline CastLogsProto_CastConnectionInfo_SenderInfo() : CastLogsProto_CastConnectionInfo_SenderInfo(nullptr) {}
  ~CastLogsProto_CastConnectionInfo_SenderInfo() override;
  explicit PROTOBUF_CONSTEXPR CastLogsProto_CastConnectionInfo_SenderInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CastLogsProto_CastConnectionInfo_SenderInfo(const CastLogsProto_CastConnectionInfo_SenderInfo& from);
  CastLogsProto_CastConnectionInfo_SenderInfo(CastLogsProto_CastConnectionInfo_SenderInfo&& from) noexcept
    : CastLogsProto_CastConnectionInfo_SenderInfo() {
    *this = ::std::move(from);
  }

  inline CastLogsProto_CastConnectionInfo_SenderInfo& operator=(const CastLogsProto_CastConnectionInfo_SenderInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CastLogsProto_CastConnectionInfo_SenderInfo& operator=(CastLogsProto_CastConnectionInfo_SenderInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CastLogsProto_CastConnectionInfo_SenderInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CastLogsProto_CastConnectionInfo_SenderInfo* internal_default_instance() {
    return reinterpret_cast<const CastLogsProto_CastConnectionInfo_SenderInfo*>(
               &_CastLogsProto_CastConnectionInfo_SenderInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CastLogsProto_CastConnectionInfo_SenderInfo& a, CastLogsProto_CastConnectionInfo_SenderInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CastLogsProto_CastConnectionInfo_SenderInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CastLogsProto_CastConnectionInfo_SenderInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CastLogsProto_CastConnectionInfo_SenderInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CastLogsProto_CastConnectionInfo_SenderInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CastLogsProto_CastConnectionInfo_SenderInfo& from);
  void MergeFrom(const CastLogsProto_CastConnectionInfo_SenderInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CastLogsProto_CastConnectionInfo_SenderInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "metrics.CastLogsProto.CastConnectionInfo.SenderInfo";
  }
  protected:
  explicit CastLogsProto_CastConnectionInfo_SenderInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CastLogsProto_CastConnectionInfo_SenderInfo_SDKType SDKType;
  static constexpr SDKType SDK_UNKNOWN =
    CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_SDK_UNKNOWN;
  static constexpr SDKType SDK_NATIVE =
    CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_SDK_NATIVE;
  static constexpr SDKType SDK_CHROME_EXTENSION =
    CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_SDK_CHROME_EXTENSION;
  static inline bool SDKType_IsValid(int value) {
    return CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_IsValid(value);
  }
  static constexpr SDKType SDKType_MIN =
    CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_SDKType_MIN;
  static constexpr SDKType SDKType_MAX =
    CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_SDKType_MAX;
  static constexpr int SDKType_ARRAYSIZE =
    CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_SDKType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SDKType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SDKType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SDKType_Name.");
    return CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_Name(enum_t_value);
  }
  static inline bool SDKType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SDKType* value) {
    return CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_Parse(name, value);
  }

  typedef CastLogsProto_CastConnectionInfo_SenderInfo_Platform Platform;
  static constexpr Platform PLATFORM_OTHER =
    CastLogsProto_CastConnectionInfo_SenderInfo_Platform_PLATFORM_OTHER;
  static constexpr Platform PLATFORM_ANDROID =
    CastLogsProto_CastConnectionInfo_SenderInfo_Platform_PLATFORM_ANDROID;
  static constexpr Platform PLATFORM_IOS =
    CastLogsProto_CastConnectionInfo_SenderInfo_Platform_PLATFORM_IOS;
  static constexpr Platform PLATFORM_WINDOWS =
    CastLogsProto_CastConnectionInfo_SenderInfo_Platform_PLATFORM_WINDOWS;
  static constexpr Platform PLATFORM_OSX =
    CastLogsProto_CastConnectionInfo_SenderInfo_Platform_PLATFORM_OSX;
  static constexpr Platform PLATFORM_CHROMEOS =
    CastLogsProto_CastConnectionInfo_SenderInfo_Platform_PLATFORM_CHROMEOS;
  static constexpr Platform PLATFORM_LINUX =
    CastLogsProto_CastConnectionInfo_SenderInfo_Platform_PLATFORM_LINUX;
  static constexpr Platform PLATFORM_CAST =
    CastLogsProto_CastConnectionInfo_SenderInfo_Platform_PLATFORM_CAST;
  static inline bool Platform_IsValid(int value) {
    return CastLogsProto_CastConnectionInfo_SenderInfo_Platform_IsValid(value);
  }
  static constexpr Platform Platform_MIN =
    CastLogsProto_CastConnectionInfo_SenderInfo_Platform_Platform_MIN;
  static constexpr Platform Platform_MAX =
    CastLogsProto_CastConnectionInfo_SenderInfo_Platform_Platform_MAX;
  static constexpr int Platform_ARRAYSIZE =
    CastLogsProto_CastConnectionInfo_SenderInfo_Platform_Platform_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Platform_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Platform>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Platform_Name.");
    return CastLogsProto_CastConnectionInfo_SenderInfo_Platform_Name(enum_t_value);
  }
  static inline bool Platform_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Platform* value) {
    return CastLogsProto_CastConnectionInfo_SenderInfo_Platform_Parse(name, value);
  }

  typedef CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType ConnectionType;
  static constexpr ConnectionType CONNECTION_TYPE_UNKNOWN =
    CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_CONNECTION_TYPE_UNKNOWN;
  static constexpr ConnectionType CONNECTION_TYPE_LOCAL =
    CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_CONNECTION_TYPE_LOCAL;
  static constexpr ConnectionType CONNECTION_TYPE_RELAY =
    CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_CONNECTION_TYPE_RELAY;
  static constexpr ConnectionType CONNECTION_TYPE_INTERNAL =
    CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_CONNECTION_TYPE_INTERNAL;
  static inline bool ConnectionType_IsValid(int value) {
    return CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_IsValid(value);
  }
  static constexpr ConnectionType ConnectionType_MIN =
    CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_ConnectionType_MIN;
  static constexpr ConnectionType ConnectionType_MAX =
    CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_ConnectionType_MAX;
  static constexpr int ConnectionType_ARRAYSIZE =
    CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_ConnectionType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ConnectionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ConnectionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ConnectionType_Name.");
    return CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_Name(enum_t_value);
  }
  static inline bool ConnectionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ConnectionType* value) {
    return CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 3,
    kChromeBrowserVersionFieldNumber = 4,
    kSystemVersionFieldNumber = 6,
    kModelFieldNumber = 8,
    kSenderDeviceIdFieldNumber = 1,
    kSdkTypeFieldNumber = 2,
    kPlatformFieldNumber = 5,
    kTransportConnectionTypeFieldNumber = 7,
    kSenderLocalIpFragmentFieldNumber = 9,
  };
  // optional string version = 3;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional string chrome_browser_version = 4;
  bool has_chrome_browser_version() const;
  private:
  bool _internal_has_chrome_browser_version() const;
  public:
  void clear_chrome_browser_version();
  const std::string& chrome_browser_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chrome_browser_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chrome_browser_version();
  PROTOBUF_NODISCARD std::string* release_chrome_browser_version();
  void set_allocated_chrome_browser_version(std::string* chrome_browser_version);
  private:
  const std::string& _internal_chrome_browser_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chrome_browser_version(const std::string& value);
  std::string* _internal_mutable_chrome_browser_version();
  public:

  // optional string system_version = 6;
  bool has_system_version() const;
  private:
  bool _internal_has_system_version() const;
  public:
  void clear_system_version();
  const std::string& system_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_system_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_system_version();
  PROTOBUF_NODISCARD std::string* release_system_version();
  void set_allocated_system_version(std::string* system_version);
  private:
  const std::string& _internal_system_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_system_version(const std::string& value);
  std::string* _internal_mutable_system_version();
  public:

  // optional string model = 8;
  bool has_model() const;
  private:
  bool _internal_has_model() const;
  public:
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // optional fixed64 sender_device_id = 1;
  bool has_sender_device_id() const;
  private:
  bool _internal_has_sender_device_id() const;
  public:
  void clear_sender_device_id();
  uint64_t sender_device_id() const;
  void set_sender_device_id(uint64_t value);
  private:
  uint64_t _internal_sender_device_id() const;
  void _internal_set_sender_device_id(uint64_t value);
  public:

  // optional .metrics.CastLogsProto.CastConnectionInfo.SenderInfo.SDKType sdk_type = 2;
  bool has_sdk_type() const;
  private:
  bool _internal_has_sdk_type() const;
  public:
  void clear_sdk_type();
  ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_SDKType sdk_type() const;
  void set_sdk_type(::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_SDKType value);
  private:
  ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_SDKType _internal_sdk_type() const;
  void _internal_set_sdk_type(::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_SDKType value);
  public:

  // optional .metrics.CastLogsProto.CastConnectionInfo.SenderInfo.Platform platform = 5;
  bool has_platform() const;
  private:
  bool _internal_has_platform() const;
  public:
  void clear_platform();
  ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_Platform platform() const;
  void set_platform(::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_Platform value);
  private:
  ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_Platform _internal_platform() const;
  void _internal_set_platform(::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_Platform value);
  public:

  // optional .metrics.CastLogsProto.CastConnectionInfo.SenderInfo.ConnectionType transport_connection_type = 7;
  bool has_transport_connection_type() const;
  private:
  bool _internal_has_transport_connection_type() const;
  public:
  void clear_transport_connection_type();
  ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType transport_connection_type() const;
  void set_transport_connection_type(::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType value);
  private:
  ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType _internal_transport_connection_type() const;
  void _internal_set_transport_connection_type(::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType value);
  public:

  // optional int32 sender_local_ip_fragment = 9;
  bool has_sender_local_ip_fragment() const;
  private:
  bool _internal_has_sender_local_ip_fragment() const;
  public:
  void clear_sender_local_ip_fragment();
  int32_t sender_local_ip_fragment() const;
  void set_sender_local_ip_fragment(int32_t value);
  private:
  int32_t _internal_sender_local_ip_fragment() const;
  void _internal_set_sender_local_ip_fragment(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:metrics.CastLogsProto.CastConnectionInfo.SenderInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chrome_browser_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr system_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  uint64_t sender_device_id_;
  int sdk_type_;
  int platform_;
  int transport_connection_type_;
  int32_t sender_local_ip_fragment_;
  friend struct ::TableStruct_cast_5flogs_2eproto;
};
// -------------------------------------------------------------------

class CastLogsProto_CastConnectionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:metrics.CastLogsProto.CastConnectionInfo) */ {
 public:
  inline CastLogsProto_CastConnectionInfo() : CastLogsProto_CastConnectionInfo(nullptr) {}
  ~CastLogsProto_CastConnectionInfo() override;
  explicit PROTOBUF_CONSTEXPR CastLogsProto_CastConnectionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CastLogsProto_CastConnectionInfo(const CastLogsProto_CastConnectionInfo& from);
  CastLogsProto_CastConnectionInfo(CastLogsProto_CastConnectionInfo&& from) noexcept
    : CastLogsProto_CastConnectionInfo() {
    *this = ::std::move(from);
  }

  inline CastLogsProto_CastConnectionInfo& operator=(const CastLogsProto_CastConnectionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CastLogsProto_CastConnectionInfo& operator=(CastLogsProto_CastConnectionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CastLogsProto_CastConnectionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CastLogsProto_CastConnectionInfo* internal_default_instance() {
    return reinterpret_cast<const CastLogsProto_CastConnectionInfo*>(
               &_CastLogsProto_CastConnectionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CastLogsProto_CastConnectionInfo& a, CastLogsProto_CastConnectionInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CastLogsProto_CastConnectionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CastLogsProto_CastConnectionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CastLogsProto_CastConnectionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CastLogsProto_CastConnectionInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CastLogsProto_CastConnectionInfo& from);
  void MergeFrom(const CastLogsProto_CastConnectionInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CastLogsProto_CastConnectionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "metrics.CastLogsProto.CastConnectionInfo";
  }
  protected:
  explicit CastLogsProto_CastConnectionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CastLogsProto_CastConnectionInfo_SenderInfo SenderInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kSenderInfoFieldNumber = 3,
    kTransportConnectionIdFieldNumber = 1,
    kVirtualConnectionIdFieldNumber = 2,
  };
  // optional .metrics.CastLogsProto.CastConnectionInfo.SenderInfo sender_info = 3;
  bool has_sender_info() const;
  private:
  bool _internal_has_sender_info() const;
  public:
  void clear_sender_info();
  const ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo& sender_info() const;
  PROTOBUF_NODISCARD ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo* release_sender_info();
  ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo* mutable_sender_info();
  void set_allocated_sender_info(::metrics::CastLogsProto_CastConnectionInfo_SenderInfo* sender_info);
  private:
  const ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo& _internal_sender_info() const;
  ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo* _internal_mutable_sender_info();
  public:
  void unsafe_arena_set_allocated_sender_info(
      ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo* sender_info);
  ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo* unsafe_arena_release_sender_info();

  // optional fixed32 transport_connection_id = 1;
  bool has_transport_connection_id() const;
  private:
  bool _internal_has_transport_connection_id() const;
  public:
  void clear_transport_connection_id();
  uint32_t transport_connection_id() const;
  void set_transport_connection_id(uint32_t value);
  private:
  uint32_t _internal_transport_connection_id() const;
  void _internal_set_transport_connection_id(uint32_t value);
  public:

  // optional fixed32 virtual_connection_id = 2;
  bool has_virtual_connection_id() const;
  private:
  bool _internal_has_virtual_connection_id() const;
  public:
  void clear_virtual_connection_id();
  uint32_t virtual_connection_id() const;
  void set_virtual_connection_id(uint32_t value);
  private:
  uint32_t _internal_virtual_connection_id() const;
  void _internal_set_virtual_connection_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:metrics.CastLogsProto.CastConnectionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo* sender_info_;
  uint32_t transport_connection_id_;
  uint32_t virtual_connection_id_;
  friend struct ::TableStruct_cast_5flogs_2eproto;
};
// -------------------------------------------------------------------

class CastLogsProto_CastEventProto_Metadata final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:metrics.CastLogsProto.CastEventProto.Metadata) */ {
 public:
  inline CastLogsProto_CastEventProto_Metadata() : CastLogsProto_CastEventProto_Metadata(nullptr) {}
  ~CastLogsProto_CastEventProto_Metadata() override;
  explicit PROTOBUF_CONSTEXPR CastLogsProto_CastEventProto_Metadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CastLogsProto_CastEventProto_Metadata(const CastLogsProto_CastEventProto_Metadata& from);
  CastLogsProto_CastEventProto_Metadata(CastLogsProto_CastEventProto_Metadata&& from) noexcept
    : CastLogsProto_CastEventProto_Metadata() {
    *this = ::std::move(from);
  }

  inline CastLogsProto_CastEventProto_Metadata& operator=(const CastLogsProto_CastEventProto_Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline CastLogsProto_CastEventProto_Metadata& operator=(CastLogsProto_CastEventProto_Metadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CastLogsProto_CastEventProto_Metadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const CastLogsProto_CastEventProto_Metadata* internal_default_instance() {
    return reinterpret_cast<const CastLogsProto_CastEventProto_Metadata*>(
               &_CastLogsProto_CastEventProto_Metadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CastLogsProto_CastEventProto_Metadata& a, CastLogsProto_CastEventProto_Metadata& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CastLogsProto_CastEventProto_Metadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CastLogsProto_CastEventProto_Metadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CastLogsProto_CastEventProto_Metadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CastLogsProto_CastEventProto_Metadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CastLogsProto_CastEventProto_Metadata& from);
  void MergeFrom(const CastLogsProto_CastEventProto_Metadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CastLogsProto_CastEventProto_Metadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "metrics.CastLogsProto.CastEventProto.Metadata";
  }
  protected:
  explicit CastLogsProto_CastEventProto_Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameHashFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // optional fixed64 name_hash = 1;
  bool has_name_hash() const;
  private:
  bool _internal_has_name_hash() const;
  public:
  void clear_name_hash();
  uint64_t name_hash() const;
  void set_name_hash(uint64_t value);
  private:
  uint64_t _internal_name_hash() const;
  void _internal_set_name_hash(uint64_t value);
  public:

  // optional int64 value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  int64_t value() const;
  void set_value(int64_t value);
  private:
  int64_t _internal_value() const;
  void _internal_set_value(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:metrics.CastLogsProto.CastEventProto.Metadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t name_hash_;
  int64_t value_;
  friend struct ::TableStruct_cast_5flogs_2eproto;
};
// -------------------------------------------------------------------

class CastLogsProto_CastEventProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:metrics.CastLogsProto.CastEventProto) */ {
 public:
  inline CastLogsProto_CastEventProto() : CastLogsProto_CastEventProto(nullptr) {}
  ~CastLogsProto_CastEventProto() override;
  explicit PROTOBUF_CONSTEXPR CastLogsProto_CastEventProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CastLogsProto_CastEventProto(const CastLogsProto_CastEventProto& from);
  CastLogsProto_CastEventProto(CastLogsProto_CastEventProto&& from) noexcept
    : CastLogsProto_CastEventProto() {
    *this = ::std::move(from);
  }

  inline CastLogsProto_CastEventProto& operator=(const CastLogsProto_CastEventProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CastLogsProto_CastEventProto& operator=(CastLogsProto_CastEventProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CastLogsProto_CastEventProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const CastLogsProto_CastEventProto* internal_default_instance() {
    return reinterpret_cast<const CastLogsProto_CastEventProto*>(
               &_CastLogsProto_CastEventProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CastLogsProto_CastEventProto& a, CastLogsProto_CastEventProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CastLogsProto_CastEventProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CastLogsProto_CastEventProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CastLogsProto_CastEventProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CastLogsProto_CastEventProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CastLogsProto_CastEventProto& from);
  void MergeFrom(const CastLogsProto_CastEventProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CastLogsProto_CastEventProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "metrics.CastLogsProto.CastEventProto";
  }
  protected:
  explicit CastLogsProto_CastEventProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CastLogsProto_CastEventProto_Metadata Metadata;

  typedef CastLogsProto_CastEventProto_LaunchFrom LaunchFrom;
  static constexpr LaunchFrom FROM_UNKNOWN =
    CastLogsProto_CastEventProto_LaunchFrom_FROM_UNKNOWN;
  static constexpr LaunchFrom FROM_LOCAL =
    CastLogsProto_CastEventProto_LaunchFrom_FROM_LOCAL;
  static constexpr LaunchFrom FROM_DIAL =
    CastLogsProto_CastEventProto_LaunchFrom_FROM_DIAL;
  static constexpr LaunchFrom FROM_CAST_V2 =
    CastLogsProto_CastEventProto_LaunchFrom_FROM_CAST_V2;
  static constexpr LaunchFrom FROM_CCS =
    CastLogsProto_CastEventProto_LaunchFrom_FROM_CCS;
  static inline bool LaunchFrom_IsValid(int value) {
    return CastLogsProto_CastEventProto_LaunchFrom_IsValid(value);
  }
  static constexpr LaunchFrom LaunchFrom_MIN =
    CastLogsProto_CastEventProto_LaunchFrom_LaunchFrom_MIN;
  static constexpr LaunchFrom LaunchFrom_MAX =
    CastLogsProto_CastEventProto_LaunchFrom_LaunchFrom_MAX;
  static constexpr int LaunchFrom_ARRAYSIZE =
    CastLogsProto_CastEventProto_LaunchFrom_LaunchFrom_ARRAYSIZE;
  template<typename T>
  static inline const std::string& LaunchFrom_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LaunchFrom>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LaunchFrom_Name.");
    return CastLogsProto_CastEventProto_LaunchFrom_Name(enum_t_value);
  }
  static inline bool LaunchFrom_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LaunchFrom* value) {
    return CastLogsProto_CastEventProto_LaunchFrom_Parse(name, value);
  }

  typedef CastLogsProto_CastEventProto_RuntimeType RuntimeType;
  static constexpr RuntimeType RUNTIME_TYPE_UNKNOWN =
    CastLogsProto_CastEventProto_RuntimeType_RUNTIME_TYPE_UNKNOWN;
  static constexpr RuntimeType RUNTIME_TYPE_CAST_WEB =
    CastLogsProto_CastEventProto_RuntimeType_RUNTIME_TYPE_CAST_WEB;
  static constexpr RuntimeType RUNTIME_TYPE_CAST_LITE =
    CastLogsProto_CastEventProto_RuntimeType_RUNTIME_TYPE_CAST_LITE;
  static constexpr RuntimeType RUNTIME_TYPE_NATIVE =
    CastLogsProto_CastEventProto_RuntimeType_RUNTIME_TYPE_NATIVE;
  static inline bool RuntimeType_IsValid(int value) {
    return CastLogsProto_CastEventProto_RuntimeType_IsValid(value);
  }
  static constexpr RuntimeType RuntimeType_MIN =
    CastLogsProto_CastEventProto_RuntimeType_RuntimeType_MIN;
  static constexpr RuntimeType RuntimeType_MAX =
    CastLogsProto_CastEventProto_RuntimeType_RuntimeType_MAX;
  static constexpr int RuntimeType_ARRAYSIZE =
    CastLogsProto_CastEventProto_RuntimeType_RuntimeType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& RuntimeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RuntimeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RuntimeType_Name.");
    return CastLogsProto_CastEventProto_RuntimeType_Name(enum_t_value);
  }
  static inline bool RuntimeType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RuntimeType* value) {
    return CastLogsProto_CastEventProto_RuntimeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 14,
    kFeatureVectorFieldNumber = 15,
    kEventIdListFieldNumber = 23,
    kConversationKeyFieldNumber = 11,
    kEventIdFieldNumber = 13,
    kAoghRequestIdFieldNumber = 16,
    kTimezoneIdFieldNumber = 17,
    kUiVersionFieldNumber = 20,
    kAoghAgentIdFieldNumber = 21,
    kSelinuxAuditDetailFieldNumber = 22,
    kHotwordModelIdFieldNumber = 25,
    kAoghStandardAgentIdFieldNumber = 28,
    kNameHashFieldNumber = 1,
    kTimeMsecFieldNumber = 2,
    kApplicationSessionIdFieldNumber = 4,
    kAppIdFieldNumber = 3,
    kTransportConnectionIdFieldNumber = 6,
    kCastReceiverVersionFieldNumber = 5,
    kValueFieldNumber = 8,
    kCastMplVersionFieldNumber = 9,
    kVirtualConnectionIdFieldNumber = 7,
    kRequestIdFieldNumber = 12,
    kGroupUuidFieldNumber = 10,
    kAoghLocalDeviceIdFieldNumber = 18,
    kRemoteAppIdFieldNumber = 19,
    kLaunchFromFieldNumber = 26,
    kDuoCoreVersionFieldNumber = 24,
    kRuntimeTypeFieldNumber = 27,
  };
  // repeated .metrics.CastLogsProto.CastEventProto.Metadata metadata = 14;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  ::metrics::CastLogsProto_CastEventProto_Metadata* mutable_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metrics::CastLogsProto_CastEventProto_Metadata >*
      mutable_metadata();
  private:
  const ::metrics::CastLogsProto_CastEventProto_Metadata& _internal_metadata(int index) const;
  ::metrics::CastLogsProto_CastEventProto_Metadata* _internal_add_metadata();
  public:
  const ::metrics::CastLogsProto_CastEventProto_Metadata& metadata(int index) const;
  ::metrics::CastLogsProto_CastEventProto_Metadata* add_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metrics::CastLogsProto_CastEventProto_Metadata >&
      metadata() const;

  // repeated float feature_vector = 15;
  int feature_vector_size() const;
  private:
  int _internal_feature_vector_size() const;
  public:
  void clear_feature_vector();
  private:
  float _internal_feature_vector(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_feature_vector() const;
  void _internal_add_feature_vector(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_feature_vector();
  public:
  float feature_vector(int index) const;
  void set_feature_vector(int index, float value);
  void add_feature_vector(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      feature_vector() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_feature_vector();

  // repeated string event_id_list = 23;
  int event_id_list_size() const;
  private:
  int _internal_event_id_list_size() const;
  public:
  void clear_event_id_list();
  const std::string& event_id_list(int index) const;
  std::string* mutable_event_id_list(int index);
  void set_event_id_list(int index, const std::string& value);
  void set_event_id_list(int index, std::string&& value);
  void set_event_id_list(int index, const char* value);
  void set_event_id_list(int index, const char* value, size_t size);
  std::string* add_event_id_list();
  void add_event_id_list(const std::string& value);
  void add_event_id_list(std::string&& value);
  void add_event_id_list(const char* value);
  void add_event_id_list(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& event_id_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_event_id_list();
  private:
  const std::string& _internal_event_id_list(int index) const;
  std::string* _internal_add_event_id_list();
  public:

  // optional string conversation_key = 11;
  bool has_conversation_key() const;
  private:
  bool _internal_has_conversation_key() const;
  public:
  void clear_conversation_key();
  const std::string& conversation_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversation_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversation_key();
  PROTOBUF_NODISCARD std::string* release_conversation_key();
  void set_allocated_conversation_key(std::string* conversation_key);
  private:
  const std::string& _internal_conversation_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversation_key(const std::string& value);
  std::string* _internal_mutable_conversation_key();
  public:

  // optional string event_id = 13;
  bool has_event_id() const;
  private:
  bool _internal_has_event_id() const;
  public:
  void clear_event_id();
  const std::string& event_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_id();
  PROTOBUF_NODISCARD std::string* release_event_id();
  void set_allocated_event_id(std::string* event_id);
  private:
  const std::string& _internal_event_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_id(const std::string& value);
  std::string* _internal_mutable_event_id();
  public:

  // optional string aogh_request_id = 16;
  bool has_aogh_request_id() const;
  private:
  bool _internal_has_aogh_request_id() const;
  public:
  void clear_aogh_request_id();
  const std::string& aogh_request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_aogh_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_aogh_request_id();
  PROTOBUF_NODISCARD std::string* release_aogh_request_id();
  void set_allocated_aogh_request_id(std::string* aogh_request_id);
  private:
  const std::string& _internal_aogh_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_aogh_request_id(const std::string& value);
  std::string* _internal_mutable_aogh_request_id();
  public:

  // optional string timezone_id = 17;
  bool has_timezone_id() const;
  private:
  bool _internal_has_timezone_id() const;
  public:
  void clear_timezone_id();
  const std::string& timezone_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_timezone_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_timezone_id();
  PROTOBUF_NODISCARD std::string* release_timezone_id();
  void set_allocated_timezone_id(std::string* timezone_id);
  private:
  const std::string& _internal_timezone_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timezone_id(const std::string& value);
  std::string* _internal_mutable_timezone_id();
  public:

  // optional string ui_version = 20;
  bool has_ui_version() const;
  private:
  bool _internal_has_ui_version() const;
  public:
  void clear_ui_version();
  const std::string& ui_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ui_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ui_version();
  PROTOBUF_NODISCARD std::string* release_ui_version();
  void set_allocated_ui_version(std::string* ui_version);
  private:
  const std::string& _internal_ui_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ui_version(const std::string& value);
  std::string* _internal_mutable_ui_version();
  public:

  // optional string aogh_agent_id = 21;
  bool has_aogh_agent_id() const;
  private:
  bool _internal_has_aogh_agent_id() const;
  public:
  void clear_aogh_agent_id();
  const std::string& aogh_agent_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_aogh_agent_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_aogh_agent_id();
  PROTOBUF_NODISCARD std::string* release_aogh_agent_id();
  void set_allocated_aogh_agent_id(std::string* aogh_agent_id);
  private:
  const std::string& _internal_aogh_agent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_aogh_agent_id(const std::string& value);
  std::string* _internal_mutable_aogh_agent_id();
  public:

  // optional string selinux_audit_detail = 22;
  bool has_selinux_audit_detail() const;
  private:
  bool _internal_has_selinux_audit_detail() const;
  public:
  void clear_selinux_audit_detail();
  const std::string& selinux_audit_detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_selinux_audit_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_selinux_audit_detail();
  PROTOBUF_NODISCARD std::string* release_selinux_audit_detail();
  void set_allocated_selinux_audit_detail(std::string* selinux_audit_detail);
  private:
  const std::string& _internal_selinux_audit_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_selinux_audit_detail(const std::string& value);
  std::string* _internal_mutable_selinux_audit_detail();
  public:

  // optional string hotword_model_id = 25;
  bool has_hotword_model_id() const;
  private:
  bool _internal_has_hotword_model_id() const;
  public:
  void clear_hotword_model_id();
  const std::string& hotword_model_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hotword_model_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hotword_model_id();
  PROTOBUF_NODISCARD std::string* release_hotword_model_id();
  void set_allocated_hotword_model_id(std::string* hotword_model_id);
  private:
  const std::string& _internal_hotword_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hotword_model_id(const std::string& value);
  std::string* _internal_mutable_hotword_model_id();
  public:

  // optional string aogh_standard_agent_id = 28;
  bool has_aogh_standard_agent_id() const;
  private:
  bool _internal_has_aogh_standard_agent_id() const;
  public:
  void clear_aogh_standard_agent_id();
  const std::string& aogh_standard_agent_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_aogh_standard_agent_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_aogh_standard_agent_id();
  PROTOBUF_NODISCARD std::string* release_aogh_standard_agent_id();
  void set_allocated_aogh_standard_agent_id(std::string* aogh_standard_agent_id);
  private:
  const std::string& _internal_aogh_standard_agent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_aogh_standard_agent_id(const std::string& value);
  std::string* _internal_mutable_aogh_standard_agent_id();
  public:

  // optional fixed64 name_hash = 1;
  bool has_name_hash() const;
  private:
  bool _internal_has_name_hash() const;
  public:
  void clear_name_hash();
  uint64_t name_hash() const;
  void set_name_hash(uint64_t value);
  private:
  uint64_t _internal_name_hash() const;
  void _internal_set_name_hash(uint64_t value);
  public:

  // optional int64 time_msec = 2;
  bool has_time_msec() const;
  private:
  bool _internal_has_time_msec() const;
  public:
  void clear_time_msec();
  int64_t time_msec() const;
  void set_time_msec(int64_t value);
  private:
  int64_t _internal_time_msec() const;
  void _internal_set_time_msec(int64_t value);
  public:

  // optional fixed64 application_session_id = 4;
  bool has_application_session_id() const;
  private:
  bool _internal_has_application_session_id() const;
  public:
  void clear_application_session_id();
  uint64_t application_session_id() const;
  void set_application_session_id(uint64_t value);
  private:
  uint64_t _internal_application_session_id() const;
  void _internal_set_application_session_id(uint64_t value);
  public:

  // optional fixed32 app_id = 3;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // optional fixed32 transport_connection_id = 6;
  bool has_transport_connection_id() const;
  private:
  bool _internal_has_transport_connection_id() const;
  public:
  void clear_transport_connection_id();
  uint32_t transport_connection_id() const;
  void set_transport_connection_id(uint32_t value);
  private:
  uint32_t _internal_transport_connection_id() const;
  void _internal_set_transport_connection_id(uint32_t value);
  public:

  // optional fixed64 cast_receiver_version = 5;
  bool has_cast_receiver_version() const;
  private:
  bool _internal_has_cast_receiver_version() const;
  public:
  void clear_cast_receiver_version();
  uint64_t cast_receiver_version() const;
  void set_cast_receiver_version(uint64_t value);
  private:
  uint64_t _internal_cast_receiver_version() const;
  void _internal_set_cast_receiver_version(uint64_t value);
  public:

  // optional int64 value = 8;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  int64_t value() const;
  void set_value(int64_t value);
  private:
  int64_t _internal_value() const;
  void _internal_set_value(int64_t value);
  public:

  // optional fixed64 cast_mpl_version = 9;
  bool has_cast_mpl_version() const;
  private:
  bool _internal_has_cast_mpl_version() const;
  public:
  void clear_cast_mpl_version();
  uint64_t cast_mpl_version() const;
  void set_cast_mpl_version(uint64_t value);
  private:
  uint64_t _internal_cast_mpl_version() const;
  void _internal_set_cast_mpl_version(uint64_t value);
  public:

  // optional fixed32 virtual_connection_id = 7;
  bool has_virtual_connection_id() const;
  private:
  bool _internal_has_virtual_connection_id() const;
  public:
  void clear_virtual_connection_id();
  uint32_t virtual_connection_id() const;
  void set_virtual_connection_id(uint32_t value);
  private:
  uint32_t _internal_virtual_connection_id() const;
  void _internal_set_virtual_connection_id(uint32_t value);
  public:

  // optional fixed32 request_id = 12;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  uint32_t request_id() const;
  void set_request_id(uint32_t value);
  private:
  uint32_t _internal_request_id() const;
  void _internal_set_request_id(uint32_t value);
  public:

  // optional fixed64 group_uuid = 10;
  bool has_group_uuid() const;
  private:
  bool _internal_has_group_uuid() const;
  public:
  void clear_group_uuid();
  uint64_t group_uuid() const;
  void set_group_uuid(uint64_t value);
  private:
  uint64_t _internal_group_uuid() const;
  void _internal_set_group_uuid(uint64_t value);
  public:

  // optional int64 aogh_local_device_id = 18;
  bool has_aogh_local_device_id() const;
  private:
  bool _internal_has_aogh_local_device_id() const;
  public:
  void clear_aogh_local_device_id();
  int64_t aogh_local_device_id() const;
  void set_aogh_local_device_id(int64_t value);
  private:
  int64_t _internal_aogh_local_device_id() const;
  void _internal_set_aogh_local_device_id(int64_t value);
  public:

  // optional fixed32 remote_app_id = 19;
  bool has_remote_app_id() const;
  private:
  bool _internal_has_remote_app_id() const;
  public:
  void clear_remote_app_id();
  uint32_t remote_app_id() const;
  void set_remote_app_id(uint32_t value);
  private:
  uint32_t _internal_remote_app_id() const;
  void _internal_set_remote_app_id(uint32_t value);
  public:

  // optional .metrics.CastLogsProto.CastEventProto.LaunchFrom launch_from = 26;
  bool has_launch_from() const;
  private:
  bool _internal_has_launch_from() const;
  public:
  void clear_launch_from();
  ::metrics::CastLogsProto_CastEventProto_LaunchFrom launch_from() const;
  void set_launch_from(::metrics::CastLogsProto_CastEventProto_LaunchFrom value);
  private:
  ::metrics::CastLogsProto_CastEventProto_LaunchFrom _internal_launch_from() const;
  void _internal_set_launch_from(::metrics::CastLogsProto_CastEventProto_LaunchFrom value);
  public:

  // optional fixed64 duo_core_version = 24;
  bool has_duo_core_version() const;
  private:
  bool _internal_has_duo_core_version() const;
  public:
  void clear_duo_core_version();
  uint64_t duo_core_version() const;
  void set_duo_core_version(uint64_t value);
  private:
  uint64_t _internal_duo_core_version() const;
  void _internal_set_duo_core_version(uint64_t value);
  public:

  // optional .metrics.CastLogsProto.CastEventProto.RuntimeType runtime_type = 27;
  bool has_runtime_type() const;
  private:
  bool _internal_has_runtime_type() const;
  public:
  void clear_runtime_type();
  ::metrics::CastLogsProto_CastEventProto_RuntimeType runtime_type() const;
  void set_runtime_type(::metrics::CastLogsProto_CastEventProto_RuntimeType value);
  private:
  ::metrics::CastLogsProto_CastEventProto_RuntimeType _internal_runtime_type() const;
  void _internal_set_runtime_type(::metrics::CastLogsProto_CastEventProto_RuntimeType value);
  public:

  // @@protoc_insertion_point(class_scope:metrics.CastLogsProto.CastEventProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metrics::CastLogsProto_CastEventProto_Metadata > metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > feature_vector_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> event_id_list_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversation_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr aogh_request_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timezone_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ui_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr aogh_agent_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr selinux_audit_detail_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hotword_model_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr aogh_standard_agent_id_;
  uint64_t name_hash_;
  int64_t time_msec_;
  uint64_t application_session_id_;
  uint32_t app_id_;
  uint32_t transport_connection_id_;
  uint64_t cast_receiver_version_;
  int64_t value_;
  uint64_t cast_mpl_version_;
  uint32_t virtual_connection_id_;
  uint32_t request_id_;
  uint64_t group_uuid_;
  int64_t aogh_local_device_id_;
  uint32_t remote_app_id_;
  int launch_from_;
  uint64_t duo_core_version_;
  int runtime_type_;
  friend struct ::TableStruct_cast_5flogs_2eproto;
};
// -------------------------------------------------------------------

class CastLogsProto_CastDeviceMutableInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:metrics.CastLogsProto.CastDeviceMutableInfo) */ {
 public:
  inline CastLogsProto_CastDeviceMutableInfo() : CastLogsProto_CastDeviceMutableInfo(nullptr) {}
  ~CastLogsProto_CastDeviceMutableInfo() override;
  explicit PROTOBUF_CONSTEXPR CastLogsProto_CastDeviceMutableInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CastLogsProto_CastDeviceMutableInfo(const CastLogsProto_CastDeviceMutableInfo& from);
  CastLogsProto_CastDeviceMutableInfo(CastLogsProto_CastDeviceMutableInfo&& from) noexcept
    : CastLogsProto_CastDeviceMutableInfo() {
    *this = ::std::move(from);
  }

  inline CastLogsProto_CastDeviceMutableInfo& operator=(const CastLogsProto_CastDeviceMutableInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CastLogsProto_CastDeviceMutableInfo& operator=(CastLogsProto_CastDeviceMutableInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CastLogsProto_CastDeviceMutableInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CastLogsProto_CastDeviceMutableInfo* internal_default_instance() {
    return reinterpret_cast<const CastLogsProto_CastDeviceMutableInfo*>(
               &_CastLogsProto_CastDeviceMutableInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CastLogsProto_CastDeviceMutableInfo& a, CastLogsProto_CastDeviceMutableInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CastLogsProto_CastDeviceMutableInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CastLogsProto_CastDeviceMutableInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CastLogsProto_CastDeviceMutableInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CastLogsProto_CastDeviceMutableInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CastLogsProto_CastDeviceMutableInfo& from);
  void MergeFrom(const CastLogsProto_CastDeviceMutableInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CastLogsProto_CastDeviceMutableInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "metrics.CastLogsProto.CastDeviceMutableInfo";
  }
  protected:
  explicit CastLogsProto_CastDeviceMutableInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CastLogsProto_CastDeviceMutableInfo_RebootType RebootType;
  static constexpr RebootType REBOOT_TYPE_UNKNOWN =
    CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_UNKNOWN;
  static constexpr RebootType REBOOT_TYPE_FORCED =
    CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_FORCED;
  static constexpr RebootType REBOOT_TYPE_API =
    CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_API;
  static constexpr RebootType REBOOT_TYPE_NIGHTLY =
    CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_NIGHTLY;
  static constexpr RebootType REBOOT_TYPE_OTA =
    CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_OTA;
  static constexpr RebootType REBOOT_TYPE_WATCHDOG =
    CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_WATCHDOG;
  static constexpr RebootType REBOOT_TYPE_PROCESS_MANAGER =
    CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_PROCESS_MANAGER;
  static constexpr RebootType REBOOT_TYPE_CRASH_UPLOADER =
    CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_CRASH_UPLOADER;
  static constexpr RebootType REBOOT_TYPE_FDR =
    CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_FDR;
  static constexpr RebootType REBOOT_TYPE_HW_WATCHDOG =
    CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_HW_WATCHDOG;
  static constexpr RebootType REBOOT_TYPE_SW_OTHER =
    CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_SW_OTHER;
  static constexpr RebootType REBOOT_TYPE_OVERHEAT =
    CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_OVERHEAT;
  static constexpr RebootType REBOOT_TYPE_REGENERATE_CLOUD_ID =
    CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_REGENERATE_CLOUD_ID;
  static constexpr RebootType REBOOT_TYPE_REPEATED_OOM =
    CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_REPEATED_OOM;
  static constexpr RebootType REBOOT_TYPE_UTILITY_PROCESS_CRASH =
    CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_UTILITY_PROCESS_CRASH;
  static constexpr RebootType REBOOT_TYPE_GRACEFUL_RESTART =
    CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_GRACEFUL_RESTART;
  static constexpr RebootType REBOOT_TYPE_UNGRACEFUL_RESTART =
    CastLogsProto_CastDeviceMutableInfo_RebootType_REBOOT_TYPE_UNGRACEFUL_RESTART;
  static constexpr RebootType MULTI_SERVICE_BUG =
    CastLogsProto_CastDeviceMutableInfo_RebootType_MULTI_SERVICE_BUG;
  static constexpr RebootType POWER_MANAGER =
    CastLogsProto_CastDeviceMutableInfo_RebootType_POWER_MANAGER;
  static constexpr RebootType EXPERIMENT_CHANGE =
    CastLogsProto_CastDeviceMutableInfo_RebootType_EXPERIMENT_CHANGE;
  static constexpr RebootType ANOMALY_DETECTION =
    CastLogsProto_CastDeviceMutableInfo_RebootType_ANOMALY_DETECTION;
  static constexpr RebootType KERNEL_PANIC =
    CastLogsProto_CastDeviceMutableInfo_RebootType_KERNEL_PANIC;
  static inline bool RebootType_IsValid(int value) {
    return CastLogsProto_CastDeviceMutableInfo_RebootType_IsValid(value);
  }
  static constexpr RebootType RebootType_MIN =
    CastLogsProto_CastDeviceMutableInfo_RebootType_RebootType_MIN;
  static constexpr RebootType RebootType_MAX =
    CastLogsProto_CastDeviceMutableInfo_RebootType_RebootType_MAX;
  static constexpr int RebootType_ARRAYSIZE =
    CastLogsProto_CastDeviceMutableInfo_RebootType_RebootType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& RebootType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RebootType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RebootType_Name.");
    return CastLogsProto_CastDeviceMutableInfo_RebootType_Name(enum_t_value);
  }
  static inline bool RebootType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RebootType* value) {
    return CastLogsProto_CastDeviceMutableInfo_RebootType_Parse(name, value);
  }

  typedef CastLogsProto_CastDeviceMutableInfo_NetifIPVersion NetifIPVersion;
  static constexpr NetifIPVersion IP_UNKNOWN =
    CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_IP_UNKNOWN;
  static constexpr NetifIPVersion IP_V4 =
    CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_IP_V4;
  static constexpr NetifIPVersion IP_V6 =
    CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_IP_V6;
  static constexpr NetifIPVersion IP_DUAL_STACK =
    CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_IP_DUAL_STACK;
  static inline bool NetifIPVersion_IsValid(int value) {
    return CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_IsValid(value);
  }
  static constexpr NetifIPVersion NetifIPVersion_MIN =
    CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_NetifIPVersion_MIN;
  static constexpr NetifIPVersion NetifIPVersion_MAX =
    CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_NetifIPVersion_MAX;
  static constexpr int NetifIPVersion_ARRAYSIZE =
    CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_NetifIPVersion_ARRAYSIZE;
  template<typename T>
  static inline const std::string& NetifIPVersion_Name(T enum_t_value) {
    static_assert(::std::is_same<T, NetifIPVersion>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function NetifIPVersion_Name.");
    return CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_Name(enum_t_value);
  }
  static inline bool NetifIPVersion_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      NetifIPVersion* value) {
    return CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBackdropAppDeviceIdFieldNumber = 3,
    kTimezoneIdFieldNumber = 7,
    kLatestUiVersionFieldNumber = 8,
    kGoogleWifiStationShmacFieldNumber = 9,
    kInstalledManifestPlatformVersionFieldNumber = 10,
    kSystemBundleVersionFieldNumber = 12,
    kSystemBuildNumberFieldNumber = 2,
    kLastRebootTypeFieldNumber = 1,
    kReleaseVersionFieldNumber = 4,
    kNetifIpVersionFieldNumber = 5,
    kIpDualStackSupportedFieldNumber = 6,
    kInstalledManifestVersionFieldNumber = 11,
  };
  // optional string backdrop_app_device_id = 3;
  bool has_backdrop_app_device_id() const;
  private:
  bool _internal_has_backdrop_app_device_id() const;
  public:
  void clear_backdrop_app_device_id();
  const std::string& backdrop_app_device_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backdrop_app_device_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backdrop_app_device_id();
  PROTOBUF_NODISCARD std::string* release_backdrop_app_device_id();
  void set_allocated_backdrop_app_device_id(std::string* backdrop_app_device_id);
  private:
  const std::string& _internal_backdrop_app_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backdrop_app_device_id(const std::string& value);
  std::string* _internal_mutable_backdrop_app_device_id();
  public:

  // optional string timezone_id = 7;
  bool has_timezone_id() const;
  private:
  bool _internal_has_timezone_id() const;
  public:
  void clear_timezone_id();
  const std::string& timezone_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_timezone_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_timezone_id();
  PROTOBUF_NODISCARD std::string* release_timezone_id();
  void set_allocated_timezone_id(std::string* timezone_id);
  private:
  const std::string& _internal_timezone_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timezone_id(const std::string& value);
  std::string* _internal_mutable_timezone_id();
  public:

  // optional string latest_ui_version = 8;
  bool has_latest_ui_version() const;
  private:
  bool _internal_has_latest_ui_version() const;
  public:
  void clear_latest_ui_version();
  const std::string& latest_ui_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_latest_ui_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_latest_ui_version();
  PROTOBUF_NODISCARD std::string* release_latest_ui_version();
  void set_allocated_latest_ui_version(std::string* latest_ui_version);
  private:
  const std::string& _internal_latest_ui_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_latest_ui_version(const std::string& value);
  std::string* _internal_mutable_latest_ui_version();
  public:

  // optional string google_wifi_station_shmac = 9;
  bool has_google_wifi_station_shmac() const;
  private:
  bool _internal_has_google_wifi_station_shmac() const;
  public:
  void clear_google_wifi_station_shmac();
  const std::string& google_wifi_station_shmac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_google_wifi_station_shmac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_google_wifi_station_shmac();
  PROTOBUF_NODISCARD std::string* release_google_wifi_station_shmac();
  void set_allocated_google_wifi_station_shmac(std::string* google_wifi_station_shmac);
  private:
  const std::string& _internal_google_wifi_station_shmac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_google_wifi_station_shmac(const std::string& value);
  std::string* _internal_mutable_google_wifi_station_shmac();
  public:

  // optional string installed_manifest_platform_version = 10;
  bool has_installed_manifest_platform_version() const;
  private:
  bool _internal_has_installed_manifest_platform_version() const;
  public:
  void clear_installed_manifest_platform_version();
  const std::string& installed_manifest_platform_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_installed_manifest_platform_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_installed_manifest_platform_version();
  PROTOBUF_NODISCARD std::string* release_installed_manifest_platform_version();
  void set_allocated_installed_manifest_platform_version(std::string* installed_manifest_platform_version);
  private:
  const std::string& _internal_installed_manifest_platform_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_installed_manifest_platform_version(const std::string& value);
  std::string* _internal_mutable_installed_manifest_platform_version();
  public:

  // optional string system_bundle_version = 12;
  bool has_system_bundle_version() const;
  private:
  bool _internal_has_system_bundle_version() const;
  public:
  void clear_system_bundle_version();
  const std::string& system_bundle_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_system_bundle_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_system_bundle_version();
  PROTOBUF_NODISCARD std::string* release_system_bundle_version();
  void set_allocated_system_bundle_version(std::string* system_bundle_version);
  private:
  const std::string& _internal_system_bundle_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_system_bundle_version(const std::string& value);
  std::string* _internal_mutable_system_bundle_version();
  public:

  // optional fixed64 system_build_number = 2;
  bool has_system_build_number() const;
  private:
  bool _internal_has_system_build_number() const;
  public:
  void clear_system_build_number();
  uint64_t system_build_number() const;
  void set_system_build_number(uint64_t value);
  private:
  uint64_t _internal_system_build_number() const;
  void _internal_set_system_build_number(uint64_t value);
  public:

  // optional .metrics.CastLogsProto.CastDeviceMutableInfo.RebootType last_reboot_type = 1;
  bool has_last_reboot_type() const;
  private:
  bool _internal_has_last_reboot_type() const;
  public:
  void clear_last_reboot_type();
  ::metrics::CastLogsProto_CastDeviceMutableInfo_RebootType last_reboot_type() const;
  void set_last_reboot_type(::metrics::CastLogsProto_CastDeviceMutableInfo_RebootType value);
  private:
  ::metrics::CastLogsProto_CastDeviceMutableInfo_RebootType _internal_last_reboot_type() const;
  void _internal_set_last_reboot_type(::metrics::CastLogsProto_CastDeviceMutableInfo_RebootType value);
  public:

  // optional fixed32 release_version = 4;
  bool has_release_version() const;
  private:
  bool _internal_has_release_version() const;
  public:
  void clear_release_version();
  uint32_t release_version() const;
  void set_release_version(uint32_t value);
  private:
  uint32_t _internal_release_version() const;
  void _internal_set_release_version(uint32_t value);
  public:

  // optional .metrics.CastLogsProto.CastDeviceMutableInfo.NetifIPVersion netif_ip_version = 5;
  bool has_netif_ip_version() const;
  private:
  bool _internal_has_netif_ip_version() const;
  public:
  void clear_netif_ip_version();
  ::metrics::CastLogsProto_CastDeviceMutableInfo_NetifIPVersion netif_ip_version() const;
  void set_netif_ip_version(::metrics::CastLogsProto_CastDeviceMutableInfo_NetifIPVersion value);
  private:
  ::metrics::CastLogsProto_CastDeviceMutableInfo_NetifIPVersion _internal_netif_ip_version() const;
  void _internal_set_netif_ip_version(::metrics::CastLogsProto_CastDeviceMutableInfo_NetifIPVersion value);
  public:

  // optional bool ip_dual_stack_supported = 6;
  bool has_ip_dual_stack_supported() const;
  private:
  bool _internal_has_ip_dual_stack_supported() const;
  public:
  void clear_ip_dual_stack_supported();
  bool ip_dual_stack_supported() const;
  void set_ip_dual_stack_supported(bool value);
  private:
  bool _internal_ip_dual_stack_supported() const;
  void _internal_set_ip_dual_stack_supported(bool value);
  public:

  // optional uint32 installed_manifest_version = 11;
  bool has_installed_manifest_version() const;
  private:
  bool _internal_has_installed_manifest_version() const;
  public:
  void clear_installed_manifest_version();
  uint32_t installed_manifest_version() const;
  void set_installed_manifest_version(uint32_t value);
  private:
  uint32_t _internal_installed_manifest_version() const;
  void _internal_set_installed_manifest_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:metrics.CastLogsProto.CastDeviceMutableInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backdrop_app_device_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timezone_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr latest_ui_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr google_wifi_station_shmac_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr installed_manifest_platform_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr system_bundle_version_;
  uint64_t system_build_number_;
  int last_reboot_type_;
  uint32_t release_version_;
  int netif_ip_version_;
  bool ip_dual_stack_supported_;
  uint32_t installed_manifest_version_;
  friend struct ::TableStruct_cast_5flogs_2eproto;
};
// -------------------------------------------------------------------

class CastLogsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:metrics.CastLogsProto) */ {
 public:
  inline CastLogsProto() : CastLogsProto(nullptr) {}
  ~CastLogsProto() override;
  explicit PROTOBUF_CONSTEXPR CastLogsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CastLogsProto(const CastLogsProto& from);
  CastLogsProto(CastLogsProto&& from) noexcept
    : CastLogsProto() {
    *this = ::std::move(from);
  }

  inline CastLogsProto& operator=(const CastLogsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CastLogsProto& operator=(CastLogsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CastLogsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const CastLogsProto* internal_default_instance() {
    return reinterpret_cast<const CastLogsProto*>(
               &_CastLogsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CastLogsProto& a, CastLogsProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CastLogsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CastLogsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CastLogsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CastLogsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CastLogsProto& from);
  void MergeFrom(const CastLogsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CastLogsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "metrics.CastLogsProto";
  }
  protected:
  explicit CastLogsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CastLogsProto_CastDeviceInfo CastDeviceInfo;
  typedef CastLogsProto_CastConnectionInfo CastConnectionInfo;
  typedef CastLogsProto_CastEventProto CastEventProto;
  typedef CastLogsProto_CastDeviceMutableInfo CastDeviceMutableInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kCastConnectionInfoFieldNumber = 2,
    kCastEventFieldNumber = 3,
    kCastDeviceInfoFieldNumber = 1,
    kCastDeviceMutableInfoFieldNumber = 5,
    kReceiverMetricsIdFieldNumber = 6,
    kVirtualReleaseTrackFieldNumber = 4,
    kSourceVirtualReleaseTrackFieldNumber = 8,
    kEphemeralIdFieldNumber = 7,
  };
  // repeated .metrics.CastLogsProto.CastConnectionInfo cast_connection_info = 2;
  int cast_connection_info_size() const;
  private:
  int _internal_cast_connection_info_size() const;
  public:
  void clear_cast_connection_info();
  ::metrics::CastLogsProto_CastConnectionInfo* mutable_cast_connection_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metrics::CastLogsProto_CastConnectionInfo >*
      mutable_cast_connection_info();
  private:
  const ::metrics::CastLogsProto_CastConnectionInfo& _internal_cast_connection_info(int index) const;
  ::metrics::CastLogsProto_CastConnectionInfo* _internal_add_cast_connection_info();
  public:
  const ::metrics::CastLogsProto_CastConnectionInfo& cast_connection_info(int index) const;
  ::metrics::CastLogsProto_CastConnectionInfo* add_cast_connection_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metrics::CastLogsProto_CastConnectionInfo >&
      cast_connection_info() const;

  // repeated .metrics.CastLogsProto.CastEventProto cast_event = 3;
  int cast_event_size() const;
  private:
  int _internal_cast_event_size() const;
  public:
  void clear_cast_event();
  ::metrics::CastLogsProto_CastEventProto* mutable_cast_event(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metrics::CastLogsProto_CastEventProto >*
      mutable_cast_event();
  private:
  const ::metrics::CastLogsProto_CastEventProto& _internal_cast_event(int index) const;
  ::metrics::CastLogsProto_CastEventProto* _internal_add_cast_event();
  public:
  const ::metrics::CastLogsProto_CastEventProto& cast_event(int index) const;
  ::metrics::CastLogsProto_CastEventProto* add_cast_event();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metrics::CastLogsProto_CastEventProto >&
      cast_event() const;

  // optional .metrics.CastLogsProto.CastDeviceInfo cast_device_info = 1;
  bool has_cast_device_info() const;
  private:
  bool _internal_has_cast_device_info() const;
  public:
  void clear_cast_device_info();
  const ::metrics::CastLogsProto_CastDeviceInfo& cast_device_info() const;
  PROTOBUF_NODISCARD ::metrics::CastLogsProto_CastDeviceInfo* release_cast_device_info();
  ::metrics::CastLogsProto_CastDeviceInfo* mutable_cast_device_info();
  void set_allocated_cast_device_info(::metrics::CastLogsProto_CastDeviceInfo* cast_device_info);
  private:
  const ::metrics::CastLogsProto_CastDeviceInfo& _internal_cast_device_info() const;
  ::metrics::CastLogsProto_CastDeviceInfo* _internal_mutable_cast_device_info();
  public:
  void unsafe_arena_set_allocated_cast_device_info(
      ::metrics::CastLogsProto_CastDeviceInfo* cast_device_info);
  ::metrics::CastLogsProto_CastDeviceInfo* unsafe_arena_release_cast_device_info();

  // optional .metrics.CastLogsProto.CastDeviceMutableInfo cast_device_mutable_info = 5;
  bool has_cast_device_mutable_info() const;
  private:
  bool _internal_has_cast_device_mutable_info() const;
  public:
  void clear_cast_device_mutable_info();
  const ::metrics::CastLogsProto_CastDeviceMutableInfo& cast_device_mutable_info() const;
  PROTOBUF_NODISCARD ::metrics::CastLogsProto_CastDeviceMutableInfo* release_cast_device_mutable_info();
  ::metrics::CastLogsProto_CastDeviceMutableInfo* mutable_cast_device_mutable_info();
  void set_allocated_cast_device_mutable_info(::metrics::CastLogsProto_CastDeviceMutableInfo* cast_device_mutable_info);
  private:
  const ::metrics::CastLogsProto_CastDeviceMutableInfo& _internal_cast_device_mutable_info() const;
  ::metrics::CastLogsProto_CastDeviceMutableInfo* _internal_mutable_cast_device_mutable_info();
  public:
  void unsafe_arena_set_allocated_cast_device_mutable_info(
      ::metrics::CastLogsProto_CastDeviceMutableInfo* cast_device_mutable_info);
  ::metrics::CastLogsProto_CastDeviceMutableInfo* unsafe_arena_release_cast_device_mutable_info();

  // optional fixed64 receiver_metrics_id = 6;
  bool has_receiver_metrics_id() const;
  private:
  bool _internal_has_receiver_metrics_id() const;
  public:
  void clear_receiver_metrics_id();
  uint64_t receiver_metrics_id() const;
  void set_receiver_metrics_id(uint64_t value);
  private:
  uint64_t _internal_receiver_metrics_id() const;
  void _internal_set_receiver_metrics_id(uint64_t value);
  public:

  // optional fixed32 virtual_release_track = 4;
  bool has_virtual_release_track() const;
  private:
  bool _internal_has_virtual_release_track() const;
  public:
  void clear_virtual_release_track();
  uint32_t virtual_release_track() const;
  void set_virtual_release_track(uint32_t value);
  private:
  uint32_t _internal_virtual_release_track() const;
  void _internal_set_virtual_release_track(uint32_t value);
  public:

  // optional fixed32 source_virtual_release_track = 8;
  bool has_source_virtual_release_track() const;
  private:
  bool _internal_has_source_virtual_release_track() const;
  public:
  void clear_source_virtual_release_track();
  uint32_t source_virtual_release_track() const;
  void set_source_virtual_release_track(uint32_t value);
  private:
  uint32_t _internal_source_virtual_release_track() const;
  void _internal_set_source_virtual_release_track(uint32_t value);
  public:

  // optional uint64 ephemeral_id = 7;
  bool has_ephemeral_id() const;
  private:
  bool _internal_has_ephemeral_id() const;
  public:
  void clear_ephemeral_id();
  uint64_t ephemeral_id() const;
  void set_ephemeral_id(uint64_t value);
  private:
  uint64_t _internal_ephemeral_id() const;
  void _internal_set_ephemeral_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:metrics.CastLogsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metrics::CastLogsProto_CastConnectionInfo > cast_connection_info_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metrics::CastLogsProto_CastEventProto > cast_event_;
  ::metrics::CastLogsProto_CastDeviceInfo* cast_device_info_;
  ::metrics::CastLogsProto_CastDeviceMutableInfo* cast_device_mutable_info_;
  uint64_t receiver_metrics_id_;
  uint32_t virtual_release_track_;
  uint32_t source_virtual_release_track_;
  uint64_t ephemeral_id_;
  friend struct ::TableStruct_cast_5flogs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CastLogsProto_CastDeviceInfo_HardwareInfo

// optional string color = 1;
inline bool CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_has_color() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceInfo_HardwareInfo::has_color() const {
  return _internal_has_color();
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::clear_color() {
  color_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CastLogsProto_CastDeviceInfo_HardwareInfo::color() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.color)
  return _internal_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastDeviceInfo_HardwareInfo::set_color(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 color_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.color)
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.color)
  return _s;
}
inline const std::string& CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_color() const {
  return color_.Get();
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_set_color(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  color_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_mutable_color() {
  _has_bits_[0] |= 0x00000001u;
  return color_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::release_color() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.color)
  if (!_internal_has_color()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = color_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (color_.IsDefault()) {
    color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::set_allocated_color(std::string* color) {
  if (color != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  color_.SetAllocated(color, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (color_.IsDefault()) {
    color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.color)
}

// optional string mic = 2;
inline bool CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_has_mic() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceInfo_HardwareInfo::has_mic() const {
  return _internal_has_mic();
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::clear_mic() {
  mic_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CastLogsProto_CastDeviceInfo_HardwareInfo::mic() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.mic)
  return _internal_mic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastDeviceInfo_HardwareInfo::set_mic(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 mic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.mic)
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::mutable_mic() {
  std::string* _s = _internal_mutable_mic();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.mic)
  return _s;
}
inline const std::string& CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_mic() const {
  return mic_.Get();
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_set_mic(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  mic_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_mutable_mic() {
  _has_bits_[0] |= 0x00000002u;
  return mic_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::release_mic() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.mic)
  if (!_internal_has_mic()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = mic_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mic_.IsDefault()) {
    mic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::set_allocated_mic(std::string* mic) {
  if (mic != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  mic_.SetAllocated(mic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mic_.IsDefault()) {
    mic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.mic)
}

// optional string memory = 3;
inline bool CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_has_memory() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceInfo_HardwareInfo::has_memory() const {
  return _internal_has_memory();
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::clear_memory() {
  memory_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CastLogsProto_CastDeviceInfo_HardwareInfo::memory() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.memory)
  return _internal_memory();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastDeviceInfo_HardwareInfo::set_memory(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 memory_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.memory)
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::mutable_memory() {
  std::string* _s = _internal_mutable_memory();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.memory)
  return _s;
}
inline const std::string& CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_memory() const {
  return memory_.Get();
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_set_memory(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  memory_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_mutable_memory() {
  _has_bits_[0] |= 0x00000004u;
  return memory_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::release_memory() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.memory)
  if (!_internal_has_memory()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = memory_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (memory_.IsDefault()) {
    memory_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::set_allocated_memory(std::string* memory) {
  if (memory != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  memory_.SetAllocated(memory, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (memory_.IsDefault()) {
    memory_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.memory)
}

// optional string nand = 4;
inline bool CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_has_nand() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceInfo_HardwareInfo::has_nand() const {
  return _internal_has_nand();
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::clear_nand() {
  nand_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CastLogsProto_CastDeviceInfo_HardwareInfo::nand() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.nand)
  return _internal_nand();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastDeviceInfo_HardwareInfo::set_nand(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 nand_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.nand)
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::mutable_nand() {
  std::string* _s = _internal_mutable_nand();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.nand)
  return _s;
}
inline const std::string& CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_nand() const {
  return nand_.Get();
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_set_nand(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  nand_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_mutable_nand() {
  _has_bits_[0] |= 0x00000008u;
  return nand_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::release_nand() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.nand)
  if (!_internal_has_nand()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = nand_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nand_.IsDefault()) {
    nand_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::set_allocated_nand(std::string* nand) {
  if (nand != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  nand_.SetAllocated(nand, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nand_.IsDefault()) {
    nand_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.nand)
}

// optional string mfg_date = 5;
inline bool CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_has_mfg_date() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceInfo_HardwareInfo::has_mfg_date() const {
  return _internal_has_mfg_date();
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::clear_mfg_date() {
  mfg_date_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CastLogsProto_CastDeviceInfo_HardwareInfo::mfg_date() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.mfg_date)
  return _internal_mfg_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastDeviceInfo_HardwareInfo::set_mfg_date(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 mfg_date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.mfg_date)
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::mutable_mfg_date() {
  std::string* _s = _internal_mutable_mfg_date();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.mfg_date)
  return _s;
}
inline const std::string& CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_mfg_date() const {
  return mfg_date_.Get();
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_set_mfg_date(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  mfg_date_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_mutable_mfg_date() {
  _has_bits_[0] |= 0x00000010u;
  return mfg_date_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::release_mfg_date() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.mfg_date)
  if (!_internal_has_mfg_date()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = mfg_date_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mfg_date_.IsDefault()) {
    mfg_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::set_allocated_mfg_date(std::string* mfg_date) {
  if (mfg_date != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  mfg_date_.SetAllocated(mfg_date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mfg_date_.IsDefault()) {
    mfg_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.mfg_date)
}

// optional string build_name = 6;
inline bool CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_has_build_name() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceInfo_HardwareInfo::has_build_name() const {
  return _internal_has_build_name();
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::clear_build_name() {
  build_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CastLogsProto_CastDeviceInfo_HardwareInfo::build_name() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.build_name)
  return _internal_build_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastDeviceInfo_HardwareInfo::set_build_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 build_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.build_name)
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::mutable_build_name() {
  std::string* _s = _internal_mutable_build_name();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.build_name)
  return _s;
}
inline const std::string& CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_build_name() const {
  return build_name_.Get();
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_set_build_name(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  build_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_mutable_build_name() {
  _has_bits_[0] |= 0x00000020u;
  return build_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::release_build_name() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.build_name)
  if (!_internal_has_build_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = build_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (build_name_.IsDefault()) {
    build_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::set_allocated_build_name(std::string* build_name) {
  if (build_name != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  build_name_.SetAllocated(build_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (build_name_.IsDefault()) {
    build_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.build_name)
}

// optional string config = 7;
inline bool CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_has_config() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceInfo_HardwareInfo::has_config() const {
  return _internal_has_config();
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::clear_config() {
  config_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& CastLogsProto_CastDeviceInfo_HardwareInfo::config() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.config)
  return _internal_config();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastDeviceInfo_HardwareInfo::set_config(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 config_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.config)
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::mutable_config() {
  std::string* _s = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.config)
  return _s;
}
inline const std::string& CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_config() const {
  return config_.Get();
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_set_config(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  config_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_mutable_config() {
  _has_bits_[0] |= 0x00000040u;
  return config_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::release_config() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.config)
  if (!_internal_has_config()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = config_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (config_.IsDefault()) {
    config_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::set_allocated_config(std::string* config) {
  if (config != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  config_.SetAllocated(config, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (config_.IsDefault()) {
    config_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.config)
}

// optional string emmc = 8;
inline bool CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_has_emmc() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceInfo_HardwareInfo::has_emmc() const {
  return _internal_has_emmc();
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::clear_emmc() {
  emmc_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& CastLogsProto_CastDeviceInfo_HardwareInfo::emmc() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.emmc)
  return _internal_emmc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastDeviceInfo_HardwareInfo::set_emmc(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 emmc_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.emmc)
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::mutable_emmc() {
  std::string* _s = _internal_mutable_emmc();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.emmc)
  return _s;
}
inline const std::string& CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_emmc() const {
  return emmc_.Get();
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_set_emmc(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  emmc_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_mutable_emmc() {
  _has_bits_[0] |= 0x00000080u;
  return emmc_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::release_emmc() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.emmc)
  if (!_internal_has_emmc()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = emmc_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (emmc_.IsDefault()) {
    emmc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::set_allocated_emmc(std::string* emmc) {
  if (emmc != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  emmc_.SetAllocated(emmc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (emmc_.IsDefault()) {
    emmc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.emmc)
}

// optional string display = 9;
inline bool CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_has_display() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceInfo_HardwareInfo::has_display() const {
  return _internal_has_display();
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::clear_display() {
  display_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& CastLogsProto_CastDeviceInfo_HardwareInfo::display() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.display)
  return _internal_display();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastDeviceInfo_HardwareInfo::set_display(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 display_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.display)
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::mutable_display() {
  std::string* _s = _internal_mutable_display();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.display)
  return _s;
}
inline const std::string& CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_display() const {
  return display_.Get();
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_set_display(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  display_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_mutable_display() {
  _has_bits_[0] |= 0x00000100u;
  return display_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::release_display() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.display)
  if (!_internal_has_display()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = display_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (display_.IsDefault()) {
    display_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::set_allocated_display(std::string* display) {
  if (display != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  display_.SetAllocated(display, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (display_.IsDefault()) {
    display_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.display)
}

// optional string amp = 10;
inline bool CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_has_amp() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceInfo_HardwareInfo::has_amp() const {
  return _internal_has_amp();
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::clear_amp() {
  amp_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000200u;
}
inline const std::string& CastLogsProto_CastDeviceInfo_HardwareInfo::amp() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.amp)
  return _internal_amp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastDeviceInfo_HardwareInfo::set_amp(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000200u;
 amp_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.amp)
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::mutable_amp() {
  std::string* _s = _internal_mutable_amp();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.amp)
  return _s;
}
inline const std::string& CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_amp() const {
  return amp_.Get();
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_set_amp(const std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  amp_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_mutable_amp() {
  _has_bits_[0] |= 0x00000200u;
  return amp_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::release_amp() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.amp)
  if (!_internal_has_amp()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  auto* p = amp_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (amp_.IsDefault()) {
    amp_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::set_allocated_amp(std::string* amp) {
  if (amp != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  amp_.SetAllocated(amp, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (amp_.IsDefault()) {
    amp_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.amp)
}

// optional string board_name = 11;
inline bool CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_has_board_name() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceInfo_HardwareInfo::has_board_name() const {
  return _internal_has_board_name();
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::clear_board_name() {
  board_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000400u;
}
inline const std::string& CastLogsProto_CastDeviceInfo_HardwareInfo::board_name() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.board_name)
  return _internal_board_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastDeviceInfo_HardwareInfo::set_board_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000400u;
 board_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.board_name)
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::mutable_board_name() {
  std::string* _s = _internal_mutable_board_name();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.board_name)
  return _s;
}
inline const std::string& CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_board_name() const {
  return board_name_.Get();
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_set_board_name(const std::string& value) {
  _has_bits_[0] |= 0x00000400u;
  board_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::_internal_mutable_board_name() {
  _has_bits_[0] |= 0x00000400u;
  return board_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo_HardwareInfo::release_board_name() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.board_name)
  if (!_internal_has_board_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000400u;
  auto* p = board_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (board_name_.IsDefault()) {
    board_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastDeviceInfo_HardwareInfo::set_allocated_board_name(std::string* board_name) {
  if (board_name != nullptr) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  board_name_.SetAllocated(board_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (board_name_.IsDefault()) {
    board_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastDeviceInfo.HardwareInfo.board_name)
}

// -------------------------------------------------------------------

// CastLogsProto_CastDeviceInfo

// optional .metrics.CastLogsProto.CastDeviceInfo.CastProductType type = 1;
inline bool CastLogsProto_CastDeviceInfo::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceInfo::has_type() const {
  return _internal_has_type();
}
inline void CastLogsProto_CastDeviceInfo::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::metrics::CastLogsProto_CastDeviceInfo_CastProductType CastLogsProto_CastDeviceInfo::_internal_type() const {
  return static_cast< ::metrics::CastLogsProto_CastDeviceInfo_CastProductType >(type_);
}
inline ::metrics::CastLogsProto_CastDeviceInfo_CastProductType CastLogsProto_CastDeviceInfo::type() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceInfo.type)
  return _internal_type();
}
inline void CastLogsProto_CastDeviceInfo::_internal_set_type(::metrics::CastLogsProto_CastDeviceInfo_CastProductType value) {
  assert(::metrics::CastLogsProto_CastDeviceInfo_CastProductType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  type_ = value;
}
inline void CastLogsProto_CastDeviceInfo::set_type(::metrics::CastLogsProto_CastDeviceInfo_CastProductType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceInfo.type)
}

// optional string hardware_revision = 2;
inline bool CastLogsProto_CastDeviceInfo::_internal_has_hardware_revision() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceInfo::has_hardware_revision() const {
  return _internal_has_hardware_revision();
}
inline void CastLogsProto_CastDeviceInfo::clear_hardware_revision() {
  hardware_revision_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CastLogsProto_CastDeviceInfo::hardware_revision() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceInfo.hardware_revision)
  return _internal_hardware_revision();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastDeviceInfo::set_hardware_revision(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 hardware_revision_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceInfo.hardware_revision)
}
inline std::string* CastLogsProto_CastDeviceInfo::mutable_hardware_revision() {
  std::string* _s = _internal_mutable_hardware_revision();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastDeviceInfo.hardware_revision)
  return _s;
}
inline const std::string& CastLogsProto_CastDeviceInfo::_internal_hardware_revision() const {
  return hardware_revision_.Get();
}
inline void CastLogsProto_CastDeviceInfo::_internal_set_hardware_revision(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hardware_revision_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo::_internal_mutable_hardware_revision() {
  _has_bits_[0] |= 0x00000001u;
  return hardware_revision_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo::release_hardware_revision() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastDeviceInfo.hardware_revision)
  if (!_internal_has_hardware_revision()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = hardware_revision_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hardware_revision_.IsDefault()) {
    hardware_revision_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastDeviceInfo::set_allocated_hardware_revision(std::string* hardware_revision) {
  if (hardware_revision != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hardware_revision_.SetAllocated(hardware_revision, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hardware_revision_.IsDefault()) {
    hardware_revision_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastDeviceInfo.hardware_revision)
}

// optional string manufacturer = 3;
inline bool CastLogsProto_CastDeviceInfo::_internal_has_manufacturer() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceInfo::has_manufacturer() const {
  return _internal_has_manufacturer();
}
inline void CastLogsProto_CastDeviceInfo::clear_manufacturer() {
  manufacturer_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CastLogsProto_CastDeviceInfo::manufacturer() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceInfo.manufacturer)
  return _internal_manufacturer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastDeviceInfo::set_manufacturer(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 manufacturer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceInfo.manufacturer)
}
inline std::string* CastLogsProto_CastDeviceInfo::mutable_manufacturer() {
  std::string* _s = _internal_mutable_manufacturer();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastDeviceInfo.manufacturer)
  return _s;
}
inline const std::string& CastLogsProto_CastDeviceInfo::_internal_manufacturer() const {
  return manufacturer_.Get();
}
inline void CastLogsProto_CastDeviceInfo::_internal_set_manufacturer(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  manufacturer_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo::_internal_mutable_manufacturer() {
  _has_bits_[0] |= 0x00000002u;
  return manufacturer_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo::release_manufacturer() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastDeviceInfo.manufacturer)
  if (!_internal_has_manufacturer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = manufacturer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (manufacturer_.IsDefault()) {
    manufacturer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastDeviceInfo::set_allocated_manufacturer(std::string* manufacturer) {
  if (manufacturer != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  manufacturer_.SetAllocated(manufacturer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (manufacturer_.IsDefault()) {
    manufacturer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastDeviceInfo.manufacturer)
}

// optional string model = 4;
inline bool CastLogsProto_CastDeviceInfo::_internal_has_model() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceInfo::has_model() const {
  return _internal_has_model();
}
inline void CastLogsProto_CastDeviceInfo::clear_model() {
  model_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CastLogsProto_CastDeviceInfo::model() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceInfo.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastDeviceInfo::set_model(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceInfo.model)
}
inline std::string* CastLogsProto_CastDeviceInfo::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastDeviceInfo.model)
  return _s;
}
inline const std::string& CastLogsProto_CastDeviceInfo::_internal_model() const {
  return model_.Get();
}
inline void CastLogsProto_CastDeviceInfo::_internal_set_model(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  model_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo::_internal_mutable_model() {
  _has_bits_[0] |= 0x00000004u;
  return model_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo::release_model() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastDeviceInfo.model)
  if (!_internal_has_model()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = model_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_.IsDefault()) {
    model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastDeviceInfo::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_.IsDefault()) {
    model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastDeviceInfo.model)
}

// optional string serial_number = 5;
inline bool CastLogsProto_CastDeviceInfo::_internal_has_serial_number() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceInfo::has_serial_number() const {
  return _internal_has_serial_number();
}
inline void CastLogsProto_CastDeviceInfo::clear_serial_number() {
  serial_number_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CastLogsProto_CastDeviceInfo::serial_number() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceInfo.serial_number)
  return _internal_serial_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastDeviceInfo::set_serial_number(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 serial_number_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceInfo.serial_number)
}
inline std::string* CastLogsProto_CastDeviceInfo::mutable_serial_number() {
  std::string* _s = _internal_mutable_serial_number();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastDeviceInfo.serial_number)
  return _s;
}
inline const std::string& CastLogsProto_CastDeviceInfo::_internal_serial_number() const {
  return serial_number_.Get();
}
inline void CastLogsProto_CastDeviceInfo::_internal_set_serial_number(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  serial_number_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo::_internal_mutable_serial_number() {
  _has_bits_[0] |= 0x00000008u;
  return serial_number_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceInfo::release_serial_number() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastDeviceInfo.serial_number)
  if (!_internal_has_serial_number()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = serial_number_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serial_number_.IsDefault()) {
    serial_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastDeviceInfo::set_allocated_serial_number(std::string* serial_number) {
  if (serial_number != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  serial_number_.SetAllocated(serial_number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serial_number_.IsDefault()) {
    serial_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastDeviceInfo.serial_number)
}

// optional .metrics.CastLogsProto.CastDeviceInfo.HardwareInfo hardware_info = 6;
inline bool CastLogsProto_CastDeviceInfo::_internal_has_hardware_info() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || hardware_info_ != nullptr);
  return value;
}
inline bool CastLogsProto_CastDeviceInfo::has_hardware_info() const {
  return _internal_has_hardware_info();
}
inline void CastLogsProto_CastDeviceInfo::clear_hardware_info() {
  if (hardware_info_ != nullptr) hardware_info_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo& CastLogsProto_CastDeviceInfo::_internal_hardware_info() const {
  const ::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo* p = hardware_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo&>(
      ::metrics::_CastLogsProto_CastDeviceInfo_HardwareInfo_default_instance_);
}
inline const ::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo& CastLogsProto_CastDeviceInfo::hardware_info() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceInfo.hardware_info)
  return _internal_hardware_info();
}
inline void CastLogsProto_CastDeviceInfo::unsafe_arena_set_allocated_hardware_info(
    ::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo* hardware_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hardware_info_);
  }
  hardware_info_ = hardware_info;
  if (hardware_info) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:metrics.CastLogsProto.CastDeviceInfo.hardware_info)
}
inline ::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo* CastLogsProto_CastDeviceInfo::release_hardware_info() {
  _has_bits_[0] &= ~0x00000010u;
  ::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo* temp = hardware_info_;
  hardware_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo* CastLogsProto_CastDeviceInfo::unsafe_arena_release_hardware_info() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastDeviceInfo.hardware_info)
  _has_bits_[0] &= ~0x00000010u;
  ::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo* temp = hardware_info_;
  hardware_info_ = nullptr;
  return temp;
}
inline ::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo* CastLogsProto_CastDeviceInfo::_internal_mutable_hardware_info() {
  _has_bits_[0] |= 0x00000010u;
  if (hardware_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo>(GetArenaForAllocation());
    hardware_info_ = p;
  }
  return hardware_info_;
}
inline ::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo* CastLogsProto_CastDeviceInfo::mutable_hardware_info() {
  ::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo* _msg = _internal_mutable_hardware_info();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastDeviceInfo.hardware_info)
  return _msg;
}
inline void CastLogsProto_CastDeviceInfo::set_allocated_hardware_info(::metrics::CastLogsProto_CastDeviceInfo_HardwareInfo* hardware_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete hardware_info_;
  }
  if (hardware_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hardware_info);
    if (message_arena != submessage_arena) {
      hardware_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hardware_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  hardware_info_ = hardware_info;
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastDeviceInfo.hardware_info)
}

// -------------------------------------------------------------------

// CastLogsProto_CastConnectionInfo_SenderInfo

// optional fixed64 sender_device_id = 1;
inline bool CastLogsProto_CastConnectionInfo_SenderInfo::_internal_has_sender_device_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CastLogsProto_CastConnectionInfo_SenderInfo::has_sender_device_id() const {
  return _internal_has_sender_device_id();
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::clear_sender_device_id() {
  sender_device_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline uint64_t CastLogsProto_CastConnectionInfo_SenderInfo::_internal_sender_device_id() const {
  return sender_device_id_;
}
inline uint64_t CastLogsProto_CastConnectionInfo_SenderInfo::sender_device_id() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.sender_device_id)
  return _internal_sender_device_id();
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::_internal_set_sender_device_id(uint64_t value) {
  _has_bits_[0] |= 0x00000010u;
  sender_device_id_ = value;
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::set_sender_device_id(uint64_t value) {
  _internal_set_sender_device_id(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.sender_device_id)
}

// optional .metrics.CastLogsProto.CastConnectionInfo.SenderInfo.SDKType sdk_type = 2;
inline bool CastLogsProto_CastConnectionInfo_SenderInfo::_internal_has_sdk_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CastLogsProto_CastConnectionInfo_SenderInfo::has_sdk_type() const {
  return _internal_has_sdk_type();
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::clear_sdk_type() {
  sdk_type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_SDKType CastLogsProto_CastConnectionInfo_SenderInfo::_internal_sdk_type() const {
  return static_cast< ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_SDKType >(sdk_type_);
}
inline ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_SDKType CastLogsProto_CastConnectionInfo_SenderInfo::sdk_type() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.sdk_type)
  return _internal_sdk_type();
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::_internal_set_sdk_type(::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_SDKType value) {
  assert(::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_SDKType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  sdk_type_ = value;
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::set_sdk_type(::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_SDKType value) {
  _internal_set_sdk_type(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.sdk_type)
}

// optional string version = 3;
inline bool CastLogsProto_CastConnectionInfo_SenderInfo::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CastLogsProto_CastConnectionInfo_SenderInfo::has_version() const {
  return _internal_has_version();
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::clear_version() {
  version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CastLogsProto_CastConnectionInfo_SenderInfo::version() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastConnectionInfo_SenderInfo::set_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.version)
}
inline std::string* CastLogsProto_CastConnectionInfo_SenderInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.version)
  return _s;
}
inline const std::string& CastLogsProto_CastConnectionInfo_SenderInfo::_internal_version() const {
  return version_.Get();
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  version_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastConnectionInfo_SenderInfo::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000001u;
  return version_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastConnectionInfo_SenderInfo::release_version() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.version)
}

// optional string chrome_browser_version = 4;
inline bool CastLogsProto_CastConnectionInfo_SenderInfo::_internal_has_chrome_browser_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CastLogsProto_CastConnectionInfo_SenderInfo::has_chrome_browser_version() const {
  return _internal_has_chrome_browser_version();
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::clear_chrome_browser_version() {
  chrome_browser_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CastLogsProto_CastConnectionInfo_SenderInfo::chrome_browser_version() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.chrome_browser_version)
  return _internal_chrome_browser_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastConnectionInfo_SenderInfo::set_chrome_browser_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 chrome_browser_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.chrome_browser_version)
}
inline std::string* CastLogsProto_CastConnectionInfo_SenderInfo::mutable_chrome_browser_version() {
  std::string* _s = _internal_mutable_chrome_browser_version();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.chrome_browser_version)
  return _s;
}
inline const std::string& CastLogsProto_CastConnectionInfo_SenderInfo::_internal_chrome_browser_version() const {
  return chrome_browser_version_.Get();
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::_internal_set_chrome_browser_version(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  chrome_browser_version_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastConnectionInfo_SenderInfo::_internal_mutable_chrome_browser_version() {
  _has_bits_[0] |= 0x00000002u;
  return chrome_browser_version_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastConnectionInfo_SenderInfo::release_chrome_browser_version() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.chrome_browser_version)
  if (!_internal_has_chrome_browser_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = chrome_browser_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chrome_browser_version_.IsDefault()) {
    chrome_browser_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::set_allocated_chrome_browser_version(std::string* chrome_browser_version) {
  if (chrome_browser_version != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  chrome_browser_version_.SetAllocated(chrome_browser_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chrome_browser_version_.IsDefault()) {
    chrome_browser_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.chrome_browser_version)
}

// optional .metrics.CastLogsProto.CastConnectionInfo.SenderInfo.Platform platform = 5;
inline bool CastLogsProto_CastConnectionInfo_SenderInfo::_internal_has_platform() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CastLogsProto_CastConnectionInfo_SenderInfo::has_platform() const {
  return _internal_has_platform();
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::clear_platform() {
  platform_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_Platform CastLogsProto_CastConnectionInfo_SenderInfo::_internal_platform() const {
  return static_cast< ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_Platform >(platform_);
}
inline ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_Platform CastLogsProto_CastConnectionInfo_SenderInfo::platform() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.platform)
  return _internal_platform();
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::_internal_set_platform(::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_Platform value) {
  assert(::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_Platform_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  platform_ = value;
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::set_platform(::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_Platform value) {
  _internal_set_platform(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.platform)
}

// optional string system_version = 6;
inline bool CastLogsProto_CastConnectionInfo_SenderInfo::_internal_has_system_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CastLogsProto_CastConnectionInfo_SenderInfo::has_system_version() const {
  return _internal_has_system_version();
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::clear_system_version() {
  system_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CastLogsProto_CastConnectionInfo_SenderInfo::system_version() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.system_version)
  return _internal_system_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastConnectionInfo_SenderInfo::set_system_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 system_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.system_version)
}
inline std::string* CastLogsProto_CastConnectionInfo_SenderInfo::mutable_system_version() {
  std::string* _s = _internal_mutable_system_version();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.system_version)
  return _s;
}
inline const std::string& CastLogsProto_CastConnectionInfo_SenderInfo::_internal_system_version() const {
  return system_version_.Get();
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::_internal_set_system_version(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  system_version_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastConnectionInfo_SenderInfo::_internal_mutable_system_version() {
  _has_bits_[0] |= 0x00000004u;
  return system_version_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastConnectionInfo_SenderInfo::release_system_version() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.system_version)
  if (!_internal_has_system_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = system_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (system_version_.IsDefault()) {
    system_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::set_allocated_system_version(std::string* system_version) {
  if (system_version != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  system_version_.SetAllocated(system_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (system_version_.IsDefault()) {
    system_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.system_version)
}

// optional .metrics.CastLogsProto.CastConnectionInfo.SenderInfo.ConnectionType transport_connection_type = 7;
inline bool CastLogsProto_CastConnectionInfo_SenderInfo::_internal_has_transport_connection_type() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CastLogsProto_CastConnectionInfo_SenderInfo::has_transport_connection_type() const {
  return _internal_has_transport_connection_type();
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::clear_transport_connection_type() {
  transport_connection_type_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType CastLogsProto_CastConnectionInfo_SenderInfo::_internal_transport_connection_type() const {
  return static_cast< ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType >(transport_connection_type_);
}
inline ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType CastLogsProto_CastConnectionInfo_SenderInfo::transport_connection_type() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.transport_connection_type)
  return _internal_transport_connection_type();
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::_internal_set_transport_connection_type(::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType value) {
  assert(::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  transport_connection_type_ = value;
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::set_transport_connection_type(::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType value) {
  _internal_set_transport_connection_type(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.transport_connection_type)
}

// optional string model = 8;
inline bool CastLogsProto_CastConnectionInfo_SenderInfo::_internal_has_model() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CastLogsProto_CastConnectionInfo_SenderInfo::has_model() const {
  return _internal_has_model();
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::clear_model() {
  model_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CastLogsProto_CastConnectionInfo_SenderInfo::model() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastConnectionInfo_SenderInfo::set_model(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.model)
}
inline std::string* CastLogsProto_CastConnectionInfo_SenderInfo::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.model)
  return _s;
}
inline const std::string& CastLogsProto_CastConnectionInfo_SenderInfo::_internal_model() const {
  return model_.Get();
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::_internal_set_model(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  model_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastConnectionInfo_SenderInfo::_internal_mutable_model() {
  _has_bits_[0] |= 0x00000008u;
  return model_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastConnectionInfo_SenderInfo::release_model() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.model)
  if (!_internal_has_model()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = model_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_.IsDefault()) {
    model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_.IsDefault()) {
    model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.model)
}

// optional int32 sender_local_ip_fragment = 9;
inline bool CastLogsProto_CastConnectionInfo_SenderInfo::_internal_has_sender_local_ip_fragment() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CastLogsProto_CastConnectionInfo_SenderInfo::has_sender_local_ip_fragment() const {
  return _internal_has_sender_local_ip_fragment();
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::clear_sender_local_ip_fragment() {
  sender_local_ip_fragment_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline int32_t CastLogsProto_CastConnectionInfo_SenderInfo::_internal_sender_local_ip_fragment() const {
  return sender_local_ip_fragment_;
}
inline int32_t CastLogsProto_CastConnectionInfo_SenderInfo::sender_local_ip_fragment() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.sender_local_ip_fragment)
  return _internal_sender_local_ip_fragment();
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::_internal_set_sender_local_ip_fragment(int32_t value) {
  _has_bits_[0] |= 0x00000100u;
  sender_local_ip_fragment_ = value;
}
inline void CastLogsProto_CastConnectionInfo_SenderInfo::set_sender_local_ip_fragment(int32_t value) {
  _internal_set_sender_local_ip_fragment(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastConnectionInfo.SenderInfo.sender_local_ip_fragment)
}

// -------------------------------------------------------------------

// CastLogsProto_CastConnectionInfo

// optional fixed32 transport_connection_id = 1;
inline bool CastLogsProto_CastConnectionInfo::_internal_has_transport_connection_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CastLogsProto_CastConnectionInfo::has_transport_connection_id() const {
  return _internal_has_transport_connection_id();
}
inline void CastLogsProto_CastConnectionInfo::clear_transport_connection_id() {
  transport_connection_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CastLogsProto_CastConnectionInfo::_internal_transport_connection_id() const {
  return transport_connection_id_;
}
inline uint32_t CastLogsProto_CastConnectionInfo::transport_connection_id() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastConnectionInfo.transport_connection_id)
  return _internal_transport_connection_id();
}
inline void CastLogsProto_CastConnectionInfo::_internal_set_transport_connection_id(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  transport_connection_id_ = value;
}
inline void CastLogsProto_CastConnectionInfo::set_transport_connection_id(uint32_t value) {
  _internal_set_transport_connection_id(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastConnectionInfo.transport_connection_id)
}

// optional fixed32 virtual_connection_id = 2;
inline bool CastLogsProto_CastConnectionInfo::_internal_has_virtual_connection_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CastLogsProto_CastConnectionInfo::has_virtual_connection_id() const {
  return _internal_has_virtual_connection_id();
}
inline void CastLogsProto_CastConnectionInfo::clear_virtual_connection_id() {
  virtual_connection_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CastLogsProto_CastConnectionInfo::_internal_virtual_connection_id() const {
  return virtual_connection_id_;
}
inline uint32_t CastLogsProto_CastConnectionInfo::virtual_connection_id() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastConnectionInfo.virtual_connection_id)
  return _internal_virtual_connection_id();
}
inline void CastLogsProto_CastConnectionInfo::_internal_set_virtual_connection_id(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  virtual_connection_id_ = value;
}
inline void CastLogsProto_CastConnectionInfo::set_virtual_connection_id(uint32_t value) {
  _internal_set_virtual_connection_id(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastConnectionInfo.virtual_connection_id)
}

// optional .metrics.CastLogsProto.CastConnectionInfo.SenderInfo sender_info = 3;
inline bool CastLogsProto_CastConnectionInfo::_internal_has_sender_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || sender_info_ != nullptr);
  return value;
}
inline bool CastLogsProto_CastConnectionInfo::has_sender_info() const {
  return _internal_has_sender_info();
}
inline void CastLogsProto_CastConnectionInfo::clear_sender_info() {
  if (sender_info_ != nullptr) sender_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo& CastLogsProto_CastConnectionInfo::_internal_sender_info() const {
  const ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo* p = sender_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo&>(
      ::metrics::_CastLogsProto_CastConnectionInfo_SenderInfo_default_instance_);
}
inline const ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo& CastLogsProto_CastConnectionInfo::sender_info() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastConnectionInfo.sender_info)
  return _internal_sender_info();
}
inline void CastLogsProto_CastConnectionInfo::unsafe_arena_set_allocated_sender_info(
    ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo* sender_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sender_info_);
  }
  sender_info_ = sender_info;
  if (sender_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:metrics.CastLogsProto.CastConnectionInfo.sender_info)
}
inline ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo* CastLogsProto_CastConnectionInfo::release_sender_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo* temp = sender_info_;
  sender_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo* CastLogsProto_CastConnectionInfo::unsafe_arena_release_sender_info() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastConnectionInfo.sender_info)
  _has_bits_[0] &= ~0x00000001u;
  ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo* temp = sender_info_;
  sender_info_ = nullptr;
  return temp;
}
inline ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo* CastLogsProto_CastConnectionInfo::_internal_mutable_sender_info() {
  _has_bits_[0] |= 0x00000001u;
  if (sender_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::metrics::CastLogsProto_CastConnectionInfo_SenderInfo>(GetArenaForAllocation());
    sender_info_ = p;
  }
  return sender_info_;
}
inline ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo* CastLogsProto_CastConnectionInfo::mutable_sender_info() {
  ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo* _msg = _internal_mutable_sender_info();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastConnectionInfo.sender_info)
  return _msg;
}
inline void CastLogsProto_CastConnectionInfo::set_allocated_sender_info(::metrics::CastLogsProto_CastConnectionInfo_SenderInfo* sender_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sender_info_;
  }
  if (sender_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sender_info);
    if (message_arena != submessage_arena) {
      sender_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sender_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sender_info_ = sender_info;
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastConnectionInfo.sender_info)
}

// -------------------------------------------------------------------

// CastLogsProto_CastEventProto_Metadata

// optional fixed64 name_hash = 1;
inline bool CastLogsProto_CastEventProto_Metadata::_internal_has_name_hash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto_Metadata::has_name_hash() const {
  return _internal_has_name_hash();
}
inline void CastLogsProto_CastEventProto_Metadata::clear_name_hash() {
  name_hash_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CastLogsProto_CastEventProto_Metadata::_internal_name_hash() const {
  return name_hash_;
}
inline uint64_t CastLogsProto_CastEventProto_Metadata::name_hash() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.Metadata.name_hash)
  return _internal_name_hash();
}
inline void CastLogsProto_CastEventProto_Metadata::_internal_set_name_hash(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  name_hash_ = value;
}
inline void CastLogsProto_CastEventProto_Metadata::set_name_hash(uint64_t value) {
  _internal_set_name_hash(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.Metadata.name_hash)
}

// optional int64 value = 2;
inline bool CastLogsProto_CastEventProto_Metadata::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto_Metadata::has_value() const {
  return _internal_has_value();
}
inline void CastLogsProto_CastEventProto_Metadata::clear_value() {
  value_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t CastLogsProto_CastEventProto_Metadata::_internal_value() const {
  return value_;
}
inline int64_t CastLogsProto_CastEventProto_Metadata::value() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.Metadata.value)
  return _internal_value();
}
inline void CastLogsProto_CastEventProto_Metadata::_internal_set_value(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  value_ = value;
}
inline void CastLogsProto_CastEventProto_Metadata::set_value(int64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.Metadata.value)
}

// -------------------------------------------------------------------

// CastLogsProto_CastEventProto

// optional fixed64 name_hash = 1;
inline bool CastLogsProto_CastEventProto::_internal_has_name_hash() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_name_hash() const {
  return _internal_has_name_hash();
}
inline void CastLogsProto_CastEventProto::clear_name_hash() {
  name_hash_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000200u;
}
inline uint64_t CastLogsProto_CastEventProto::_internal_name_hash() const {
  return name_hash_;
}
inline uint64_t CastLogsProto_CastEventProto::name_hash() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.name_hash)
  return _internal_name_hash();
}
inline void CastLogsProto_CastEventProto::_internal_set_name_hash(uint64_t value) {
  _has_bits_[0] |= 0x00000200u;
  name_hash_ = value;
}
inline void CastLogsProto_CastEventProto::set_name_hash(uint64_t value) {
  _internal_set_name_hash(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.name_hash)
}

// optional int64 time_msec = 2;
inline bool CastLogsProto_CastEventProto::_internal_has_time_msec() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_time_msec() const {
  return _internal_has_time_msec();
}
inline void CastLogsProto_CastEventProto::clear_time_msec() {
  time_msec_ = int64_t{0};
  _has_bits_[0] &= ~0x00000400u;
}
inline int64_t CastLogsProto_CastEventProto::_internal_time_msec() const {
  return time_msec_;
}
inline int64_t CastLogsProto_CastEventProto::time_msec() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.time_msec)
  return _internal_time_msec();
}
inline void CastLogsProto_CastEventProto::_internal_set_time_msec(int64_t value) {
  _has_bits_[0] |= 0x00000400u;
  time_msec_ = value;
}
inline void CastLogsProto_CastEventProto::set_time_msec(int64_t value) {
  _internal_set_time_msec(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.time_msec)
}

// optional fixed32 app_id = 3;
inline bool CastLogsProto_CastEventProto::_internal_has_app_id() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_app_id() const {
  return _internal_has_app_id();
}
inline void CastLogsProto_CastEventProto::clear_app_id() {
  app_id_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline uint32_t CastLogsProto_CastEventProto::_internal_app_id() const {
  return app_id_;
}
inline uint32_t CastLogsProto_CastEventProto::app_id() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.app_id)
  return _internal_app_id();
}
inline void CastLogsProto_CastEventProto::_internal_set_app_id(uint32_t value) {
  _has_bits_[0] |= 0x00001000u;
  app_id_ = value;
}
inline void CastLogsProto_CastEventProto::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.app_id)
}

// optional fixed32 remote_app_id = 19;
inline bool CastLogsProto_CastEventProto::_internal_has_remote_app_id() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_remote_app_id() const {
  return _internal_has_remote_app_id();
}
inline void CastLogsProto_CastEventProto::clear_remote_app_id() {
  remote_app_id_ = 0u;
  _has_bits_[0] &= ~0x00200000u;
}
inline uint32_t CastLogsProto_CastEventProto::_internal_remote_app_id() const {
  return remote_app_id_;
}
inline uint32_t CastLogsProto_CastEventProto::remote_app_id() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.remote_app_id)
  return _internal_remote_app_id();
}
inline void CastLogsProto_CastEventProto::_internal_set_remote_app_id(uint32_t value) {
  _has_bits_[0] |= 0x00200000u;
  remote_app_id_ = value;
}
inline void CastLogsProto_CastEventProto::set_remote_app_id(uint32_t value) {
  _internal_set_remote_app_id(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.remote_app_id)
}

// optional fixed64 application_session_id = 4;
inline bool CastLogsProto_CastEventProto::_internal_has_application_session_id() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_application_session_id() const {
  return _internal_has_application_session_id();
}
inline void CastLogsProto_CastEventProto::clear_application_session_id() {
  application_session_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000800u;
}
inline uint64_t CastLogsProto_CastEventProto::_internal_application_session_id() const {
  return application_session_id_;
}
inline uint64_t CastLogsProto_CastEventProto::application_session_id() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.application_session_id)
  return _internal_application_session_id();
}
inline void CastLogsProto_CastEventProto::_internal_set_application_session_id(uint64_t value) {
  _has_bits_[0] |= 0x00000800u;
  application_session_id_ = value;
}
inline void CastLogsProto_CastEventProto::set_application_session_id(uint64_t value) {
  _internal_set_application_session_id(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.application_session_id)
}

// optional fixed64 cast_receiver_version = 5;
inline bool CastLogsProto_CastEventProto::_internal_has_cast_receiver_version() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_cast_receiver_version() const {
  return _internal_has_cast_receiver_version();
}
inline void CastLogsProto_CastEventProto::clear_cast_receiver_version() {
  cast_receiver_version_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00004000u;
}
inline uint64_t CastLogsProto_CastEventProto::_internal_cast_receiver_version() const {
  return cast_receiver_version_;
}
inline uint64_t CastLogsProto_CastEventProto::cast_receiver_version() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.cast_receiver_version)
  return _internal_cast_receiver_version();
}
inline void CastLogsProto_CastEventProto::_internal_set_cast_receiver_version(uint64_t value) {
  _has_bits_[0] |= 0x00004000u;
  cast_receiver_version_ = value;
}
inline void CastLogsProto_CastEventProto::set_cast_receiver_version(uint64_t value) {
  _internal_set_cast_receiver_version(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.cast_receiver_version)
}

// optional fixed64 cast_mpl_version = 9;
inline bool CastLogsProto_CastEventProto::_internal_has_cast_mpl_version() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_cast_mpl_version() const {
  return _internal_has_cast_mpl_version();
}
inline void CastLogsProto_CastEventProto::clear_cast_mpl_version() {
  cast_mpl_version_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00010000u;
}
inline uint64_t CastLogsProto_CastEventProto::_internal_cast_mpl_version() const {
  return cast_mpl_version_;
}
inline uint64_t CastLogsProto_CastEventProto::cast_mpl_version() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.cast_mpl_version)
  return _internal_cast_mpl_version();
}
inline void CastLogsProto_CastEventProto::_internal_set_cast_mpl_version(uint64_t value) {
  _has_bits_[0] |= 0x00010000u;
  cast_mpl_version_ = value;
}
inline void CastLogsProto_CastEventProto::set_cast_mpl_version(uint64_t value) {
  _internal_set_cast_mpl_version(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.cast_mpl_version)
}

// optional fixed32 transport_connection_id = 6;
inline bool CastLogsProto_CastEventProto::_internal_has_transport_connection_id() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_transport_connection_id() const {
  return _internal_has_transport_connection_id();
}
inline void CastLogsProto_CastEventProto::clear_transport_connection_id() {
  transport_connection_id_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline uint32_t CastLogsProto_CastEventProto::_internal_transport_connection_id() const {
  return transport_connection_id_;
}
inline uint32_t CastLogsProto_CastEventProto::transport_connection_id() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.transport_connection_id)
  return _internal_transport_connection_id();
}
inline void CastLogsProto_CastEventProto::_internal_set_transport_connection_id(uint32_t value) {
  _has_bits_[0] |= 0x00002000u;
  transport_connection_id_ = value;
}
inline void CastLogsProto_CastEventProto::set_transport_connection_id(uint32_t value) {
  _internal_set_transport_connection_id(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.transport_connection_id)
}

// optional fixed32 virtual_connection_id = 7;
inline bool CastLogsProto_CastEventProto::_internal_has_virtual_connection_id() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_virtual_connection_id() const {
  return _internal_has_virtual_connection_id();
}
inline void CastLogsProto_CastEventProto::clear_virtual_connection_id() {
  virtual_connection_id_ = 0u;
  _has_bits_[0] &= ~0x00020000u;
}
inline uint32_t CastLogsProto_CastEventProto::_internal_virtual_connection_id() const {
  return virtual_connection_id_;
}
inline uint32_t CastLogsProto_CastEventProto::virtual_connection_id() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.virtual_connection_id)
  return _internal_virtual_connection_id();
}
inline void CastLogsProto_CastEventProto::_internal_set_virtual_connection_id(uint32_t value) {
  _has_bits_[0] |= 0x00020000u;
  virtual_connection_id_ = value;
}
inline void CastLogsProto_CastEventProto::set_virtual_connection_id(uint32_t value) {
  _internal_set_virtual_connection_id(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.virtual_connection_id)
}

// optional int64 value = 8;
inline bool CastLogsProto_CastEventProto::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_value() const {
  return _internal_has_value();
}
inline void CastLogsProto_CastEventProto::clear_value() {
  value_ = int64_t{0};
  _has_bits_[0] &= ~0x00008000u;
}
inline int64_t CastLogsProto_CastEventProto::_internal_value() const {
  return value_;
}
inline int64_t CastLogsProto_CastEventProto::value() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.value)
  return _internal_value();
}
inline void CastLogsProto_CastEventProto::_internal_set_value(int64_t value) {
  _has_bits_[0] |= 0x00008000u;
  value_ = value;
}
inline void CastLogsProto_CastEventProto::set_value(int64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.value)
}

// optional fixed64 group_uuid = 10;
inline bool CastLogsProto_CastEventProto::_internal_has_group_uuid() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_group_uuid() const {
  return _internal_has_group_uuid();
}
inline void CastLogsProto_CastEventProto::clear_group_uuid() {
  group_uuid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00080000u;
}
inline uint64_t CastLogsProto_CastEventProto::_internal_group_uuid() const {
  return group_uuid_;
}
inline uint64_t CastLogsProto_CastEventProto::group_uuid() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.group_uuid)
  return _internal_group_uuid();
}
inline void CastLogsProto_CastEventProto::_internal_set_group_uuid(uint64_t value) {
  _has_bits_[0] |= 0x00080000u;
  group_uuid_ = value;
}
inline void CastLogsProto_CastEventProto::set_group_uuid(uint64_t value) {
  _internal_set_group_uuid(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.group_uuid)
}

// optional string conversation_key = 11;
inline bool CastLogsProto_CastEventProto::_internal_has_conversation_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_conversation_key() const {
  return _internal_has_conversation_key();
}
inline void CastLogsProto_CastEventProto::clear_conversation_key() {
  conversation_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CastLogsProto_CastEventProto::conversation_key() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.conversation_key)
  return _internal_conversation_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastEventProto::set_conversation_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 conversation_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.conversation_key)
}
inline std::string* CastLogsProto_CastEventProto::mutable_conversation_key() {
  std::string* _s = _internal_mutable_conversation_key();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastEventProto.conversation_key)
  return _s;
}
inline const std::string& CastLogsProto_CastEventProto::_internal_conversation_key() const {
  return conversation_key_.Get();
}
inline void CastLogsProto_CastEventProto::_internal_set_conversation_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  conversation_key_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastEventProto::_internal_mutable_conversation_key() {
  _has_bits_[0] |= 0x00000001u;
  return conversation_key_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastEventProto::release_conversation_key() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastEventProto.conversation_key)
  if (!_internal_has_conversation_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = conversation_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (conversation_key_.IsDefault()) {
    conversation_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastEventProto::set_allocated_conversation_key(std::string* conversation_key) {
  if (conversation_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  conversation_key_.SetAllocated(conversation_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (conversation_key_.IsDefault()) {
    conversation_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastEventProto.conversation_key)
}

// optional fixed32 request_id = 12;
inline bool CastLogsProto_CastEventProto::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_request_id() const {
  return _internal_has_request_id();
}
inline void CastLogsProto_CastEventProto::clear_request_id() {
  request_id_ = 0u;
  _has_bits_[0] &= ~0x00040000u;
}
inline uint32_t CastLogsProto_CastEventProto::_internal_request_id() const {
  return request_id_;
}
inline uint32_t CastLogsProto_CastEventProto::request_id() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.request_id)
  return _internal_request_id();
}
inline void CastLogsProto_CastEventProto::_internal_set_request_id(uint32_t value) {
  _has_bits_[0] |= 0x00040000u;
  request_id_ = value;
}
inline void CastLogsProto_CastEventProto::set_request_id(uint32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.request_id)
}

// optional string event_id = 13;
inline bool CastLogsProto_CastEventProto::_internal_has_event_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_event_id() const {
  return _internal_has_event_id();
}
inline void CastLogsProto_CastEventProto::clear_event_id() {
  event_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CastLogsProto_CastEventProto::event_id() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.event_id)
  return _internal_event_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastEventProto::set_event_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 event_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.event_id)
}
inline std::string* CastLogsProto_CastEventProto::mutable_event_id() {
  std::string* _s = _internal_mutable_event_id();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastEventProto.event_id)
  return _s;
}
inline const std::string& CastLogsProto_CastEventProto::_internal_event_id() const {
  return event_id_.Get();
}
inline void CastLogsProto_CastEventProto::_internal_set_event_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  event_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastEventProto::_internal_mutable_event_id() {
  _has_bits_[0] |= 0x00000002u;
  return event_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastEventProto::release_event_id() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastEventProto.event_id)
  if (!_internal_has_event_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = event_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (event_id_.IsDefault()) {
    event_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastEventProto::set_allocated_event_id(std::string* event_id) {
  if (event_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  event_id_.SetAllocated(event_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (event_id_.IsDefault()) {
    event_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastEventProto.event_id)
}

// optional string aogh_request_id = 16;
inline bool CastLogsProto_CastEventProto::_internal_has_aogh_request_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_aogh_request_id() const {
  return _internal_has_aogh_request_id();
}
inline void CastLogsProto_CastEventProto::clear_aogh_request_id() {
  aogh_request_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CastLogsProto_CastEventProto::aogh_request_id() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.aogh_request_id)
  return _internal_aogh_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastEventProto::set_aogh_request_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 aogh_request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.aogh_request_id)
}
inline std::string* CastLogsProto_CastEventProto::mutable_aogh_request_id() {
  std::string* _s = _internal_mutable_aogh_request_id();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastEventProto.aogh_request_id)
  return _s;
}
inline const std::string& CastLogsProto_CastEventProto::_internal_aogh_request_id() const {
  return aogh_request_id_.Get();
}
inline void CastLogsProto_CastEventProto::_internal_set_aogh_request_id(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  aogh_request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastEventProto::_internal_mutable_aogh_request_id() {
  _has_bits_[0] |= 0x00000004u;
  return aogh_request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastEventProto::release_aogh_request_id() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastEventProto.aogh_request_id)
  if (!_internal_has_aogh_request_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = aogh_request_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (aogh_request_id_.IsDefault()) {
    aogh_request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastEventProto::set_allocated_aogh_request_id(std::string* aogh_request_id) {
  if (aogh_request_id != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  aogh_request_id_.SetAllocated(aogh_request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (aogh_request_id_.IsDefault()) {
    aogh_request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastEventProto.aogh_request_id)
}

// optional int64 aogh_local_device_id = 18;
inline bool CastLogsProto_CastEventProto::_internal_has_aogh_local_device_id() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_aogh_local_device_id() const {
  return _internal_has_aogh_local_device_id();
}
inline void CastLogsProto_CastEventProto::clear_aogh_local_device_id() {
  aogh_local_device_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00100000u;
}
inline int64_t CastLogsProto_CastEventProto::_internal_aogh_local_device_id() const {
  return aogh_local_device_id_;
}
inline int64_t CastLogsProto_CastEventProto::aogh_local_device_id() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.aogh_local_device_id)
  return _internal_aogh_local_device_id();
}
inline void CastLogsProto_CastEventProto::_internal_set_aogh_local_device_id(int64_t value) {
  _has_bits_[0] |= 0x00100000u;
  aogh_local_device_id_ = value;
}
inline void CastLogsProto_CastEventProto::set_aogh_local_device_id(int64_t value) {
  _internal_set_aogh_local_device_id(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.aogh_local_device_id)
}

// optional string aogh_agent_id = 21;
inline bool CastLogsProto_CastEventProto::_internal_has_aogh_agent_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_aogh_agent_id() const {
  return _internal_has_aogh_agent_id();
}
inline void CastLogsProto_CastEventProto::clear_aogh_agent_id() {
  aogh_agent_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CastLogsProto_CastEventProto::aogh_agent_id() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.aogh_agent_id)
  return _internal_aogh_agent_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastEventProto::set_aogh_agent_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 aogh_agent_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.aogh_agent_id)
}
inline std::string* CastLogsProto_CastEventProto::mutable_aogh_agent_id() {
  std::string* _s = _internal_mutable_aogh_agent_id();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastEventProto.aogh_agent_id)
  return _s;
}
inline const std::string& CastLogsProto_CastEventProto::_internal_aogh_agent_id() const {
  return aogh_agent_id_.Get();
}
inline void CastLogsProto_CastEventProto::_internal_set_aogh_agent_id(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  aogh_agent_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastEventProto::_internal_mutable_aogh_agent_id() {
  _has_bits_[0] |= 0x00000020u;
  return aogh_agent_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastEventProto::release_aogh_agent_id() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastEventProto.aogh_agent_id)
  if (!_internal_has_aogh_agent_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = aogh_agent_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (aogh_agent_id_.IsDefault()) {
    aogh_agent_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastEventProto::set_allocated_aogh_agent_id(std::string* aogh_agent_id) {
  if (aogh_agent_id != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  aogh_agent_id_.SetAllocated(aogh_agent_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (aogh_agent_id_.IsDefault()) {
    aogh_agent_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastEventProto.aogh_agent_id)
}

// optional string aogh_standard_agent_id = 28;
inline bool CastLogsProto_CastEventProto::_internal_has_aogh_standard_agent_id() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_aogh_standard_agent_id() const {
  return _internal_has_aogh_standard_agent_id();
}
inline void CastLogsProto_CastEventProto::clear_aogh_standard_agent_id() {
  aogh_standard_agent_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& CastLogsProto_CastEventProto::aogh_standard_agent_id() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.aogh_standard_agent_id)
  return _internal_aogh_standard_agent_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastEventProto::set_aogh_standard_agent_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 aogh_standard_agent_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.aogh_standard_agent_id)
}
inline std::string* CastLogsProto_CastEventProto::mutable_aogh_standard_agent_id() {
  std::string* _s = _internal_mutable_aogh_standard_agent_id();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastEventProto.aogh_standard_agent_id)
  return _s;
}
inline const std::string& CastLogsProto_CastEventProto::_internal_aogh_standard_agent_id() const {
  return aogh_standard_agent_id_.Get();
}
inline void CastLogsProto_CastEventProto::_internal_set_aogh_standard_agent_id(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  aogh_standard_agent_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastEventProto::_internal_mutable_aogh_standard_agent_id() {
  _has_bits_[0] |= 0x00000100u;
  return aogh_standard_agent_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastEventProto::release_aogh_standard_agent_id() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastEventProto.aogh_standard_agent_id)
  if (!_internal_has_aogh_standard_agent_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = aogh_standard_agent_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (aogh_standard_agent_id_.IsDefault()) {
    aogh_standard_agent_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastEventProto::set_allocated_aogh_standard_agent_id(std::string* aogh_standard_agent_id) {
  if (aogh_standard_agent_id != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  aogh_standard_agent_id_.SetAllocated(aogh_standard_agent_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (aogh_standard_agent_id_.IsDefault()) {
    aogh_standard_agent_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastEventProto.aogh_standard_agent_id)
}

// repeated .metrics.CastLogsProto.CastEventProto.Metadata metadata = 14;
inline int CastLogsProto_CastEventProto::_internal_metadata_size() const {
  return metadata_.size();
}
inline int CastLogsProto_CastEventProto::metadata_size() const {
  return _internal_metadata_size();
}
inline void CastLogsProto_CastEventProto::clear_metadata() {
  metadata_.Clear();
}
inline ::metrics::CastLogsProto_CastEventProto_Metadata* CastLogsProto_CastEventProto::mutable_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastEventProto.metadata)
  return metadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metrics::CastLogsProto_CastEventProto_Metadata >*
CastLogsProto_CastEventProto::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_list:metrics.CastLogsProto.CastEventProto.metadata)
  return &metadata_;
}
inline const ::metrics::CastLogsProto_CastEventProto_Metadata& CastLogsProto_CastEventProto::_internal_metadata(int index) const {
  return metadata_.Get(index);
}
inline const ::metrics::CastLogsProto_CastEventProto_Metadata& CastLogsProto_CastEventProto::metadata(int index) const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.metadata)
  return _internal_metadata(index);
}
inline ::metrics::CastLogsProto_CastEventProto_Metadata* CastLogsProto_CastEventProto::_internal_add_metadata() {
  return metadata_.Add();
}
inline ::metrics::CastLogsProto_CastEventProto_Metadata* CastLogsProto_CastEventProto::add_metadata() {
  ::metrics::CastLogsProto_CastEventProto_Metadata* _add = _internal_add_metadata();
  // @@protoc_insertion_point(field_add:metrics.CastLogsProto.CastEventProto.metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metrics::CastLogsProto_CastEventProto_Metadata >&
CastLogsProto_CastEventProto::metadata() const {
  // @@protoc_insertion_point(field_list:metrics.CastLogsProto.CastEventProto.metadata)
  return metadata_;
}

// repeated float feature_vector = 15;
inline int CastLogsProto_CastEventProto::_internal_feature_vector_size() const {
  return feature_vector_.size();
}
inline int CastLogsProto_CastEventProto::feature_vector_size() const {
  return _internal_feature_vector_size();
}
inline void CastLogsProto_CastEventProto::clear_feature_vector() {
  feature_vector_.Clear();
}
inline float CastLogsProto_CastEventProto::_internal_feature_vector(int index) const {
  return feature_vector_.Get(index);
}
inline float CastLogsProto_CastEventProto::feature_vector(int index) const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.feature_vector)
  return _internal_feature_vector(index);
}
inline void CastLogsProto_CastEventProto::set_feature_vector(int index, float value) {
  feature_vector_.Set(index, value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.feature_vector)
}
inline void CastLogsProto_CastEventProto::_internal_add_feature_vector(float value) {
  feature_vector_.Add(value);
}
inline void CastLogsProto_CastEventProto::add_feature_vector(float value) {
  _internal_add_feature_vector(value);
  // @@protoc_insertion_point(field_add:metrics.CastLogsProto.CastEventProto.feature_vector)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
CastLogsProto_CastEventProto::_internal_feature_vector() const {
  return feature_vector_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
CastLogsProto_CastEventProto::feature_vector() const {
  // @@protoc_insertion_point(field_list:metrics.CastLogsProto.CastEventProto.feature_vector)
  return _internal_feature_vector();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
CastLogsProto_CastEventProto::_internal_mutable_feature_vector() {
  return &feature_vector_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
CastLogsProto_CastEventProto::mutable_feature_vector() {
  // @@protoc_insertion_point(field_mutable_list:metrics.CastLogsProto.CastEventProto.feature_vector)
  return _internal_mutable_feature_vector();
}

// optional string timezone_id = 17;
inline bool CastLogsProto_CastEventProto::_internal_has_timezone_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_timezone_id() const {
  return _internal_has_timezone_id();
}
inline void CastLogsProto_CastEventProto::clear_timezone_id() {
  timezone_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CastLogsProto_CastEventProto::timezone_id() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.timezone_id)
  return _internal_timezone_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastEventProto::set_timezone_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 timezone_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.timezone_id)
}
inline std::string* CastLogsProto_CastEventProto::mutable_timezone_id() {
  std::string* _s = _internal_mutable_timezone_id();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastEventProto.timezone_id)
  return _s;
}
inline const std::string& CastLogsProto_CastEventProto::_internal_timezone_id() const {
  return timezone_id_.Get();
}
inline void CastLogsProto_CastEventProto::_internal_set_timezone_id(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  timezone_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastEventProto::_internal_mutable_timezone_id() {
  _has_bits_[0] |= 0x00000008u;
  return timezone_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastEventProto::release_timezone_id() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastEventProto.timezone_id)
  if (!_internal_has_timezone_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = timezone_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (timezone_id_.IsDefault()) {
    timezone_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastEventProto::set_allocated_timezone_id(std::string* timezone_id) {
  if (timezone_id != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  timezone_id_.SetAllocated(timezone_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (timezone_id_.IsDefault()) {
    timezone_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastEventProto.timezone_id)
}

// optional string ui_version = 20;
inline bool CastLogsProto_CastEventProto::_internal_has_ui_version() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_ui_version() const {
  return _internal_has_ui_version();
}
inline void CastLogsProto_CastEventProto::clear_ui_version() {
  ui_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CastLogsProto_CastEventProto::ui_version() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.ui_version)
  return _internal_ui_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastEventProto::set_ui_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 ui_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.ui_version)
}
inline std::string* CastLogsProto_CastEventProto::mutable_ui_version() {
  std::string* _s = _internal_mutable_ui_version();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastEventProto.ui_version)
  return _s;
}
inline const std::string& CastLogsProto_CastEventProto::_internal_ui_version() const {
  return ui_version_.Get();
}
inline void CastLogsProto_CastEventProto::_internal_set_ui_version(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  ui_version_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastEventProto::_internal_mutable_ui_version() {
  _has_bits_[0] |= 0x00000010u;
  return ui_version_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastEventProto::release_ui_version() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastEventProto.ui_version)
  if (!_internal_has_ui_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = ui_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ui_version_.IsDefault()) {
    ui_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastEventProto::set_allocated_ui_version(std::string* ui_version) {
  if (ui_version != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  ui_version_.SetAllocated(ui_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ui_version_.IsDefault()) {
    ui_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastEventProto.ui_version)
}

// optional string selinux_audit_detail = 22;
inline bool CastLogsProto_CastEventProto::_internal_has_selinux_audit_detail() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_selinux_audit_detail() const {
  return _internal_has_selinux_audit_detail();
}
inline void CastLogsProto_CastEventProto::clear_selinux_audit_detail() {
  selinux_audit_detail_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& CastLogsProto_CastEventProto::selinux_audit_detail() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.selinux_audit_detail)
  return _internal_selinux_audit_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastEventProto::set_selinux_audit_detail(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 selinux_audit_detail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.selinux_audit_detail)
}
inline std::string* CastLogsProto_CastEventProto::mutable_selinux_audit_detail() {
  std::string* _s = _internal_mutable_selinux_audit_detail();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastEventProto.selinux_audit_detail)
  return _s;
}
inline const std::string& CastLogsProto_CastEventProto::_internal_selinux_audit_detail() const {
  return selinux_audit_detail_.Get();
}
inline void CastLogsProto_CastEventProto::_internal_set_selinux_audit_detail(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  selinux_audit_detail_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastEventProto::_internal_mutable_selinux_audit_detail() {
  _has_bits_[0] |= 0x00000040u;
  return selinux_audit_detail_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastEventProto::release_selinux_audit_detail() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastEventProto.selinux_audit_detail)
  if (!_internal_has_selinux_audit_detail()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = selinux_audit_detail_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (selinux_audit_detail_.IsDefault()) {
    selinux_audit_detail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastEventProto::set_allocated_selinux_audit_detail(std::string* selinux_audit_detail) {
  if (selinux_audit_detail != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  selinux_audit_detail_.SetAllocated(selinux_audit_detail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (selinux_audit_detail_.IsDefault()) {
    selinux_audit_detail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastEventProto.selinux_audit_detail)
}

// repeated string event_id_list = 23;
inline int CastLogsProto_CastEventProto::_internal_event_id_list_size() const {
  return event_id_list_.size();
}
inline int CastLogsProto_CastEventProto::event_id_list_size() const {
  return _internal_event_id_list_size();
}
inline void CastLogsProto_CastEventProto::clear_event_id_list() {
  event_id_list_.Clear();
}
inline std::string* CastLogsProto_CastEventProto::add_event_id_list() {
  std::string* _s = _internal_add_event_id_list();
  // @@protoc_insertion_point(field_add_mutable:metrics.CastLogsProto.CastEventProto.event_id_list)
  return _s;
}
inline const std::string& CastLogsProto_CastEventProto::_internal_event_id_list(int index) const {
  return event_id_list_.Get(index);
}
inline const std::string& CastLogsProto_CastEventProto::event_id_list(int index) const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.event_id_list)
  return _internal_event_id_list(index);
}
inline std::string* CastLogsProto_CastEventProto::mutable_event_id_list(int index) {
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastEventProto.event_id_list)
  return event_id_list_.Mutable(index);
}
inline void CastLogsProto_CastEventProto::set_event_id_list(int index, const std::string& value) {
  event_id_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.event_id_list)
}
inline void CastLogsProto_CastEventProto::set_event_id_list(int index, std::string&& value) {
  event_id_list_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.event_id_list)
}
inline void CastLogsProto_CastEventProto::set_event_id_list(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  event_id_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:metrics.CastLogsProto.CastEventProto.event_id_list)
}
inline void CastLogsProto_CastEventProto::set_event_id_list(int index, const char* value, size_t size) {
  event_id_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:metrics.CastLogsProto.CastEventProto.event_id_list)
}
inline std::string* CastLogsProto_CastEventProto::_internal_add_event_id_list() {
  return event_id_list_.Add();
}
inline void CastLogsProto_CastEventProto::add_event_id_list(const std::string& value) {
  event_id_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:metrics.CastLogsProto.CastEventProto.event_id_list)
}
inline void CastLogsProto_CastEventProto::add_event_id_list(std::string&& value) {
  event_id_list_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:metrics.CastLogsProto.CastEventProto.event_id_list)
}
inline void CastLogsProto_CastEventProto::add_event_id_list(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  event_id_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:metrics.CastLogsProto.CastEventProto.event_id_list)
}
inline void CastLogsProto_CastEventProto::add_event_id_list(const char* value, size_t size) {
  event_id_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:metrics.CastLogsProto.CastEventProto.event_id_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CastLogsProto_CastEventProto::event_id_list() const {
  // @@protoc_insertion_point(field_list:metrics.CastLogsProto.CastEventProto.event_id_list)
  return event_id_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CastLogsProto_CastEventProto::mutable_event_id_list() {
  // @@protoc_insertion_point(field_mutable_list:metrics.CastLogsProto.CastEventProto.event_id_list)
  return &event_id_list_;
}

// optional fixed64 duo_core_version = 24;
inline bool CastLogsProto_CastEventProto::_internal_has_duo_core_version() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_duo_core_version() const {
  return _internal_has_duo_core_version();
}
inline void CastLogsProto_CastEventProto::clear_duo_core_version() {
  duo_core_version_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00800000u;
}
inline uint64_t CastLogsProto_CastEventProto::_internal_duo_core_version() const {
  return duo_core_version_;
}
inline uint64_t CastLogsProto_CastEventProto::duo_core_version() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.duo_core_version)
  return _internal_duo_core_version();
}
inline void CastLogsProto_CastEventProto::_internal_set_duo_core_version(uint64_t value) {
  _has_bits_[0] |= 0x00800000u;
  duo_core_version_ = value;
}
inline void CastLogsProto_CastEventProto::set_duo_core_version(uint64_t value) {
  _internal_set_duo_core_version(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.duo_core_version)
}

// optional string hotword_model_id = 25;
inline bool CastLogsProto_CastEventProto::_internal_has_hotword_model_id() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_hotword_model_id() const {
  return _internal_has_hotword_model_id();
}
inline void CastLogsProto_CastEventProto::clear_hotword_model_id() {
  hotword_model_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& CastLogsProto_CastEventProto::hotword_model_id() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.hotword_model_id)
  return _internal_hotword_model_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastEventProto::set_hotword_model_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 hotword_model_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.hotword_model_id)
}
inline std::string* CastLogsProto_CastEventProto::mutable_hotword_model_id() {
  std::string* _s = _internal_mutable_hotword_model_id();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastEventProto.hotword_model_id)
  return _s;
}
inline const std::string& CastLogsProto_CastEventProto::_internal_hotword_model_id() const {
  return hotword_model_id_.Get();
}
inline void CastLogsProto_CastEventProto::_internal_set_hotword_model_id(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  hotword_model_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastEventProto::_internal_mutable_hotword_model_id() {
  _has_bits_[0] |= 0x00000080u;
  return hotword_model_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastEventProto::release_hotword_model_id() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastEventProto.hotword_model_id)
  if (!_internal_has_hotword_model_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = hotword_model_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hotword_model_id_.IsDefault()) {
    hotword_model_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastEventProto::set_allocated_hotword_model_id(std::string* hotword_model_id) {
  if (hotword_model_id != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  hotword_model_id_.SetAllocated(hotword_model_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hotword_model_id_.IsDefault()) {
    hotword_model_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastEventProto.hotword_model_id)
}

// optional .metrics.CastLogsProto.CastEventProto.LaunchFrom launch_from = 26;
inline bool CastLogsProto_CastEventProto::_internal_has_launch_from() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_launch_from() const {
  return _internal_has_launch_from();
}
inline void CastLogsProto_CastEventProto::clear_launch_from() {
  launch_from_ = 0;
  _has_bits_[0] &= ~0x00400000u;
}
inline ::metrics::CastLogsProto_CastEventProto_LaunchFrom CastLogsProto_CastEventProto::_internal_launch_from() const {
  return static_cast< ::metrics::CastLogsProto_CastEventProto_LaunchFrom >(launch_from_);
}
inline ::metrics::CastLogsProto_CastEventProto_LaunchFrom CastLogsProto_CastEventProto::launch_from() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.launch_from)
  return _internal_launch_from();
}
inline void CastLogsProto_CastEventProto::_internal_set_launch_from(::metrics::CastLogsProto_CastEventProto_LaunchFrom value) {
  assert(::metrics::CastLogsProto_CastEventProto_LaunchFrom_IsValid(value));
  _has_bits_[0] |= 0x00400000u;
  launch_from_ = value;
}
inline void CastLogsProto_CastEventProto::set_launch_from(::metrics::CastLogsProto_CastEventProto_LaunchFrom value) {
  _internal_set_launch_from(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.launch_from)
}

// optional .metrics.CastLogsProto.CastEventProto.RuntimeType runtime_type = 27;
inline bool CastLogsProto_CastEventProto::_internal_has_runtime_type() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool CastLogsProto_CastEventProto::has_runtime_type() const {
  return _internal_has_runtime_type();
}
inline void CastLogsProto_CastEventProto::clear_runtime_type() {
  runtime_type_ = 0;
  _has_bits_[0] &= ~0x01000000u;
}
inline ::metrics::CastLogsProto_CastEventProto_RuntimeType CastLogsProto_CastEventProto::_internal_runtime_type() const {
  return static_cast< ::metrics::CastLogsProto_CastEventProto_RuntimeType >(runtime_type_);
}
inline ::metrics::CastLogsProto_CastEventProto_RuntimeType CastLogsProto_CastEventProto::runtime_type() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastEventProto.runtime_type)
  return _internal_runtime_type();
}
inline void CastLogsProto_CastEventProto::_internal_set_runtime_type(::metrics::CastLogsProto_CastEventProto_RuntimeType value) {
  assert(::metrics::CastLogsProto_CastEventProto_RuntimeType_IsValid(value));
  _has_bits_[0] |= 0x01000000u;
  runtime_type_ = value;
}
inline void CastLogsProto_CastEventProto::set_runtime_type(::metrics::CastLogsProto_CastEventProto_RuntimeType value) {
  _internal_set_runtime_type(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastEventProto.runtime_type)
}

// -------------------------------------------------------------------

// CastLogsProto_CastDeviceMutableInfo

// optional .metrics.CastLogsProto.CastDeviceMutableInfo.RebootType last_reboot_type = 1;
inline bool CastLogsProto_CastDeviceMutableInfo::_internal_has_last_reboot_type() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceMutableInfo::has_last_reboot_type() const {
  return _internal_has_last_reboot_type();
}
inline void CastLogsProto_CastDeviceMutableInfo::clear_last_reboot_type() {
  last_reboot_type_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::metrics::CastLogsProto_CastDeviceMutableInfo_RebootType CastLogsProto_CastDeviceMutableInfo::_internal_last_reboot_type() const {
  return static_cast< ::metrics::CastLogsProto_CastDeviceMutableInfo_RebootType >(last_reboot_type_);
}
inline ::metrics::CastLogsProto_CastDeviceMutableInfo_RebootType CastLogsProto_CastDeviceMutableInfo::last_reboot_type() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceMutableInfo.last_reboot_type)
  return _internal_last_reboot_type();
}
inline void CastLogsProto_CastDeviceMutableInfo::_internal_set_last_reboot_type(::metrics::CastLogsProto_CastDeviceMutableInfo_RebootType value) {
  assert(::metrics::CastLogsProto_CastDeviceMutableInfo_RebootType_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  last_reboot_type_ = value;
}
inline void CastLogsProto_CastDeviceMutableInfo::set_last_reboot_type(::metrics::CastLogsProto_CastDeviceMutableInfo_RebootType value) {
  _internal_set_last_reboot_type(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceMutableInfo.last_reboot_type)
}

// optional fixed64 system_build_number = 2;
inline bool CastLogsProto_CastDeviceMutableInfo::_internal_has_system_build_number() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceMutableInfo::has_system_build_number() const {
  return _internal_has_system_build_number();
}
inline void CastLogsProto_CastDeviceMutableInfo::clear_system_build_number() {
  system_build_number_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000040u;
}
inline uint64_t CastLogsProto_CastDeviceMutableInfo::_internal_system_build_number() const {
  return system_build_number_;
}
inline uint64_t CastLogsProto_CastDeviceMutableInfo::system_build_number() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceMutableInfo.system_build_number)
  return _internal_system_build_number();
}
inline void CastLogsProto_CastDeviceMutableInfo::_internal_set_system_build_number(uint64_t value) {
  _has_bits_[0] |= 0x00000040u;
  system_build_number_ = value;
}
inline void CastLogsProto_CastDeviceMutableInfo::set_system_build_number(uint64_t value) {
  _internal_set_system_build_number(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceMutableInfo.system_build_number)
}

// optional string backdrop_app_device_id = 3;
inline bool CastLogsProto_CastDeviceMutableInfo::_internal_has_backdrop_app_device_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceMutableInfo::has_backdrop_app_device_id() const {
  return _internal_has_backdrop_app_device_id();
}
inline void CastLogsProto_CastDeviceMutableInfo::clear_backdrop_app_device_id() {
  backdrop_app_device_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CastLogsProto_CastDeviceMutableInfo::backdrop_app_device_id() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceMutableInfo.backdrop_app_device_id)
  return _internal_backdrop_app_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastDeviceMutableInfo::set_backdrop_app_device_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 backdrop_app_device_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceMutableInfo.backdrop_app_device_id)
}
inline std::string* CastLogsProto_CastDeviceMutableInfo::mutable_backdrop_app_device_id() {
  std::string* _s = _internal_mutable_backdrop_app_device_id();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastDeviceMutableInfo.backdrop_app_device_id)
  return _s;
}
inline const std::string& CastLogsProto_CastDeviceMutableInfo::_internal_backdrop_app_device_id() const {
  return backdrop_app_device_id_.Get();
}
inline void CastLogsProto_CastDeviceMutableInfo::_internal_set_backdrop_app_device_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  backdrop_app_device_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceMutableInfo::_internal_mutable_backdrop_app_device_id() {
  _has_bits_[0] |= 0x00000001u;
  return backdrop_app_device_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceMutableInfo::release_backdrop_app_device_id() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastDeviceMutableInfo.backdrop_app_device_id)
  if (!_internal_has_backdrop_app_device_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = backdrop_app_device_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (backdrop_app_device_id_.IsDefault()) {
    backdrop_app_device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastDeviceMutableInfo::set_allocated_backdrop_app_device_id(std::string* backdrop_app_device_id) {
  if (backdrop_app_device_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  backdrop_app_device_id_.SetAllocated(backdrop_app_device_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (backdrop_app_device_id_.IsDefault()) {
    backdrop_app_device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastDeviceMutableInfo.backdrop_app_device_id)
}

// optional fixed32 release_version = 4;
inline bool CastLogsProto_CastDeviceMutableInfo::_internal_has_release_version() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceMutableInfo::has_release_version() const {
  return _internal_has_release_version();
}
inline void CastLogsProto_CastDeviceMutableInfo::clear_release_version() {
  release_version_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline uint32_t CastLogsProto_CastDeviceMutableInfo::_internal_release_version() const {
  return release_version_;
}
inline uint32_t CastLogsProto_CastDeviceMutableInfo::release_version() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceMutableInfo.release_version)
  return _internal_release_version();
}
inline void CastLogsProto_CastDeviceMutableInfo::_internal_set_release_version(uint32_t value) {
  _has_bits_[0] |= 0x00000100u;
  release_version_ = value;
}
inline void CastLogsProto_CastDeviceMutableInfo::set_release_version(uint32_t value) {
  _internal_set_release_version(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceMutableInfo.release_version)
}

// optional .metrics.CastLogsProto.CastDeviceMutableInfo.NetifIPVersion netif_ip_version = 5;
inline bool CastLogsProto_CastDeviceMutableInfo::_internal_has_netif_ip_version() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceMutableInfo::has_netif_ip_version() const {
  return _internal_has_netif_ip_version();
}
inline void CastLogsProto_CastDeviceMutableInfo::clear_netif_ip_version() {
  netif_ip_version_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::metrics::CastLogsProto_CastDeviceMutableInfo_NetifIPVersion CastLogsProto_CastDeviceMutableInfo::_internal_netif_ip_version() const {
  return static_cast< ::metrics::CastLogsProto_CastDeviceMutableInfo_NetifIPVersion >(netif_ip_version_);
}
inline ::metrics::CastLogsProto_CastDeviceMutableInfo_NetifIPVersion CastLogsProto_CastDeviceMutableInfo::netif_ip_version() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceMutableInfo.netif_ip_version)
  return _internal_netif_ip_version();
}
inline void CastLogsProto_CastDeviceMutableInfo::_internal_set_netif_ip_version(::metrics::CastLogsProto_CastDeviceMutableInfo_NetifIPVersion value) {
  assert(::metrics::CastLogsProto_CastDeviceMutableInfo_NetifIPVersion_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  netif_ip_version_ = value;
}
inline void CastLogsProto_CastDeviceMutableInfo::set_netif_ip_version(::metrics::CastLogsProto_CastDeviceMutableInfo_NetifIPVersion value) {
  _internal_set_netif_ip_version(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceMutableInfo.netif_ip_version)
}

// optional bool ip_dual_stack_supported = 6;
inline bool CastLogsProto_CastDeviceMutableInfo::_internal_has_ip_dual_stack_supported() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceMutableInfo::has_ip_dual_stack_supported() const {
  return _internal_has_ip_dual_stack_supported();
}
inline void CastLogsProto_CastDeviceMutableInfo::clear_ip_dual_stack_supported() {
  ip_dual_stack_supported_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool CastLogsProto_CastDeviceMutableInfo::_internal_ip_dual_stack_supported() const {
  return ip_dual_stack_supported_;
}
inline bool CastLogsProto_CastDeviceMutableInfo::ip_dual_stack_supported() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceMutableInfo.ip_dual_stack_supported)
  return _internal_ip_dual_stack_supported();
}
inline void CastLogsProto_CastDeviceMutableInfo::_internal_set_ip_dual_stack_supported(bool value) {
  _has_bits_[0] |= 0x00000400u;
  ip_dual_stack_supported_ = value;
}
inline void CastLogsProto_CastDeviceMutableInfo::set_ip_dual_stack_supported(bool value) {
  _internal_set_ip_dual_stack_supported(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceMutableInfo.ip_dual_stack_supported)
}

// optional string timezone_id = 7;
inline bool CastLogsProto_CastDeviceMutableInfo::_internal_has_timezone_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceMutableInfo::has_timezone_id() const {
  return _internal_has_timezone_id();
}
inline void CastLogsProto_CastDeviceMutableInfo::clear_timezone_id() {
  timezone_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CastLogsProto_CastDeviceMutableInfo::timezone_id() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceMutableInfo.timezone_id)
  return _internal_timezone_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastDeviceMutableInfo::set_timezone_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 timezone_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceMutableInfo.timezone_id)
}
inline std::string* CastLogsProto_CastDeviceMutableInfo::mutable_timezone_id() {
  std::string* _s = _internal_mutable_timezone_id();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastDeviceMutableInfo.timezone_id)
  return _s;
}
inline const std::string& CastLogsProto_CastDeviceMutableInfo::_internal_timezone_id() const {
  return timezone_id_.Get();
}
inline void CastLogsProto_CastDeviceMutableInfo::_internal_set_timezone_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  timezone_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceMutableInfo::_internal_mutable_timezone_id() {
  _has_bits_[0] |= 0x00000002u;
  return timezone_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceMutableInfo::release_timezone_id() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastDeviceMutableInfo.timezone_id)
  if (!_internal_has_timezone_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = timezone_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (timezone_id_.IsDefault()) {
    timezone_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastDeviceMutableInfo::set_allocated_timezone_id(std::string* timezone_id) {
  if (timezone_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  timezone_id_.SetAllocated(timezone_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (timezone_id_.IsDefault()) {
    timezone_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastDeviceMutableInfo.timezone_id)
}

// optional string latest_ui_version = 8;
inline bool CastLogsProto_CastDeviceMutableInfo::_internal_has_latest_ui_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceMutableInfo::has_latest_ui_version() const {
  return _internal_has_latest_ui_version();
}
inline void CastLogsProto_CastDeviceMutableInfo::clear_latest_ui_version() {
  latest_ui_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CastLogsProto_CastDeviceMutableInfo::latest_ui_version() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceMutableInfo.latest_ui_version)
  return _internal_latest_ui_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastDeviceMutableInfo::set_latest_ui_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 latest_ui_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceMutableInfo.latest_ui_version)
}
inline std::string* CastLogsProto_CastDeviceMutableInfo::mutable_latest_ui_version() {
  std::string* _s = _internal_mutable_latest_ui_version();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastDeviceMutableInfo.latest_ui_version)
  return _s;
}
inline const std::string& CastLogsProto_CastDeviceMutableInfo::_internal_latest_ui_version() const {
  return latest_ui_version_.Get();
}
inline void CastLogsProto_CastDeviceMutableInfo::_internal_set_latest_ui_version(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  latest_ui_version_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceMutableInfo::_internal_mutable_latest_ui_version() {
  _has_bits_[0] |= 0x00000004u;
  return latest_ui_version_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceMutableInfo::release_latest_ui_version() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastDeviceMutableInfo.latest_ui_version)
  if (!_internal_has_latest_ui_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = latest_ui_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (latest_ui_version_.IsDefault()) {
    latest_ui_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastDeviceMutableInfo::set_allocated_latest_ui_version(std::string* latest_ui_version) {
  if (latest_ui_version != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  latest_ui_version_.SetAllocated(latest_ui_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (latest_ui_version_.IsDefault()) {
    latest_ui_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastDeviceMutableInfo.latest_ui_version)
}

// optional string google_wifi_station_shmac = 9;
inline bool CastLogsProto_CastDeviceMutableInfo::_internal_has_google_wifi_station_shmac() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceMutableInfo::has_google_wifi_station_shmac() const {
  return _internal_has_google_wifi_station_shmac();
}
inline void CastLogsProto_CastDeviceMutableInfo::clear_google_wifi_station_shmac() {
  google_wifi_station_shmac_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CastLogsProto_CastDeviceMutableInfo::google_wifi_station_shmac() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceMutableInfo.google_wifi_station_shmac)
  return _internal_google_wifi_station_shmac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastDeviceMutableInfo::set_google_wifi_station_shmac(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 google_wifi_station_shmac_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceMutableInfo.google_wifi_station_shmac)
}
inline std::string* CastLogsProto_CastDeviceMutableInfo::mutable_google_wifi_station_shmac() {
  std::string* _s = _internal_mutable_google_wifi_station_shmac();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastDeviceMutableInfo.google_wifi_station_shmac)
  return _s;
}
inline const std::string& CastLogsProto_CastDeviceMutableInfo::_internal_google_wifi_station_shmac() const {
  return google_wifi_station_shmac_.Get();
}
inline void CastLogsProto_CastDeviceMutableInfo::_internal_set_google_wifi_station_shmac(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  google_wifi_station_shmac_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceMutableInfo::_internal_mutable_google_wifi_station_shmac() {
  _has_bits_[0] |= 0x00000008u;
  return google_wifi_station_shmac_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceMutableInfo::release_google_wifi_station_shmac() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastDeviceMutableInfo.google_wifi_station_shmac)
  if (!_internal_has_google_wifi_station_shmac()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = google_wifi_station_shmac_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (google_wifi_station_shmac_.IsDefault()) {
    google_wifi_station_shmac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastDeviceMutableInfo::set_allocated_google_wifi_station_shmac(std::string* google_wifi_station_shmac) {
  if (google_wifi_station_shmac != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  google_wifi_station_shmac_.SetAllocated(google_wifi_station_shmac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (google_wifi_station_shmac_.IsDefault()) {
    google_wifi_station_shmac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastDeviceMutableInfo.google_wifi_station_shmac)
}

// optional string installed_manifest_platform_version = 10;
inline bool CastLogsProto_CastDeviceMutableInfo::_internal_has_installed_manifest_platform_version() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceMutableInfo::has_installed_manifest_platform_version() const {
  return _internal_has_installed_manifest_platform_version();
}
inline void CastLogsProto_CastDeviceMutableInfo::clear_installed_manifest_platform_version() {
  installed_manifest_platform_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CastLogsProto_CastDeviceMutableInfo::installed_manifest_platform_version() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceMutableInfo.installed_manifest_platform_version)
  return _internal_installed_manifest_platform_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastDeviceMutableInfo::set_installed_manifest_platform_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 installed_manifest_platform_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceMutableInfo.installed_manifest_platform_version)
}
inline std::string* CastLogsProto_CastDeviceMutableInfo::mutable_installed_manifest_platform_version() {
  std::string* _s = _internal_mutable_installed_manifest_platform_version();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastDeviceMutableInfo.installed_manifest_platform_version)
  return _s;
}
inline const std::string& CastLogsProto_CastDeviceMutableInfo::_internal_installed_manifest_platform_version() const {
  return installed_manifest_platform_version_.Get();
}
inline void CastLogsProto_CastDeviceMutableInfo::_internal_set_installed_manifest_platform_version(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  installed_manifest_platform_version_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceMutableInfo::_internal_mutable_installed_manifest_platform_version() {
  _has_bits_[0] |= 0x00000010u;
  return installed_manifest_platform_version_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceMutableInfo::release_installed_manifest_platform_version() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastDeviceMutableInfo.installed_manifest_platform_version)
  if (!_internal_has_installed_manifest_platform_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = installed_manifest_platform_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (installed_manifest_platform_version_.IsDefault()) {
    installed_manifest_platform_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastDeviceMutableInfo::set_allocated_installed_manifest_platform_version(std::string* installed_manifest_platform_version) {
  if (installed_manifest_platform_version != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  installed_manifest_platform_version_.SetAllocated(installed_manifest_platform_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (installed_manifest_platform_version_.IsDefault()) {
    installed_manifest_platform_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastDeviceMutableInfo.installed_manifest_platform_version)
}

// optional uint32 installed_manifest_version = 11;
inline bool CastLogsProto_CastDeviceMutableInfo::_internal_has_installed_manifest_version() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceMutableInfo::has_installed_manifest_version() const {
  return _internal_has_installed_manifest_version();
}
inline void CastLogsProto_CastDeviceMutableInfo::clear_installed_manifest_version() {
  installed_manifest_version_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline uint32_t CastLogsProto_CastDeviceMutableInfo::_internal_installed_manifest_version() const {
  return installed_manifest_version_;
}
inline uint32_t CastLogsProto_CastDeviceMutableInfo::installed_manifest_version() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceMutableInfo.installed_manifest_version)
  return _internal_installed_manifest_version();
}
inline void CastLogsProto_CastDeviceMutableInfo::_internal_set_installed_manifest_version(uint32_t value) {
  _has_bits_[0] |= 0x00000800u;
  installed_manifest_version_ = value;
}
inline void CastLogsProto_CastDeviceMutableInfo::set_installed_manifest_version(uint32_t value) {
  _internal_set_installed_manifest_version(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceMutableInfo.installed_manifest_version)
}

// optional string system_bundle_version = 12;
inline bool CastLogsProto_CastDeviceMutableInfo::_internal_has_system_bundle_version() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CastLogsProto_CastDeviceMutableInfo::has_system_bundle_version() const {
  return _internal_has_system_bundle_version();
}
inline void CastLogsProto_CastDeviceMutableInfo::clear_system_bundle_version() {
  system_bundle_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CastLogsProto_CastDeviceMutableInfo::system_bundle_version() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.CastDeviceMutableInfo.system_bundle_version)
  return _internal_system_bundle_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CastLogsProto_CastDeviceMutableInfo::set_system_bundle_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 system_bundle_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.CastDeviceMutableInfo.system_bundle_version)
}
inline std::string* CastLogsProto_CastDeviceMutableInfo::mutable_system_bundle_version() {
  std::string* _s = _internal_mutable_system_bundle_version();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.CastDeviceMutableInfo.system_bundle_version)
  return _s;
}
inline const std::string& CastLogsProto_CastDeviceMutableInfo::_internal_system_bundle_version() const {
  return system_bundle_version_.Get();
}
inline void CastLogsProto_CastDeviceMutableInfo::_internal_set_system_bundle_version(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  system_bundle_version_.Set(value, GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceMutableInfo::_internal_mutable_system_bundle_version() {
  _has_bits_[0] |= 0x00000020u;
  return system_bundle_version_.Mutable(GetArenaForAllocation());
}
inline std::string* CastLogsProto_CastDeviceMutableInfo::release_system_bundle_version() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.CastDeviceMutableInfo.system_bundle_version)
  if (!_internal_has_system_bundle_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = system_bundle_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (system_bundle_version_.IsDefault()) {
    system_bundle_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CastLogsProto_CastDeviceMutableInfo::set_allocated_system_bundle_version(std::string* system_bundle_version) {
  if (system_bundle_version != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  system_bundle_version_.SetAllocated(system_bundle_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (system_bundle_version_.IsDefault()) {
    system_bundle_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.CastDeviceMutableInfo.system_bundle_version)
}

// -------------------------------------------------------------------

// CastLogsProto

// optional .metrics.CastLogsProto.CastDeviceInfo cast_device_info = 1;
inline bool CastLogsProto::_internal_has_cast_device_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || cast_device_info_ != nullptr);
  return value;
}
inline bool CastLogsProto::has_cast_device_info() const {
  return _internal_has_cast_device_info();
}
inline void CastLogsProto::clear_cast_device_info() {
  if (cast_device_info_ != nullptr) cast_device_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::metrics::CastLogsProto_CastDeviceInfo& CastLogsProto::_internal_cast_device_info() const {
  const ::metrics::CastLogsProto_CastDeviceInfo* p = cast_device_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::metrics::CastLogsProto_CastDeviceInfo&>(
      ::metrics::_CastLogsProto_CastDeviceInfo_default_instance_);
}
inline const ::metrics::CastLogsProto_CastDeviceInfo& CastLogsProto::cast_device_info() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.cast_device_info)
  return _internal_cast_device_info();
}
inline void CastLogsProto::unsafe_arena_set_allocated_cast_device_info(
    ::metrics::CastLogsProto_CastDeviceInfo* cast_device_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cast_device_info_);
  }
  cast_device_info_ = cast_device_info;
  if (cast_device_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:metrics.CastLogsProto.cast_device_info)
}
inline ::metrics::CastLogsProto_CastDeviceInfo* CastLogsProto::release_cast_device_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::metrics::CastLogsProto_CastDeviceInfo* temp = cast_device_info_;
  cast_device_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::metrics::CastLogsProto_CastDeviceInfo* CastLogsProto::unsafe_arena_release_cast_device_info() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.cast_device_info)
  _has_bits_[0] &= ~0x00000001u;
  ::metrics::CastLogsProto_CastDeviceInfo* temp = cast_device_info_;
  cast_device_info_ = nullptr;
  return temp;
}
inline ::metrics::CastLogsProto_CastDeviceInfo* CastLogsProto::_internal_mutable_cast_device_info() {
  _has_bits_[0] |= 0x00000001u;
  if (cast_device_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::metrics::CastLogsProto_CastDeviceInfo>(GetArenaForAllocation());
    cast_device_info_ = p;
  }
  return cast_device_info_;
}
inline ::metrics::CastLogsProto_CastDeviceInfo* CastLogsProto::mutable_cast_device_info() {
  ::metrics::CastLogsProto_CastDeviceInfo* _msg = _internal_mutable_cast_device_info();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.cast_device_info)
  return _msg;
}
inline void CastLogsProto::set_allocated_cast_device_info(::metrics::CastLogsProto_CastDeviceInfo* cast_device_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cast_device_info_;
  }
  if (cast_device_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cast_device_info);
    if (message_arena != submessage_arena) {
      cast_device_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cast_device_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cast_device_info_ = cast_device_info;
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.cast_device_info)
}

// repeated .metrics.CastLogsProto.CastConnectionInfo cast_connection_info = 2;
inline int CastLogsProto::_internal_cast_connection_info_size() const {
  return cast_connection_info_.size();
}
inline int CastLogsProto::cast_connection_info_size() const {
  return _internal_cast_connection_info_size();
}
inline void CastLogsProto::clear_cast_connection_info() {
  cast_connection_info_.Clear();
}
inline ::metrics::CastLogsProto_CastConnectionInfo* CastLogsProto::mutable_cast_connection_info(int index) {
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.cast_connection_info)
  return cast_connection_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metrics::CastLogsProto_CastConnectionInfo >*
CastLogsProto::mutable_cast_connection_info() {
  // @@protoc_insertion_point(field_mutable_list:metrics.CastLogsProto.cast_connection_info)
  return &cast_connection_info_;
}
inline const ::metrics::CastLogsProto_CastConnectionInfo& CastLogsProto::_internal_cast_connection_info(int index) const {
  return cast_connection_info_.Get(index);
}
inline const ::metrics::CastLogsProto_CastConnectionInfo& CastLogsProto::cast_connection_info(int index) const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.cast_connection_info)
  return _internal_cast_connection_info(index);
}
inline ::metrics::CastLogsProto_CastConnectionInfo* CastLogsProto::_internal_add_cast_connection_info() {
  return cast_connection_info_.Add();
}
inline ::metrics::CastLogsProto_CastConnectionInfo* CastLogsProto::add_cast_connection_info() {
  ::metrics::CastLogsProto_CastConnectionInfo* _add = _internal_add_cast_connection_info();
  // @@protoc_insertion_point(field_add:metrics.CastLogsProto.cast_connection_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metrics::CastLogsProto_CastConnectionInfo >&
CastLogsProto::cast_connection_info() const {
  // @@protoc_insertion_point(field_list:metrics.CastLogsProto.cast_connection_info)
  return cast_connection_info_;
}

// repeated .metrics.CastLogsProto.CastEventProto cast_event = 3;
inline int CastLogsProto::_internal_cast_event_size() const {
  return cast_event_.size();
}
inline int CastLogsProto::cast_event_size() const {
  return _internal_cast_event_size();
}
inline void CastLogsProto::clear_cast_event() {
  cast_event_.Clear();
}
inline ::metrics::CastLogsProto_CastEventProto* CastLogsProto::mutable_cast_event(int index) {
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.cast_event)
  return cast_event_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metrics::CastLogsProto_CastEventProto >*
CastLogsProto::mutable_cast_event() {
  // @@protoc_insertion_point(field_mutable_list:metrics.CastLogsProto.cast_event)
  return &cast_event_;
}
inline const ::metrics::CastLogsProto_CastEventProto& CastLogsProto::_internal_cast_event(int index) const {
  return cast_event_.Get(index);
}
inline const ::metrics::CastLogsProto_CastEventProto& CastLogsProto::cast_event(int index) const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.cast_event)
  return _internal_cast_event(index);
}
inline ::metrics::CastLogsProto_CastEventProto* CastLogsProto::_internal_add_cast_event() {
  return cast_event_.Add();
}
inline ::metrics::CastLogsProto_CastEventProto* CastLogsProto::add_cast_event() {
  ::metrics::CastLogsProto_CastEventProto* _add = _internal_add_cast_event();
  // @@protoc_insertion_point(field_add:metrics.CastLogsProto.cast_event)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metrics::CastLogsProto_CastEventProto >&
CastLogsProto::cast_event() const {
  // @@protoc_insertion_point(field_list:metrics.CastLogsProto.cast_event)
  return cast_event_;
}

// optional fixed32 virtual_release_track = 4;
inline bool CastLogsProto::_internal_has_virtual_release_track() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CastLogsProto::has_virtual_release_track() const {
  return _internal_has_virtual_release_track();
}
inline void CastLogsProto::clear_virtual_release_track() {
  virtual_release_track_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CastLogsProto::_internal_virtual_release_track() const {
  return virtual_release_track_;
}
inline uint32_t CastLogsProto::virtual_release_track() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.virtual_release_track)
  return _internal_virtual_release_track();
}
inline void CastLogsProto::_internal_set_virtual_release_track(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  virtual_release_track_ = value;
}
inline void CastLogsProto::set_virtual_release_track(uint32_t value) {
  _internal_set_virtual_release_track(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.virtual_release_track)
}

// optional .metrics.CastLogsProto.CastDeviceMutableInfo cast_device_mutable_info = 5;
inline bool CastLogsProto::_internal_has_cast_device_mutable_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || cast_device_mutable_info_ != nullptr);
  return value;
}
inline bool CastLogsProto::has_cast_device_mutable_info() const {
  return _internal_has_cast_device_mutable_info();
}
inline void CastLogsProto::clear_cast_device_mutable_info() {
  if (cast_device_mutable_info_ != nullptr) cast_device_mutable_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::metrics::CastLogsProto_CastDeviceMutableInfo& CastLogsProto::_internal_cast_device_mutable_info() const {
  const ::metrics::CastLogsProto_CastDeviceMutableInfo* p = cast_device_mutable_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::metrics::CastLogsProto_CastDeviceMutableInfo&>(
      ::metrics::_CastLogsProto_CastDeviceMutableInfo_default_instance_);
}
inline const ::metrics::CastLogsProto_CastDeviceMutableInfo& CastLogsProto::cast_device_mutable_info() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.cast_device_mutable_info)
  return _internal_cast_device_mutable_info();
}
inline void CastLogsProto::unsafe_arena_set_allocated_cast_device_mutable_info(
    ::metrics::CastLogsProto_CastDeviceMutableInfo* cast_device_mutable_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cast_device_mutable_info_);
  }
  cast_device_mutable_info_ = cast_device_mutable_info;
  if (cast_device_mutable_info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:metrics.CastLogsProto.cast_device_mutable_info)
}
inline ::metrics::CastLogsProto_CastDeviceMutableInfo* CastLogsProto::release_cast_device_mutable_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::metrics::CastLogsProto_CastDeviceMutableInfo* temp = cast_device_mutable_info_;
  cast_device_mutable_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::metrics::CastLogsProto_CastDeviceMutableInfo* CastLogsProto::unsafe_arena_release_cast_device_mutable_info() {
  // @@protoc_insertion_point(field_release:metrics.CastLogsProto.cast_device_mutable_info)
  _has_bits_[0] &= ~0x00000002u;
  ::metrics::CastLogsProto_CastDeviceMutableInfo* temp = cast_device_mutable_info_;
  cast_device_mutable_info_ = nullptr;
  return temp;
}
inline ::metrics::CastLogsProto_CastDeviceMutableInfo* CastLogsProto::_internal_mutable_cast_device_mutable_info() {
  _has_bits_[0] |= 0x00000002u;
  if (cast_device_mutable_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::metrics::CastLogsProto_CastDeviceMutableInfo>(GetArenaForAllocation());
    cast_device_mutable_info_ = p;
  }
  return cast_device_mutable_info_;
}
inline ::metrics::CastLogsProto_CastDeviceMutableInfo* CastLogsProto::mutable_cast_device_mutable_info() {
  ::metrics::CastLogsProto_CastDeviceMutableInfo* _msg = _internal_mutable_cast_device_mutable_info();
  // @@protoc_insertion_point(field_mutable:metrics.CastLogsProto.cast_device_mutable_info)
  return _msg;
}
inline void CastLogsProto::set_allocated_cast_device_mutable_info(::metrics::CastLogsProto_CastDeviceMutableInfo* cast_device_mutable_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cast_device_mutable_info_;
  }
  if (cast_device_mutable_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cast_device_mutable_info);
    if (message_arena != submessage_arena) {
      cast_device_mutable_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cast_device_mutable_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  cast_device_mutable_info_ = cast_device_mutable_info;
  // @@protoc_insertion_point(field_set_allocated:metrics.CastLogsProto.cast_device_mutable_info)
}

// optional fixed64 receiver_metrics_id = 6;
inline bool CastLogsProto::_internal_has_receiver_metrics_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CastLogsProto::has_receiver_metrics_id() const {
  return _internal_has_receiver_metrics_id();
}
inline void CastLogsProto::clear_receiver_metrics_id() {
  receiver_metrics_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CastLogsProto::_internal_receiver_metrics_id() const {
  return receiver_metrics_id_;
}
inline uint64_t CastLogsProto::receiver_metrics_id() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.receiver_metrics_id)
  return _internal_receiver_metrics_id();
}
inline void CastLogsProto::_internal_set_receiver_metrics_id(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  receiver_metrics_id_ = value;
}
inline void CastLogsProto::set_receiver_metrics_id(uint64_t value) {
  _internal_set_receiver_metrics_id(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.receiver_metrics_id)
}

// optional uint64 ephemeral_id = 7;
inline bool CastLogsProto::_internal_has_ephemeral_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CastLogsProto::has_ephemeral_id() const {
  return _internal_has_ephemeral_id();
}
inline void CastLogsProto::clear_ephemeral_id() {
  ephemeral_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t CastLogsProto::_internal_ephemeral_id() const {
  return ephemeral_id_;
}
inline uint64_t CastLogsProto::ephemeral_id() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.ephemeral_id)
  return _internal_ephemeral_id();
}
inline void CastLogsProto::_internal_set_ephemeral_id(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  ephemeral_id_ = value;
}
inline void CastLogsProto::set_ephemeral_id(uint64_t value) {
  _internal_set_ephemeral_id(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.ephemeral_id)
}

// optional fixed32 source_virtual_release_track = 8;
inline bool CastLogsProto::_internal_has_source_virtual_release_track() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CastLogsProto::has_source_virtual_release_track() const {
  return _internal_has_source_virtual_release_track();
}
inline void CastLogsProto::clear_source_virtual_release_track() {
  source_virtual_release_track_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CastLogsProto::_internal_source_virtual_release_track() const {
  return source_virtual_release_track_;
}
inline uint32_t CastLogsProto::source_virtual_release_track() const {
  // @@protoc_insertion_point(field_get:metrics.CastLogsProto.source_virtual_release_track)
  return _internal_source_virtual_release_track();
}
inline void CastLogsProto::_internal_set_source_virtual_release_track(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  source_virtual_release_track_ = value;
}
inline void CastLogsProto::set_source_virtual_release_track(uint32_t value) {
  _internal_set_source_virtual_release_track(value);
  // @@protoc_insertion_point(field_set:metrics.CastLogsProto.source_virtual_release_track)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace metrics

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::metrics::CastLogsProto_CastDeviceInfo_CastProductType> : ::std::true_type {};
template <> struct is_proto_enum< ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_SDKType> : ::std::true_type {};
template <> struct is_proto_enum< ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_Platform> : ::std::true_type {};
template <> struct is_proto_enum< ::metrics::CastLogsProto_CastConnectionInfo_SenderInfo_ConnectionType> : ::std::true_type {};
template <> struct is_proto_enum< ::metrics::CastLogsProto_CastEventProto_LaunchFrom> : ::std::true_type {};
template <> struct is_proto_enum< ::metrics::CastLogsProto_CastEventProto_RuntimeType> : ::std::true_type {};
template <> struct is_proto_enum< ::metrics::CastLogsProto_CastDeviceMutableInfo_RebootType> : ::std::true_type {};
template <> struct is_proto_enum< ::metrics::CastLogsProto_CastDeviceMutableInfo_NetifIPVersion> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_cast_5flogs_2eproto
