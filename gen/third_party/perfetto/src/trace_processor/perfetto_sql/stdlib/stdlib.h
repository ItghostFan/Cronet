/*
 * Copyright (C) 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 *******************************************************************************
 * AUTOGENERATED BY tools/gen_amalgamated_sql.py - DO NOT EDIT
 *******************************************************************************
 */

 #include <string.h>

namespace perfetto {
namespace trace_processor {
namespace stdlib {

const char kAndroidStartupInternalStartupsMaxsdk28[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.


INSERT INTO internal_all_startups
SELECT
  "maxsdk28",
  ROW_NUMBER() OVER(ORDER BY ts) AS startup_id,
  le.ts,
  le.ts_end AS ts_end,
  le.ts_end - le.ts AS dur,
  package_name AS package,
  NULL AS startup_type
FROM internal_startup_events le
ORDER BY ts;


)_d3l1m1t3r_"
;

const char kAndroidStartupInternalStartupsMinsdk29[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Marks the beginning of the trace and is equivalent to when the statsd startup
-- logging begins.
CREATE VIEW internal_activity_intent_received AS
SELECT ts FROM slice
WHERE name = 'MetricsLogger:launchObserverNotifyIntentStarted';

-- We partition the trace into spans based on posted activity intents.
-- We will refine these progressively in the next steps to only encompass
-- activity starts.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO TABLE internal_activity_intent_recv_spans AS
SELECT
  ROW_NUMBER()
  OVER(ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS startup_id,
  ts,
  LEAD(ts, 1, (SELECT end_ts FROM trace_bounds)) OVER(ORDER BY ts) - ts AS dur
FROM internal_activity_intent_received
ORDER BY ts;

-- Filter activity_intent_recv_spans, keeping only the ones that triggered
-- a startup.
CREATE VIEW internal_startup_partitions AS
SELECT * FROM internal_activity_intent_recv_spans AS spans
WHERE 1 = (
  SELECT COUNT(1)
  FROM internal_startup_events
  WHERE internal_startup_events.ts BETWEEN spans.ts AND spans.ts + spans.dur);

-- Successful activity startup. The end of the 'launching' event is not related
-- to whether it actually succeeded or not.
CREATE VIEW internal_activity_intent_startup_successful AS
SELECT ts FROM slice
WHERE name = 'MetricsLogger:launchObserverNotifyActivityLaunchFinished';

-- Use the starting event package name. The finish event package name
-- is not reliable in the case of failed startups.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(INSERT INTO internal_all_startups
SELECT
  "minsdk29",
  lpart.startup_id,
  lpart.ts,
  le.ts_end,
  le.ts_end - lpart.ts AS dur,
  package_name AS package,
  NULL AS startup_type
FROM internal_startup_partitions AS lpart
JOIN internal_startup_events le ON
  (le.ts BETWEEN lpart.ts AND lpart.ts + lpart.dur)
  AND (le.ts_end BETWEEN lpart.ts AND lpart.ts + lpart.dur)
WHERE (
  SELECT COUNT(1)
  FROM internal_activity_intent_startup_successful AS successful
  WHERE successful.ts BETWEEN lpart.ts AND lpart.ts + lpart.dur
) > 0;

)_d3l1m1t3r_"
;

const char kAndroidStartupInternalStartupsMinsdk33[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.


CREATE VIEW internal_startup_async_events AS
SELECT
  ts,
  dur,
  SUBSTR(name, 19) AS startup_id
FROM slice
WHERE
  name GLOB 'launchingActivity#*'
  AND dur != 0
  AND INSTR(name, ':') = 0;

CREATE VIEW internal_startup_complete_events AS
SELECT
  STR_SPLIT(completed, ':', 0) AS startup_id,
  STR_SPLIT(completed, ':', 2) AS package_name,
  CASE
    WHEN STR_SPLIT(completed, ':', 1) = 'completed-hot' THEN 'hot'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHEN STR_SPLIT(completed, ':', 1) = 'completed-warm' THEN 'warm'
    WHEN STR_SPLIT(completed, ':', 1) = 'completed-cold' THEN 'cold'
    ELSE NULL
  END AS startup_type,
  MIN(ts)
FROM (
  SELECT ts, SUBSTR(name, 19) AS completed
  FROM slice
  WHERE
    dur = 0
    -- Originally completed was unqualified, but at some point we introduced
    -- the startup type as well
    AND name GLOB 'launchingActivity#*:completed*:*'
)
GROUP BY 1, 2, 3;

INSERT INTO internal_all_startups
SELECT
  "minsdk33",
  startup_id,
  ts,
  ts + dur AS ts_end,
  dur,
  package_name,
  startup_type
FROM internal_startup_async_events
JOIN internal_startup_complete_events USING (startup_id);




)_d3l1m1t3r_"
;

const char kAndroidStartupStartups[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

SELECT IMPORT('common.slices');
SELECT IMPORT('android.process_metadata');

-- All activity startup events.
CREATE PERFETTO TABLE internal_startup_events AS
SELECT
  ts,
  dur,
  ts + dur AS ts_end,
  STR_SPLIT(s.name, ": ", 1) AS package_name
FROM slice s
JOIN process_track t ON s.track_id = t.id
JOIN process USING(upid)
WHERE
  s.name GLOB 'launching: *'
  AND (process.name IS NULL OR process.name = 'system_server');
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Gather all startup data. Populate by different sdks.
CREATE TABLE internal_all_startups(
  sdk STRING,
  startup_id INTEGER BIGINT,
  ts BIGINT,
  ts_end BIGINT,
  dur BIGINT,
  package STRING,
  startup_type STRING
);

SELECT IMPORT('android.startup.internal_startups_maxsdk28');
SELECT IMPORT('android.startup.internal_startups_minsdk29');
SELECT IMPORT('android.startup.internal_startups_minsdk33');

-- All activity startups in the trace by startup id.
-- Populated by different scripts depending on the platform version/contents.
--
-- @column id           Startup id.
-- @column ts           Timestamp of startup start.
-- @column ts_end       Timestamp of startup end.
-- @column dur          Startup duration.
-- @column package      Package name.
-- @column startup_type Startup type.
CREATE PERFETTO TABLE android_startups AS
SELECT startup_id, ts, ts_end, dur, package, startup_type FROM
internal_all_startups WHERE ( CASE
  WHEN slice_count('launchingActivity#*:*') > 0
    THEN sdk = "minsdk33"
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  WHEN slice_count('MetricsLogger:*') > 0
    THEN sdk = "minsdk29"
  ELSE sdk = "maxsdk28"
  END);

--
-- Create startup processes
--

-- Create a table containing only the slices which are necessary for determining
-- whether a startup happened.
CREATE PERFETTO TABLE internal_startup_indicator_slices AS
SELECT ts, name, track_id
FROM slice
WHERE name IN ('bindApplication', 'activityStart', 'activityResume');

CREATE PERFETTO FUNCTION INTERNAL_STARTUP_INDICATOR_slice_count(start_ts LONG,
                                                                end_ts LONG,
                                                                utid INT,
                                                                name STRING)
RETURNS INT AS
SELECT COUNT(1)
FROM thread_track t
JOIN internal_startup_indicator_slices s ON s.track_id = t.id
WHERE
  t.utid = $utid AND
  s.ts >= $start_ts AND
  s.ts < $end_ts AND
  s.name = $name;

-- Maps a startup to the set of processes that handled the activity start.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--
-- The vast majority of cases should be a single process. However it is
-- possible that the process dies during the activity startup and is respawned.
--
-- @column startup_id   Startup id.
-- @column upid         Upid of process on which activity started.
-- @column startup_type Type of the startup.
CREATE PERFETTO TABLE android_startup_processes AS
-- This is intentionally a materialized query. For some reason, if we don't
-- materialize, we end up with a query which is an order of magnitude slower :(
WITH startup_with_type AS MATERIALIZED (
  SELECT
    startup_id,
    upid,
    CASE
      -- type parsed from platform event takes precedence if available
      WHEN startup_type IS NOT NULL THEN startup_type
      WHEN bind_app > 0 AND a_start > 0 AND a_resume > 0 THEN 'cold'
      WHEN a_start > 0 AND a_resume > 0 THEN 'warm'
      WHEN a_resume > 0 THEN 'hot'
      ELSE NULL
    END AS startup_type
  FROM (
    SELECT
      l.startup_id,
      l.startup_type,
      p.upid,
      INTERNAL_STARTUP_INDICATOR_slice_count(l.ts, l.ts_end, t.utid, 'bindApplication') AS bind_app,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      INTERNAL_STARTUP_INDICATOR_slice_count(l.ts, l.ts_end, t.utid, 'activityStart') AS a_start,
      INTERNAL_STARTUP_INDICATOR_slice_count(l.ts, l.ts_end, t.utid, 'activityResume') AS a_resume
    FROM android_startups l
    JOIN android_process_metadata p ON (
      l.package = p.package_name
      -- If the package list data source was not enabled in the trace, nothing
      -- will match the above constraint so also match any process whose name
      -- is a prefix of the package name.
      OR (
        (SELECT COUNT(1) = 0 FROM package_list)
        AND p.process_name GLOB l.package || '*'
      )
      )
    JOIN thread t ON (p.upid = t.upid AND t.is_main_thread)
  )
)
SELECT *
FROM startup_with_type
WHERE startup_type IS NOT NULL;


-- Maps a startup to the set of threads on processes that handled the
-- activity start.
--
-- @column startup_id     Startup id.
-- @column ts             Timestamp of start.
-- @column dur            Duration of startup.
-- @column upid           Upid of process involved in startup.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column utid           Utid of the thread.
-- @column thread_name    Name of the thread.
-- @column is_main_thread Thread is a main thread.
CREATE VIEW android_startup_threads AS
SELECT
  startups.startup_id,
  startups.ts,
  startups.dur,
  android_startup_processes.upid,
  thread.utid,
  thread.name AS thread_name,
  thread.is_main_thread AS is_main_thread
FROM android_startups startups
JOIN android_startup_processes USING (startup_id)
JOIN thread USING (upid);

---
--- Functions
---

-- All the slices for all startups in trace.
--
-- Generally, this view should not be used. Instead, use one of the view functions related
-- to the startup slices which are created from this table.
--
-- @column startup_ts     Timestamp of startup.
-- @column startup_ts_end Timestamp of startup end.
-- @column startup_id     Startup id.
-- @column utid           UTID of thread with slice.
-- @column thread_name    Name of thread.
-- @column is_main_thread Whether it is main thread.
-- @column arg_set_id     Arg set id.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column slice_id       Slice id.
-- @column slice_name     Name of slice.
-- @column slice_ts       Timestamp of slice start.
-- @column slice_dur      Slice duration.
CREATE VIEW android_thread_slices_for_all_startups AS
SELECT
  st.ts AS startup_ts,
  st.ts + st.dur AS startup_ts_end,
  st.startup_id,
  st.utid,
  st.thread_name,
  st.is_main_thread,
  slice.arg_set_id,
  slice.id as slice_id,
  slice.name AS slice_name,
  slice.ts AS slice_ts,
  slice.dur AS slice_dur
FROM android_startup_threads st
JOIN thread_track USING (utid)
JOIN slice ON (slice.track_id = thread_track.id)
WHERE slice.ts BETWEEN st.ts AND st.ts + st.dur;

-- Given a startup id and GLOB for a slice name, returns matching slices with data.
--
-- @arg startup_id INT    Startup id.
-- @arg slice_name STRING Glob of the slice.
-- @column slice_name     Name of the slice.
-- @column slice_ts       Timestamp of start of the slice.
-- @column slice_dur      Duration of the slice.
-- @column thread_name    Name of the thread with the slice.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column arg_set_id     Arg set id.
SELECT CREATE_VIEW_FUNCTION(
  'ANDROID_SLICES_FOR_STARTUP_AND_SLICE_NAME(startup_id INT, slice_name STRING)',
  'slice_name STRING, slice_ts INT, slice_dur INT, thread_name STRING, arg_set_id INT',
  '
    SELECT slice_name, slice_ts, slice_dur, thread_name, arg_set_id
    FROM android_thread_slices_for_all_startups
    WHERE startup_id = $startup_id AND slice_name GLOB $slice_name
  '
);

-- Returns binder transaction slices for a given startup id with duration over threshold.
--
-- @arg startup_id INT    Startup id.
-- @arg threshold DOUBLE  Only return slices with duration over threshold.
-- @column id             Slice id.
-- @column slice_dur      Slice duration.
-- @column thread_name    Name of the thread with slice.
-- @column process        Name of the process with slice.
-- @column arg_set_id     Arg set id.
-- @column is_main_thread Whether is main thread.
SELECT CREATE_VIEW_FUNCTION(
  'ANDROID_BINDER_TRANSACTION_SLICES_FOR_STARTUP(startup_id INT, threshold DOUBLE)',
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  'id INT, slice_dur INT, thread_name STRING, process STRING, arg_set_id INT, is_main_thread BOOL',
  '
    SELECT slice_id as id, slice_dur, thread_name, process.name as process, s.arg_set_id, is_main_thread
    FROM android_thread_slices_for_all_startups s
    JOIN process ON (
      EXTRACT_ARG(s.arg_set_id, "destination process") = process.pid
    )
    WHERE startup_id = $startup_id AND slice_name GLOB "binder transaction" AND slice_dur > $threshold
  '
);

-- Returns duration of startup for slice name.
--
-- Sums duration of all slices of startup with provided name.
--
-- @arg startup_id LONG   Startup id.
-- @arg slice_name STRING Slice name.
-- @ret INT               Sum of duration.
CREATE PERFETTO FUNCTION android_sum_dur_for_startup_and_slice(startup_id LONG, slice_name STRING)
RETURNS INT AS
SELECT SUM(slice_dur)
FROM android_thread_slices_for_all_startups
WHERE startup_id = $startup_id AND slice_name GLOB $slice_name;

-- Returns duration of startup for slice name on main thread.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--
-- Sums duration of all slices of startup with provided name only on main thread.
--
-- @arg startup_id LONG   Startup id.
-- @arg slice_name STRING Slice name.
-- @ret INT               Sum of duration.
CREATE PERFETTO FUNCTION android_sum_dur_on_main_thread_for_startup_and_slice(startup_id LONG, slice_name STRING)
RETURNS INT AS
SELECT SUM(slice_dur)
FROM android_thread_slices_for_all_startups
WHERE startup_id = $startup_id AND slice_name GLOB $slice_name AND is_main_thread;

)_d3l1m1t3r_"
;

const char kAndroidBattery[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Battery charge at timestamp.
--
-- @column ts                  Timestamp.
-- @column current_avg_ua      Current average micro ampers.
-- @column capacity_percent    Current capacity percentage.
-- @column charge_uah          Current charge in micro ampers.
-- @column current_ua          Current micro ampers.
CREATE VIEW android_battery_charge AS
SELECT
  all_ts.ts,
  current_avg_ua,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  capacity_percent,
  charge_uah,
  current_ua
FROM (
  SELECT DISTINCT(ts) AS ts
  FROM counter c
  JOIN counter_track t ON c.track_id = t.id
  WHERE name GLOB 'batt.*'
) AS all_ts
LEFT JOIN (
  SELECT ts, value AS current_avg_ua
  FROM counter c
  JOIN counter_track t ON c.track_id = t.id
  WHERE name = 'batt.current.avg_ua'
) USING(ts)
LEFT JOIN (
  SELECT ts, value AS capacity_percent
  FROM counter c
  JOIN counter_track t ON c.track_id = t.id
  WHERE name = 'batt.capacity_pct'
) USING(ts)
LEFT JOIN (
  SELECT ts, value AS charge_uah
  FROM counter c
  JOIN counter_track t ON c.track_id = t.id
  WHERE name = 'batt.charge_uah'
) USING(ts)
LEFT JOIN (
  SELECT ts, value AS current_ua
  FROM counter c
  JOIN counter_track t ON c.track_id = t.id
  WHERE name = 'batt.current_ua'
) USING(ts)
ORDER BY ts;

)_d3l1m1t3r_"
;

const char kAndroidBatteryStats[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

SELECT IMPORT('common.timestamps');

-- Converts a battery_stats counter value to human readable string.
--
-- @arg track STRING  The counter track name (e.g. 'battery_stats.audio').
-- @arg value FLOAT   The counter value.
-- @ret STRING        The human-readable name for the counter value.
CREATE PERFETTO FUNCTION android_battery_stats_counter_to_string(track STRING, value FLOAT)
RETURNS STRING AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  CASE
    WHEN ($track = "battery_stats.wifi_scan" OR
          $track = "battery_stats.wifi_radio" OR
          $track = "battery_stats.mobile_radio" OR
          $track = "battery_stats.audio" OR
          $track = "battery_stats.video" OR
          $track = "battery_stats.camera" OR
          $track = "battery_stats.power_save" OR
          $track = "battery_stats.phone_in_call")
      THEN
        CASE $value
          WHEN 0 THEN "inactive"
          WHEN 1 THEN "active"
          ELSE "unknown"
        END
    WHEN $track = "battery_stats.wifi"
      THEN
        CASE $value
          WHEN 0 THEN "off"
          WHEN 1 THEN "on"
          ELSE "unknown"
        END
    WHEN $track = "battery_stats.phone_state"
      THEN
        CASE $value
          WHEN 0 THEN "in"
          WHEN 1 THEN "out"
          WHEN 2 THEN "emergency"
          WHEN 3 THEN "off"
          ELSE "unknown"
        END
    WHEN ($track = "battery_stats.phone_signal_strength" OR
          $track = "battery_stats.wifi_signal_strength")
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      THEN
        CASE $value
          WHEN 0 THEN "0/4"
          WHEN 1 THEN "1/4"
          WHEN 2 THEN "2/4"
          WHEN 3 THEN "3/4"
          WHEN 4 THEN "4/4"
          ELSE "unknown"
        END
    WHEN $track = "battery_stats.wifi_suppl"
      THEN
        CASE $value
          WHEN 0 THEN "invalid"
          WHEN 1 THEN "disconnected"
          WHEN 2 THEN "disabled"
          WHEN 3 THEN "inactive"
          WHEN 4 THEN "scanning"
          WHEN 5 THEN "authenticating"
          WHEN 6 THEN "associating"
          WHEN 7 THEN "associated"
          WHEN 8 THEN "4-way-handshake"
          WHEN 9 THEN "group-handshake"
          WHEN 10 THEN "completed"
          WHEN 11 THEN "dormant"
          WHEN 12 THEN "uninitialized"
          ELSE "unknown"
        END
    WHEN $track = "battery_stats.data_conn"
      THEN
        CASE $value
          WHEN 0 THEN "Out of service"
          WHEN 1 THEN "2.5G (GPRS)"
          WHEN 2 THEN "2.7G (EDGE)"
          WHEN 3 THEN "3G (UMTS)"
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          WHEN 4 THEN "3G (CDMA)"
          WHEN 5 THEN "3G (EVDO Rel 0)"
          WHEN 6 THEN "3G (EVDO Rev A)"
          WHEN 7 THEN "3G (LXRTT)"
          WHEN 8 THEN "3.5G (HSDPA)"
          WHEN 9 THEN "3.5G (HSUPA)"
          WHEN 10 THEN "3.5G (HSPA)"
          WHEN 11 THEN "2G (IDEN)"
          WHEN 12 THEN "3G (EVDO Rev B)"
          WHEN 13 THEN "4G (LTE)"
          WHEN 14 THEN "3.5G (eHRPD)"
          WHEN 15 THEN "3.7G (HSPA+)"
          WHEN 16 THEN "2G (GSM)"
          WHEN 17 THEN "3G (TD SCDMA)"
          WHEN 18 THEN "Wifi calling (IWLAN)"
          WHEN 19 THEN "4.5G (LTE CA)"
          WHEN 20 THEN "5G (NR)"
          WHEN 21 THEN "Emergency calls only"
          WHEN 22 THEN "Other"
          ELSE "unknown"
        END
    ELSE CAST($value AS text)
  END;

-- View of human readable battery stats counter-based states. These are recorded
-- by BatteryStats as a bitmap where each 'category' has a unique value at any
-- given time.
--
-- @column ts                  Timestamp in nanoseconds.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column dur                 The duration the state was active.
-- @column track_name          The name of the counter track.
-- @column value               The counter value as a number.
-- @column value_name          The counter value as a human-readable string.
CREATE VIEW android_battery_stats_state AS
SELECT
  ts,
  name AS track_name,
  CAST(value AS INT64) AS value,
  android_battery_stats_counter_to_string(name, value) AS value_name,
  IFNULL(LEAD(ts) OVER (PARTITION BY name ORDER BY ts) - ts, -1) AS dur
FROM counter
JOIN counter_track
  ON counter.track_id = counter_track.id
WHERE counter_track.name GLOB 'battery_stats.*';


-- View of slices derived from battery_stats events. Battery stats records all
-- events as instants, however some may indicate whether something started or
-- stopped with a '+' or '-' prefix. Events such as jobs, top apps, foreground
-- apps or long wakes include these details and allow drawing slices between
-- instant events found in a trace.
--
-- For example, we may see an event like the following on 'battery_stats.top':
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--
--     -top=10215:"com.google.android.apps.nexuslauncher"
--
-- This view will find the associated start ('+top') with the matching suffix
-- (everything after the '=') to construct a slice. It computes the timestamp
-- and duration from the events and extract the details as follows:
--
--     track_name='battery_stats.top'
--     str_value='com.google.android.apps.nexuslauncher'
--     int_value=10215
--
-- @column track_name          The battery stats track name.
-- @column ts                  Timestamp in nanoseconds.
-- @column dur                 The duration of the event.
-- @column str_value           The string part of the event identifier.
-- @column int_value           The integer part of the event identifier.
CREATE VIEW android_battery_stats_event_slices AS
WITH
  event_markers AS (
    SELECT
      ts,
      track.name AS track_name,
      str_split(slice.name, '=', 1) AS key,
      substr(slice.name, 1, 1) = '+' AS start
    FROM slice
    JOIN track
      ON slice.track_id = track.id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHERE
      track_name GLOB 'battery_stats.*'
      AND substr(slice.name, 1, 1) IN ('+', '-')
  ),
  with_neighbors AS (
    SELECT
      *,
      LAG(ts) OVER (PARTITION BY track_name, key ORDER BY ts) AS last_ts,
      LEAD(ts) OVER (PARTITION BY track_name, key ORDER BY ts) AS next_ts
    FROM event_markers
  ),
  -- Note: query performance depends on the ability to push down filters on
  -- the track_name. It would be more clear below to have two queries and union
  -- them, but doing so prevents push down through the above window functions.
  event_spans AS (
    SELECT
      track_name, key,
      IIF(start, ts, trace_start()) AS ts,
      IIF(start, next_ts, ts) AS end_ts
    FROM with_neighbors
    -- For the majority of events, we take the `start` event and compute the dur
    -- based on next_ts. In the off chance we get an end event with no prior
    -- start (matched by the second half of this where), we can create an event
    -- starting from the beginning of the trace ending at the current event.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHERE (start OR last_ts IS NULL)
  )
SELECT
  ts,
  IFNULL(end_ts-ts, -1) AS dur,
  track_name,
  str_split(key, '"', 1) AS str_value,
  CAST(str_split(key, ':', 0) AS INT64) AS int_value
FROM event_spans;

)_d3l1m1t3r_"
;

const char kAndroidBinder[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

SELECT IMPORT('common.timestamps');

-- Count Binder transactions per process.
--
-- @column process_name  Name of the process that started the binder transaction.
-- @column pid           PID of the process that started the binder transaction.
-- @column slice_name    Name of the slice with binder transaction.
-- @column event_count   Number of binder transactions in process in slice.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE VIEW android_binder_metrics_by_process AS
SELECT
  process.name AS process_name,
  process.pid AS pid,
  slice.name AS slice_name,
  COUNT(*) AS event_count
FROM slice
JOIN thread_track ON slice.track_id = thread_track.id
JOIN thread ON thread.utid = thread_track.utid
JOIN process ON thread.upid = process.upid
WHERE
  slice.name GLOB 'binder*'
GROUP BY
  process_name,
  slice_name;

CREATE PERFETTO TABLE internal_binder_txn_merged AS
WITH
  -- Fetch the broken binder txns first, i.e, the txns that have children slices
  -- They are definietly broken because synchronous txns are blocked sleeping while
  -- waiting for a response.
  -- These broken txns will be excluded below in the binder_txn CTE
  broken_binder_txn AS (
    SELECT ancestor.id FROM slice
    JOIN slice ancestor ON ancestor.id = slice.parent_id
    WHERE ancestor.name = 'binder transaction'
    GROUP BY ancestor.id
  ),
  -- Adding MATERIALIZED here matters in cases where there are few/no binder
  -- transactions in the trace. Our cost estimation is not good enough to allow
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- the query planner to see through to this fact. Instead, our cost estimation
  -- causes repeated queries on this table which is slow because it's an O(n)
  -- query.
  --
  -- We should fix this by doing some (ideally all) of the following:
  --  1) Add support for columnar tables in SQL which will allow for
  --     "subsetting" the slice table to only contain binder transactions.
  --  2) Make this query faster by adding improving string filtering.
  --  3) Add caching so that even if these queries happen many times, they are
  --     fast.
  --  4) Improve cost estimation algorithm to allow the joins to happen the
  --     right way around.
  binder_txn AS MATERIALIZED (
    SELECT
      slice.id AS binder_txn_id,
      process.name AS process_name,
      thread.name AS thread_name,
      thread.utid AS utid,
      thread.tid AS tid,
      process.pid AS pid,
      process.upid AS upid,
      slice.ts,
      slice.dur,
      thread.is_main_thread
    FROM slice
    JOIN thread_track ON slice.track_id = thread_track.id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    JOIN thread USING (utid)
    JOIN process USING (upid)
    LEFT JOIN broken_binder_txn ON broken_binder_txn.id = slice.id
    WHERE slice.name = 'binder transaction'
    AND broken_binder_txn.id IS NULL
  ),
  binder_reply AS (
    SELECT
      binder_txn.*,
      binder_reply.ts AS server_ts,
      binder_reply.dur AS server_dur,
      binder_reply.id AS binder_reply_id,
      reply_thread.name AS server_thread,
      reply_process.name AS server_process,
      reply_thread.utid AS server_utid,
      reply_thread.tid AS server_tid,
      reply_process.pid AS server_pid,
      reply_process.upid AS server_upid,
      aidl.name AS aidl_name
    FROM binder_txn
    JOIN flow binder_flow ON binder_txn.binder_txn_id = binder_flow.slice_out
    JOIN slice binder_reply ON binder_flow.slice_in = binder_reply.id
    JOIN thread_track reply_thread_track
      ON binder_reply.track_id = reply_thread_track.id
    JOIN thread reply_thread ON reply_thread.utid = reply_thread_track.utid
    JOIN process reply_process ON reply_process.upid = reply_thread.upid
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    LEFT JOIN slice aidl ON aidl.parent_id = binder_reply.id
        AND (aidl.name GLOB 'AIDL::cpp*Server'
             OR aidl.name GLOB 'AIDL::java*server'
             OR aidl.name GLOB 'HIDL::*server')
  )
SELECT
  MIN(aidl_name) AS aidl_name,
  binder_txn_id,
  process_name AS client_process,
  thread_name AS client_thread,
  upid AS client_upid,
  utid AS client_utid,
  tid AS client_tid,
  pid AS client_pid,
  is_main_thread,
  ts AS client_ts,
  dur AS client_dur,
  binder_reply_id,
  server_process,
  server_thread,
  server_upid,
  server_utid,
  server_tid,
  server_pid,
  server_ts,
  server_dur
FROM binder_reply
WHERE client_dur != -1 AND server_dur != -1 AND client_dur >= server_dur
GROUP BY
  process_name,
  thread_name,
  binder_txn_id,
  binder_reply_id;

CREATE TABLE internal_oom_score AS
  SELECT
    process.upid,
    CAST(c.value AS INT) AS value,
    c.ts,
    IFNULL(LEAD(ts) OVER (PARTITION BY upid ORDER BY ts), trace_bounds.end_ts) AS end_ts
    FROM counter c, trace_bounds
)_d3l1m1t3r_"
R"_d3l1m1t3r_(         JOIN process_counter_track t ON c.track_id = t.id
         JOIN process USING (upid)
   WHERE t.name = 'oom_score_adj';

CREATE INDEX internal_oom_score_idx ON internal_oom_score(upid, ts);

-- Breakdown synchronous binder transactions per txn.
-- It returns data about the client and server ends of every binder transaction.
--
-- @column aidl_name name of the binder interface if existing.
-- @column binder_txn_id slice id of the binder txn.
-- @column client_process name of the client process.
-- @column client_thread name of the client thread.
-- @column client_upid Upid of the client process.
-- @column client_utid Utid of the client thread.
-- @column client_tid Tid of the client thread.
-- @column client_ts timestamp of the client txn.
-- @column client_dur dur of the client txn.
-- @column client_oom_score oom score of the client process at the start of the txn.
-- @column is_main_thread Whether the txn was initiated from the main thread of the client process.
-- @column binder_reply_id slice id of the binder reply.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column server_process name of the server process.
-- @column server_thread  name of the server thread.
-- @column server_upid Upid of the server process.
-- @column server_utid Utid of the server thread.
-- @column server_tid Tid of the server thread.
-- @column server_ts timestamp of the server txn.
-- @column server_dur dur of the server txn.
-- @column server_oom_score oom score of the server process at the start of the reply.
CREATE VIEW android_sync_binder_metrics_by_txn AS
SELECT binder.*, client_oom.value AS client_oom_score, server_oom.value AS server_oom_score
FROM internal_binder_txn_merged binder
LEFT JOIN internal_oom_score client_oom
  ON
    binder.client_upid = client_oom.upid
    AND binder.client_ts BETWEEN client_oom.ts AND client_oom.end_ts
LEFT JOIN internal_oom_score server_oom
  ON
    binder.server_upid = server_oom.upid
    AND binder.server_ts BETWEEN server_oom.ts AND server_oom.end_ts;

CREATE VIEW internal_binder_txn
AS
SELECT client_ts AS ts, client_dur AS dur, client_utid AS utid, *
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM android_sync_binder_metrics_by_txn;

CREATE VIEW internal_binder_reply
AS
SELECT server_ts AS ts, server_dur AS dur, server_utid AS utid, *
FROM android_sync_binder_metrics_by_txn;

CREATE VIRTUAL TABLE internal_sp_binder_txn_thread_state
USING
  SPAN_JOIN(internal_binder_txn PARTITIONED utid, thread_state PARTITIONED utid);

CREATE VIRTUAL TABLE internal_sp_binder_reply_thread_state
USING
  SPAN_JOIN(internal_binder_reply PARTITIONED utid, thread_state PARTITIONED utid);

-- Aggregated thread_states on the client and server side per binder txn
-- This builds on the data from |android_sync_binder_metrics_by_txn| and
-- for each end (client and server) of the transaction, it returns
-- the aggregated sum of all the thread state durations.
-- The |thread_state_type| column represents whether a given 'aggregated thread_state'
-- row is on the client or server side. 'binder_txn' is client side and 'binder_reply'
-- is server side.
--
-- @column binder_txn_id slice id of the binder txn
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column binder_reply_id slice id of the binder reply
-- @column thread_state_type whether thread state is on the txn or reply side
-- @column thread_state a thread_state that occurred in the txn
-- @column thread_state_dur aggregated dur of the |thread_state| in the txn
-- @column thread_state_count aggregated count of the |thread_state| in the txn
CREATE VIEW android_sync_binder_thread_state_by_txn
AS
SELECT
  binder_txn_id,
  client_ts,
  client_tid,
  binder_reply_id,
  server_ts,
  server_tid,
  'binder_txn' AS thread_state_type,
  state AS thread_state,
  SUM(dur) AS thread_state_dur,
  COUNT(dur) AS thread_state_count
FROM internal_sp_binder_txn_thread_state
GROUP BY binder_txn_id, binder_reply_id, thread_state_type, thread_state
UNION ALL
SELECT
  binder_txn_id,
  client_ts,
  client_tid,
  binder_reply_id,
  server_ts,
  server_tid,
  'binder_reply' AS thread_state_type,
  state AS thread_state,
  SUM(dur) AS thread_state_dur,
  COUNT(dur) AS thread_state_count
FROM internal_sp_binder_reply_thread_state
)_d3l1m1t3r_"
R"_d3l1m1t3r_(GROUP BY binder_txn_id, binder_reply_id, thread_state_type, thread_state;

-- Aggregated blocked_functions on the client and server side per binder txn
-- This builds on the data from |android_sync_binder_metrics_by_txn| and
-- for each end (client and server) of the transaction, it returns
-- the aggregated sum of all the kernel blocked function durations.
-- The |thread_state_type| column represents whether a given 'aggregated blocked_function'
-- row is on the client or server side. 'binder_txn' is client side and 'binder_reply'
-- is server side.
--
-- @column binder_txn_id slice id of the binder txn
-- @column binder_reply_id slice id of the binder reply
-- @column thread_state_type whether thread state is on the txn or reply side
-- @column blocked_function blocked kernel function in a thread state
-- @column blocked_function_dur aggregated dur of the |blocked_function| in the txn
-- @column blocked_function_count aggregated count of the |blocked_function| in the txn
CREATE VIEW android_sync_binder_blocked_functions_by_txn
)_d3l1m1t3r_"
R"_d3l1m1t3r_(AS
SELECT
  binder_txn_id,
  client_ts,
  client_tid,
  binder_reply_id,
  server_ts,
  server_tid,
  'binder_txn' AS thread_state_type,
  blocked_function,
  SUM(dur) AS blocked_function_dur,
  COUNT(dur) AS blocked_function_count
FROM internal_sp_binder_txn_thread_state
WHERE blocked_function IS NOT NULL
GROUP BY binder_txn_id, binder_reply_id, blocked_function
UNION ALL
SELECT
  binder_txn_id,
  client_ts,
  client_tid,
  binder_reply_id,
  server_ts,
  server_tid,
  'binder_reply' AS thread_state_type,
  blocked_function,
  SUM(dur) AS blocked_function_dur,
  COUNT(dur) AS blocked_function_count
FROM internal_sp_binder_reply_thread_state
WHERE blocked_function IS NOT NULL
GROUP BY binder_txn_id, binder_reply_id, blocked_function;

CREATE TABLE internal_async_binder_reply AS
WITH async_reply AS MATERIALIZED (
  SELECT id, ts, dur, track_id, name
  FROM slice
  WHERE
    name GLOB 'AIDL::cpp*Server'
    OR name GLOB 'AIDL::java*server'
    OR name GLOB 'HIDL::*server'
    OR name = 'binder async rcv'
)_d3l1m1t3r_"
R"_d3l1m1t3r_() SELECT *, LEAD(name) OVER (PARTITION BY track_id ORDER BY ts) AS next_name FROM async_reply;

CREATE TABLE internal_binder_async_txn_raw AS
SELECT
  slice.id AS binder_txn_id,
  process.name AS client_process,
  thread.name AS client_thread,
  process.upid AS client_upid,
  thread.utid AS client_utid,
  thread.tid AS client_tid,
  process.pid AS client_pid,
  thread.is_main_thread,
  slice.ts AS client_ts,
  slice.dur AS client_dur
FROM slice
JOIN thread_track
  ON slice.track_id = thread_track.id
JOIN thread
  USING (utid)
JOIN process
  USING (upid)
WHERE slice.name = 'binder transaction async';

CREATE PERFETTO TABLE internal_binder_async_txn AS
SELECT
  IIF(binder_reply.next_name = 'binder async rcv', NULL, binder_reply.next_name) AS aidl_name,
  binder_txn.*,
  binder_reply.id AS binder_reply_id,
  reply_process.name AS server_process,
  reply_thread.name AS server_thread,
  reply_process.upid AS server_upid,
  reply_thread.utid AS server_utid,
  reply_thread.tid AS server_tid,
  reply_process.pid AS server_pid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  binder_reply.ts AS server_ts,
  binder_reply.dur AS server_dur
FROM internal_binder_async_txn_raw binder_txn
JOIN flow binder_flow
  ON binder_txn.binder_txn_id = binder_flow.slice_out
JOIN internal_async_binder_reply binder_reply
  ON binder_flow.slice_in = binder_reply.id
JOIN thread_track reply_thread_track
  ON binder_reply.track_id = reply_thread_track.id
JOIN thread reply_thread
  ON reply_thread.utid = reply_thread_track.utid
JOIN process reply_process
  ON reply_process.upid = reply_thread.upid
WHERE binder_reply.name = 'binder async rcv';

-- Breakdown asynchronous binder transactions per txn.
-- It returns data about the client and server ends of every binder transaction async.
--
-- @column aidl_name name of the binder interface if existing.
-- @column binder_txn_id slice id of the binder txn.
-- @column client_process name of the client process.
-- @column client_thread name of the client thread.
-- @column client_upid Upid of the client process.
-- @column client_utid Utid of the client thread.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column client_tid Tid of the client thread.
-- @column client_ts timestamp of the client txn.
-- @column client_dur dur of the client txn.
-- @column client_oom_score oom score of the client process at the start of the txn.
-- @column is_main_thread Whether the txn was initiated from the main thread of the client process.
-- @column binder_reply_id slice id of the binder reply.
-- @column server_process name of the server process.
-- @column server_thread  name of the server thread.
-- @column server_upid Upid of the server process.
-- @column server_utid Utid of the server thread.
-- @column server_tid Tid of the server thread.
-- @column server_ts timestamp of the server txn.
-- @column server_dur dur of the server txn.
-- @column server_oom_score oom score of the server process at the start of the reply.
CREATE VIEW android_async_binder_metrics_by_txn
AS
SELECT binder.*, client_oom.value AS client_oom_score, server_oom.value AS server_oom_score
FROM internal_binder_async_txn binder
)_d3l1m1t3r_"
R"_d3l1m1t3r_(LEFT JOIN internal_oom_score client_oom
  ON
    binder.client_upid = client_oom.upid
    AND binder.client_ts BETWEEN client_oom.ts AND client_oom.end_ts
LEFT JOIN internal_oom_score server_oom
  ON
    binder.server_upid = server_oom.upid
    AND binder.server_ts BETWEEN server_oom.ts AND server_oom.end_ts;

-- Breakdown asynchronous binder transactions per txn.
-- It returns data about the client and server ends of every binder transaction async.
--
-- @column aidl_name name of the binder interface if existing.
-- @column binder_txn_id slice id of the binder txn.
-- @column client_process name of the client process.
-- @column client_thread name of the client thread.
-- @column client_upid Upid of the client process.
-- @column client_utid Utid of the client thread.
-- @column client_tid Tid of the client thread.
-- @column client_ts timestamp of the client txn.
-- @column client_dur dur of the client txn.
-- @column client_oom_score oom score of the client process at the start of the txn.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column is_main_thread Whether the txn was initiated from the main thread of the client process.
-- @column binder_reply_id slice id of the binder reply.
-- @column server_process name of the server process.
-- @column server_thread  name of the server thread.
-- @column server_upid Upid of the server process.
-- @column server_utid Utid of the server thread.
-- @column server_tid Tid of the server thread.
-- @column server_ts timestamp of the server txn.
-- @column server_dur dur of the server txn.
-- @column server_oom_score oom score of the server process at the start of the reply.
-- @column is_sync whether the txn is synchronous or async (oneway).
CREATE VIEW android_binder_txns
AS
SELECT *, 1 AS is_sync FROM android_sync_binder_metrics_by_txn
UNION ALL
SELECT *, 0 AS is_sync FROM android_async_binder_metrics_by_txn;

-- Returns a DAG of all outgoing binder txns from a process.
-- The roots of the graph are the threads making the txns and the graph flows from:
-- thread -> server_process -> AIDL interface -> AIDL method.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- The weights of each node represent the wall execution time in the server_process.
--
-- @arg upid STRING   Upid of process to generate an outgoing graph for.
-- @ret pprof BYTES   Pprof of outgoing binder txns.
CREATE PERFETTO FUNCTION ANDROID_BINDER_OUTGOING_GRAPH(upid INT)
RETURNS TABLE(pprof BYTES) AS
WITH threads AS (
  SELECT binder_txn_id, CAT_STACKS(client_thread) AS stack
  FROM android_binder_txns
  WHERE ($upid IS NOT NULL AND client_upid = $upid) OR ($upid IS NULL)
), server_process AS (
  SELECT binder_txn_id, CAT_STACKS(stack, server_process) AS stack
  FROM android_binder_txns
  JOIN threads USING(binder_txn_id)
), end_points AS (
  SELECT binder_txn_id,
         CAT_STACKS(stack, STR_SPLIT(aidl_name, '::', IIF(aidl_name GLOB 'AIDL*', 2, 1))) AS stack
  FROM android_binder_txns
  JOIN server_process USING(binder_txn_id)
), aidl_names AS (
  SELECT binder_txn_id, server_dur,
         CAT_STACKS(stack, STR_SPLIT(aidl_name, '::', IIF(aidl_name GLOB 'AIDL*', 3, 2))) AS stack
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM android_binder_txns
  JOIN end_points USING(binder_txn_id)
) SELECT EXPERIMENTAL_PROFILE(stack, 'duration', 'ns', server_dur) AS pprof
  FROM aidl_names;

-- Returns a DAG of all incoming binder txns from a process.
-- The roots of the graph are the clients making the txns and the graph flows from:
-- client_process -> AIDL interface -> AIDL method.
-- The weights of each node represent the wall execution time in the server_process.
--
-- @arg upid STRING   Upid of process to generate an outgoing graph for.
-- @ret pprof BYTES   Pprof of outgoing binder txns.
CREATE PERFETTO FUNCTION ANDROID_BINDER_INCOMING_GRAPH(upid INT)
RETURNS TABLE(pprof BYTES) AS
WITH client_process AS (
  SELECT binder_txn_id, CAT_STACKS(client_process) AS stack
  FROM android_binder_txns
  WHERE ($upid IS NOT NULL AND server_upid = $upid) OR ($upid IS NULL)
), end_points AS (
  SELECT binder_txn_id,
         CAT_STACKS(stack, STR_SPLIT(aidl_name, '::', IIF(aidl_name GLOB 'AIDL*', 2, 1))) AS stack
  FROM android_binder_txns
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  JOIN client_process USING(binder_txn_id)
), aidl_names AS (
  SELECT binder_txn_id, server_dur,
         CAT_STACKS(stack, STR_SPLIT(aidl_name, '::', IIF(aidl_name GLOB 'AIDL*', 3, 2))) AS stack
  FROM android_binder_txns
  JOIN end_points USING(binder_txn_id)
) SELECT EXPERIMENTAL_PROFILE(stack, 'duration', 'ns', server_dur) AS pprof
  FROM aidl_names;

-- Returns a graph of all binder txns in a trace.
-- The nodes are client_process and server_process.
-- The weights of each node represent the wall execution time in the server_process.
--
-- @arg min_client_oom_score INT   Matches txns from client_processes greater than or equal to the OOM score.
-- @arg max_client_oom_score INT   Matches txns from client_processes less than or equal to the OOM score.
-- @arg min_server_oom_score INT   Matches txns to server_processes greater than or equal to the OOM score.
-- @arg max_server_oom_score INT   Matches txns to server_processes less than or equal to the OOM score.
-- @ret pprof BYTES                Pprof of binder txns.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO FUNCTION ANDROID_BINDER_GRAPH(min_client_oom_score INT, max_client_oom_score INT, min_server_oom_score INT, max_server_oom_score INT)
RETURNS TABLE(pprof BYTES) AS
WITH clients AS (
  SELECT binder_txn_id, CAT_STACKS(client_process) AS stack
   FROM android_binder_txns
   WHERE client_oom_score BETWEEN $min_client_oom_score AND $max_client_oom_score
), servers AS (
  SELECT binder_txn_id, server_dur, CAT_STACKS(stack, server_process) AS stack
  FROM android_binder_txns
  JOIN clients USING(binder_txn_id)
  WHERE server_oom_score BETWEEN $min_server_oom_score AND $max_server_oom_score
) SELECT EXPERIMENTAL_PROFILE(stack, 'duration', 'ns', server_dur) AS pprof
  FROM servers;

)_d3l1m1t3r_"
;

const char kAndroidIo[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Aggregates f2fs IO and latency stats by counter name.
--
-- @column counter_name   Counter name on which all the other values are aggregated on.
-- @column counter_sum    Sum of all counter values for the counter name.
-- @column counter_max    Max of all counter values for the counter name.
-- @column counter_min    Min of all counter values for the counter name.
-- @column counter_dur    Duration between the first and last counter value for the counter name.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column counter_count  Count of all the counter values for the counter name.
-- @column counter_avg    Avergate of all the counter values for the counter name.
CREATE VIEW android_io_f2fs_counter_stats AS
SELECT
  STR_SPLIT(counter_track.name, '].', 1) AS name,
  SUM(counter.value) AS sum,
  MAX(counter.value) AS max,
  MIN(counter.value) AS min,
  MAX(ts) - MIN(ts) AS dur,
  COUNT(ts) AS count,
  AVG(counter.value) AS avg
FROM counter
JOIN counter_track
  ON counter_track.id = counter.track_id AND counter_track.name GLOB '*f2fs*'
GROUP BY name
ORDER BY sum DESC;

-- Aggregates f2fs_write stats by inode and thread.
--
-- @column utid          Utid of the thread.
-- @column tid           Tid of the thread.
-- @column thread_name   Name of the thread.
-- @column upid          Upid of the process.
-- @column pid           Pid of the process.
-- @column process_name  Name of the thread.
-- @column ino           Inode number of the file being written.
-- @column dev           Device node number of the file being written.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column bytes         Total number of bytes written on this file by the |utid|.
-- @column write_count   Total count of write requests for this file.
CREATE VIEW android_io_f2fs_write_stats AS
WITH
  f2fs_write_end AS (
    SELECT
      *,
      EXTRACT_ARG(arg_set_id, 'len') AS len,
      EXTRACT_ARG(arg_set_id, 'dev') AS dev,
      EXTRACT_ARG(arg_set_id, 'ino') AS ino,
      EXTRACT_ARG(arg_set_id, 'copied') AS copied
    FROM raw
    WHERE name GLOB 'f2fs_write_end*'
  )
SELECT
  thread.utid,
  thread.tid,
  thread.name AS thread_name,
  process.upid,
  process.pid,
  process.name AS process_name,
  f.ino,
  f.dev,
  SUM(copied) AS bytes,
  COUNT(len) AS write_count
FROM f2fs_write_end f
JOIN thread
  USING (utid)
JOIN process
  USING (upid)
GROUP BY utid, ino, dev
ORDER BY bytes DESC;

-- Aggregates f2fs write stats. Counts distinct datapoints, total write operations,
-- and bytes written
--
-- @column total_write_count        Total number of writes in the trace.
-- @column distinct_processes       Number of distinct processes.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column total_bytes_written      Total number of bytes written.
-- @column distinct_device_count    Count of distinct devices written to.
-- @column distict_inode_count      Count of distinct inodes written to.
-- @column distinct_thread_count    Count of distinct threads writing.
CREATE VIEW android_io_f2fs_aggregate_write_stats AS
select SUM(write_count) as total_write_count,
      COUNT(DISTINCT pid) distinct_processes,
      SUM(bytes) as total_bytes_written,
      COUNT(DISTINCT dev) as distinct_device_count,
      COUNT(DISTINCT ino) distict_inode_count,
      COUNT(DISTINCT tid) distinct_thread_count
from android_io_f2fs_write_stats;
)_d3l1m1t3r_"
;

const char kAndroidMonitorContention[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Extracts the blocking thread from a slice name
--
-- @arg slice_name STRING   Name of slice
-- @ret STRING              Blocking thread
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_blocking_thread(
  slice_name STRING
)
RETURNS STRING AS
SELECT STR_SPLIT(STR_SPLIT($slice_name, "with owner ", 1), " (", 0);

-- Extracts the blocking thread tid from a slice name
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--
-- @arg slice_name STRING   Name of slice
-- @ret INT                 Blocking thread tid
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_blocking_tid(
  slice_name STRING
)
RETURNS INT AS
SELECT CAST(STR_SPLIT(STR_SPLIT($slice_name, " (", 1), ")", 0) AS INT);

-- Extracts the blocking method from a slice name
--
-- @arg slice_name STRING   Name of slice
-- @ret STRING              Blocking thread
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_blocking_method(
  slice_name STRING
)
RETURNS STRING AS
SELECT STR_SPLIT(STR_SPLIT($slice_name, ") at ", 1), "(", 0)
    || "("
    || STR_SPLIT(STR_SPLIT($slice_name, ") at ", 1), "(", 1);

-- Extracts a shortened form of the blocking method name from a slice name.
-- The shortened form discards the parameter and return
-- types.
--
-- @arg slice_name STRING   Name of slice
-- @ret STRING              Blocking thread
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_short_blocking_method(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  slice_name STRING
)
RETURNS STRING AS
SELECT
    STR_SPLIT(STR_SPLIT(android_extract_android_monitor_contention_blocking_method($slice_name), " ", 1), "(", 0);

-- Extracts the monitor contention blocked method from a slice name
--
-- @arg slice_name STRING   Name of slice
-- @ret STRING              Blocking thread
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_blocked_method(
  slice_name STRING
)
RETURNS STRING AS
SELECT STR_SPLIT(STR_SPLIT($slice_name, "blocking from ", 1), "(", 0)
    || "("
    || STR_SPLIT(STR_SPLIT($slice_name, "blocking from ", 1), "(", 1);

-- Extracts a shortened form of the monitor contention blocked method name
-- from a slice name. The shortened form discards the parameter and return
-- types.
--
-- @arg slice_name STRING   Name of slice
-- @ret STRING              Blocking thread
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_short_blocked_method(
  slice_name STRING
)
RETURNS STRING AS
SELECT
    STR_SPLIT(STR_SPLIT(android_extract_android_monitor_contention_blocked_method($slice_name), " ", 1), "(", 0);
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Extracts the number of waiters on the monitor from a slice name
--
-- @arg slice_name STRING   Name of slice
-- @ret INT                 Count of waiters on the lock
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_waiter_count(
  slice_name STRING
)
RETURNS INT AS
SELECT CAST(STR_SPLIT(STR_SPLIT($slice_name, "waiters=", 1), " ", 0) AS INT);

-- Extracts the monitor contention blocking source location from a slice name
--
-- @arg slice_name STRING   Name of slice
-- @ret STRING              Blocking thread
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_blocking_src(
  slice_name STRING
)
RETURNS STRING AS
SELECT STR_SPLIT(STR_SPLIT($slice_name, ")(", 1), ")", 0);

-- Extracts the monitor contention blocked source location from a slice name
--
-- @arg slice_name STRING   Name of slice
-- @ret STRING              Blocking thread
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_blocked_src(
  slice_name STRING
)
RETURNS STRING AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT STR_SPLIT(STR_SPLIT($slice_name, ")(", 2), ")", 0);

CREATE PERFETTO TABLE internal_valid_android_monitor_contention AS
SELECT slice.id AS id
FROM slice
LEFT JOIN slice child
  ON child.parent_id = slice.id
LEFT JOIN slice grand_child
  ON grand_child.parent_id = child.id
WHERE
  slice.name GLOB 'monitor contention*'
  AND (child.name GLOB 'Lock contention*' OR child.name IS NULL)
  AND (grand_child.name IS NULL)
GROUP BY slice.id;

-- Contains parsed monitor contention slices.
--
-- @column blocking_method Name of the method holding the lock.
-- @column blocked_methhod Name of the method trying to acquire the lock.
-- @column short_blocking_method Blocking_method without arguments and return types.
-- @column short_blocked_method Blocked_method without arguments and return types.
-- @column blocking_src File location of blocking_method in form <filename:linenumber>.
-- @column blocked_src File location of blocked_method in form <filename:linenumber>.
-- @column waiter_count Zero indexed number of threads trying to acquire the lock.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column blocking_utid Utid of thread holding the lock.
-- @column blocking_thread_name Thread name of thread holding the lock.
-- @column upid Upid of process experiencing lock contention.
-- @column process_name Process name of process experiencing lock contention.
-- @column id Slice id of lock contention.
-- @column ts Timestamp of lock contention start.
-- @column dur Duration of lock contention.
-- @column track_id Thread track id of blocked thread.
-- @column is_blocked_main_thread Whether the blocked thread is the main thread.
-- @column is_blocking_main_thread Whether the blocking thread is the main thread.
-- @column binder_reply_id Slice id of binder reply slice if lock contention was part of a binder txn.
-- @column binder_reply_ts Timestamp of binder reply slice if lock contention was part of a binder txn.
-- @column binder_reply_tid Tid of binder reply slice if lock contention was part of a binder txn.
CREATE TABLE android_monitor_contention AS
SELECT
  android_extract_android_monitor_contention_blocking_method(slice.name) AS blocking_method,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  android_extract_android_monitor_contention_blocked_method(slice.name)  AS blocked_method,
  android_extract_android_monitor_contention_short_blocking_method(slice.name) AS short_blocking_method,
  android_extract_android_monitor_contention_short_blocked_method(slice.name)  AS short_blocked_method,
  android_extract_android_monitor_contention_blocking_src(slice.name) AS blocking_src,
  android_extract_android_monitor_contention_blocked_src(slice.name) AS blocked_src,
  android_extract_android_monitor_contention_waiter_count(slice.name) AS waiter_count,
  thread.utid AS blocked_utid,
  thread.name AS blocked_thread_name,
  blocking_thread.utid AS blocking_utid,
  android_extract_android_monitor_contention_blocking_thread(slice.name) AS blocking_thread_name,
  android_extract_android_monitor_contention_blocking_tid(slice.name) AS blocking_tid,
  thread.upid AS upid,
  process.name AS process_name,
  slice.id,
  slice.ts,
  slice.dur,
  slice.track_id,
  thread.is_main_thread AS is_blocked_thread_main,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  thread.tid AS blocked_thread_tid,
  blocking_thread.is_main_thread AS is_blocking_thread_main,
  blocking_thread.tid AS blocking_thread_tid,
  binder_reply.id AS binder_reply_id,
  binder_reply.ts AS binder_reply_ts,
  binder_reply_thread.tid AS binder_reply_tid,
  process.pid
FROM slice
JOIN thread_track
  ON thread_track.id = slice.track_id
LEFT JOIN thread
  USING (utid)
LEFT JOIN process
  USING (upid)
LEFT JOIN ANCESTOR_SLICE(slice.id) binder_reply ON binder_reply.name = 'binder reply'
LEFT JOIN thread_track binder_reply_thread_track ON binder_reply.track_id = binder_reply_thread_track.id
LEFT JOIN thread binder_reply_thread ON binder_reply_thread_track.utid = binder_reply_thread.utid
JOIN internal_valid_android_monitor_contention ON internal_valid_android_monitor_contention.id = slice.id
JOIN thread blocking_thread ON blocking_thread.tid = blocking_tid AND blocking_thread.upid = thread.upid
WHERE slice.name GLOB 'monitor contention*'
  AND slice.dur != -1
  AND short_blocking_method IS NOT NULL
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  AND short_blocked_method IS NOT NULL
GROUP BY slice.id;

CREATE INDEX internal_android_monitor_contention_idx
  ON android_monitor_contention (blocking_utid, ts);

-- Monitor contention slices that are blocked by another monitor contention slice.
-- They will have a |parent_id| field which is the id of the slice they are blocked by.
CREATE PERFETTO TABLE internal_children AS
SELECT parent.id AS parent_id, child.* FROM android_monitor_contention child
JOIN android_monitor_contention parent ON parent.blocked_utid = child.blocking_utid
AND child.ts BETWEEN parent.ts AND parent.ts + parent.dur;

-- Monitor contention slices that are blocking another monitor contention slice.
-- They will have a |child_id| field which is the id of the slice they are blocking.
CREATE PERFETTO TABLE internal_parents AS
SELECT parent.*, child.id AS child_id FROM android_monitor_contention parent
JOIN android_monitor_contention child ON parent.blocked_utid = child.blocking_utid
AND child.ts BETWEEN parent.ts AND parent.ts + parent.dur;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Monitor contention slices that are neither blocking nor blocked by another monitor contention
-- slice. They neither have |parent_id| nor |child_id| fields.
CREATE TABLE internal_isolated AS
WITH
  x AS (
    SELECT id FROM android_monitor_contention
    EXCEPT
    SELECT id FROM internal_children
    UNION ALL
    SELECT id FROM internal_parents
  )
SELECT * FROM android_monitor_contention JOIN x USING (id);

-- Contains parsed monitor contention slices with the parent-child relationships.
--
-- @column parent_id Id of monitor contention slice blocking this contention.
-- @column blocking_method Name of the method holding the lock.
-- @column blocked_methhod Name of the method trying to acquire the lock.
-- @column short_blocking_method Blocking_method without arguments and return types.
-- @column short_blocked_method Blocked_method without arguments and return types.
-- @column blocking_src File location of blocking_method in form <filename:linenumber>.
-- @column blocked_src File location of blocked_method in form <filename:linenumber>.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column waiter_count Zero indexed number of threads trying to acquire the lock.
-- @column blocking_utid Utid of thread holding the lock.
-- @column blocking_thread_name Thread name of thread holding the lock.
-- @column upid Upid of process experiencing lock contention.
-- @column process_name Process name of process experiencing lock contention.
-- @column id Slice id of lock contention.
-- @column ts Timestamp of lock contention start.
-- @column dur Duration of lock contention.
-- @column track_id Thread track id of blocked thread.
-- @column is_blocked_main_thread Whether the blocked thread is the main thread.
-- @column is_blocking_main_thread Whether the blocking thread is the main thread.
-- @column binder_reply_id Slice id of binder reply slice if lock contention was part of a binder txn.
-- @column binder_reply_ts Timestamp of binder reply slice if lock contention was part of a binder txn.
-- @column binder_reply_tid Tid of binder reply slice if lock contention was part of a binder txn.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column child_id Id of monitor contention slice blocked by this contention.
CREATE TABLE android_monitor_contention_chain AS
SELECT NULL AS parent_id, *, NULL AS child_id FROM internal_isolated
UNION ALL
SELECT c.*, p.child_id FROM internal_children c
LEFT JOIN internal_parents p USING(id)
UNION
SELECT c.parent_id, p.* FROM internal_parents p
LEFT JOIN internal_children c USING(id);

CREATE INDEX internal_android_monitor_contention_chain_idx
  ON android_monitor_contention_chain (blocking_method, blocking_utid, ts);

-- First blocked node on a lock, i.e nodes with |waiter_count| = 0. The |dur| here is adjusted
-- to only account for the time between the first thread waiting and the first thread to acquire
-- the lock. That way, the thread state span joins below only compute the thread states where
-- the blocking thread is actually holding the lock. This avoids counting the time when another
-- waiter acquired the lock before the first waiter.
CREATE VIEW internal_first_blocked_contention
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  AS
SELECT start.id, start.blocking_utid, start.ts, MIN(end.ts + end.dur) - start.ts AS dur
FROM android_monitor_contention_chain start
JOIN android_monitor_contention_chain end
  ON
    start.blocking_utid = end.blocking_utid
    AND start.blocking_method = end.blocking_method
    AND end.ts BETWEEN start.ts AND start.ts + start.dur
WHERE start.waiter_count = 0
GROUP BY start.id;

CREATE VIEW internal_blocking_thread_state
AS
SELECT utid AS blocking_utid, ts, dur, state, blocked_function
FROM thread_state;

-- Contains the span join of the first waiters in the |android_monitor_contention_chain| with their
-- blocking_thread thread state.

-- Note that we only span join the duration where the lock was actually held and contended.
-- This can be less than the duration the lock was 'waited on' when a different waiter acquired the
-- lock earlier than the first waiter.
--
-- @column parent_id Id of slice blocking the blocking_thread.
-- @column blocking_method Name of the method holding the lock.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column blocked_methhod Name of the method trying to acquire the lock.
-- @column short_blocking_method Blocking_method without arguments and return types.
-- @column short_blocked_method Blocked_method without arguments and return types.
-- @column blocking_src File location of blocking_method in form <filename:linenumber>.
-- @column blocked_src File location of blocked_method in form <filename:linenumber>.
-- @column waiter_count Zero indexed number of threads trying to acquire the lock.
-- @column blocking_utid Utid of thread holding the lock.
-- @column blocking_thread_name Thread name of thread holding the lock.
-- @column upid Upid of process experiencing lock contention.
-- @column process_name Process name of process experiencing lock contention.
-- @column id Slice id of lock contention.
-- @column ts Timestamp of lock contention start.
-- @column dur Duration of lock contention.
-- @column track_id Thread track id of blocked thread.
-- @column is_blocked_main_thread Whether the blocked thread is the main thread.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column is_blocking_main_thread Whether the blocking thread is the main thread.
-- @column binder_reply_id Slice id of binder reply slice if lock contention was part of a binder txn.
-- @column binder_reply_ts Timestamp of binder reply slice if lock contention was part of a binder txn.
-- @column binder_reply_tid Tid of binder reply slice if lock contention was part of a binder txn.
-- @column blocking_utid Utid of the blocking |thread_state|.
-- @column ts Timestamp of the blocking |thread_state|.
-- @column state Thread state of the blocking thread.
-- @column blocked_function Blocked kernel function of the blocking thread.
CREATE VIRTUAL TABLE android_monitor_contention_chain_thread_state
USING
  SPAN_JOIN(internal_first_blocked_contention PARTITIONED blocking_utid,
            internal_blocking_thread_state PARTITIONED blocking_utid);

-- Aggregated thread_states on the 'blocking thread', the thread holding the lock.
-- This builds on the data from |android_monitor_contention_chain| and
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- for each contention slice, it returns the aggregated sum of all the thread states on the
-- blocking thread.
--
-- Note that this data is only available for the first waiter on a lock.
--
-- @column id Slice id of the monitor contention.
-- @column thread_state A |thread_state| that occurred in the blocking thread during the contention.
-- @column thread_state_dur Total time the blocking thread spent in the |thread_state| during
-- contention.
-- @column thread_state_count Count of all times the blocking thread entered |thread_state| during
-- the contention.
CREATE VIEW android_monitor_contention_chain_thread_state_by_txn
AS
SELECT
  id,
  state AS thread_state,
  SUM(dur) AS thread_state_dur,
  COUNT(dur) AS thread_state_count
FROM android_monitor_contention_chain_thread_state
GROUP BY id, thread_state;

-- Aggregated blocked_functions on the 'blocking thread', the thread holding the lock.
-- This builds on the data from |android_monitor_contention_chain| and
-- for each contention, it returns the aggregated sum of all the kernel
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- blocked function durations on the blocking thread.
--
-- Note that this data is only available for the first waiter on a lock.
--
-- @column id Slice id of the monitor contention.
-- @column blocked_function Blocked kernel function in a thread state in the blocking thread during
-- the contention.
-- @column blocked_function_dur Total time the blocking thread spent in the |blocked_function|
-- during the contention.
-- @column blocked_function_count Count of all times the blocking thread executed the
-- |blocked_function| during the contention.
CREATE VIEW android_monitor_contention_chain_blocked_functions_by_txn
AS
SELECT
  id,
  blocked_function,
  SUM(dur) AS blocked_function_dur,
  COUNT(dur) AS blocked_function_count
FROM android_monitor_contention_chain_thread_state
WHERE blocked_function IS NOT NULL
GROUP BY id, blocked_function;

-- Returns a DAG of all Java lock contentions in a process.
-- Each node in the graph is a <thread:Java method> pair.
-- Each edge connects from a node waiting on a lock to a node holding a lock.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- The weights of each node represent the cumulative wall time the node blocked
-- other nodes connected to it.
--
-- @arg upid INT      Upid of process to generate a lock graph for.
-- @ret pprof BYTES   Pprof of lock graph.
CREATE PERFETTO FUNCTION android_monitor_contention_graph(upid INT)
RETURNS TABLE(pprof BYTES) AS
WITH contention_chain AS (
SELECT *,
       IIF(blocked_thread_name GLOB 'binder:*', 'binder', blocked_thread_name)
        AS blocked_thread_name_norm,
       IIF(blocking_thread_name GLOB 'binder:*', 'binder', blocking_thread_name)
        AS blocking_thread_name_norm
FROM android_monitor_contention_chain WHERE upid = $upid
GROUP BY id, parent_id
), graph AS (
SELECT
  id,
  dur,
  CAT_STACKS(blocked_thread_name_norm || ':' || short_blocked_method,
    blocking_thread_name_norm || ':' || short_blocking_method) AS stack
FROM contention_chain
WHERE parent_id IS NULL
UNION ALL
SELECT
c.id,
c.dur AS dur,
  CAT_STACKS(blocked_thread_name_norm || ':' || short_blocked_method,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(             blocking_thread_name_norm || ':' || short_blocking_method, stack) AS stack
FROM contention_chain c, graph AS p
WHERE p.id = c.parent_id
) SELECT EXPERIMENTAL_PROFILE(stack, 'duration', 'ns', dur) AS pprof
  FROM graph;

)_d3l1m1t3r_"
;

const char kAndroidNetworkPackets[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Android network packet events (from android.network_packets data source).
--
-- @column ts                  Timestamp in nanoseconds.
-- @column dur                 Duration (non-zero only in aggregate events)
-- @column track_name          The track name (interface and direction)
-- @column package_name        Traffic package source (or uid=$X if not found)
-- @column iface               Traffic interface name (linux interface name)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column direction           Traffic direction ('Transmitted' or 'Received')
-- @column packet_count        Number of packets in this event
-- @column packet_length       Number of bytes in this event (wire size)
-- @column packet_transport    Transport used for traffic in this event
-- @column packet_tcp_flags    TCP flags used by tcp frames in this event
-- @column socket_tag          The Android traffic tag of the network socket
-- @column socket_uid          The Linux user id of the network socket
-- @column local_port          The local port number (for udp or tcp only)
-- @column remote_port         The remote port number (for udp or tcp only)
CREATE VIEW android_network_packets AS
SELECT
  ts,
  dur,
  track.name AS track_name,
  slice.name AS package_name,
  str_split(track.name, ' ', 0) AS iface,
  str_split(track.name, ' ', 1) AS direction,
  ifnull(extract_arg(arg_set_id, 'packet_count'), 1) AS packet_count,
  extract_arg(arg_set_id, 'packet_length') AS packet_length,
  extract_arg(arg_set_id, 'packet_transport') AS packet_transport,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  extract_arg(arg_set_id, 'packet_tcp_flags') AS packet_tcp_flags,
  extract_arg(arg_set_id, 'socket_tag') AS socket_tag,
  extract_arg(arg_set_id, 'socket_uid') AS socket_uid,
  extract_arg(arg_set_id, 'local_port') AS local_port,
  extract_arg(arg_set_id, 'remote_port') AS remote_port
FROM slice
JOIN track
  ON slice.track_id = track.id
WHERE (track.name GLOB '* Transmitted' OR
       track.name GLOB '* Received');

)_d3l1m1t3r_"
;

const char kAndroidProcessMetadata[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Count packages by package UID.
CREATE PERFETTO TABLE internal_uid_package_count AS
SELECT uid, COUNT(1) AS cnt
FROM package_list
GROUP BY 1;

-- Data about packages running on the process.
--
-- @column upid         Process upid.
-- @column process_name Process name.
-- @column package_name Name of the packages running in this process.
-- @column version_code Package version code.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column debuggable   Whether package is debuggable.
CREATE PERFETTO TABLE android_process_metadata AS
SELECT
  process.upid,
  -- workaround for b/169226092: the bug has been fixed it Android T, but
  -- we support ingesting traces from older Android versions.
  CASE
    -- cmdline gets rewritten after fork, if these are still there we must
    -- have seen a racy capture.
    WHEN length(process.name) = 15 AND (
      process.cmdline IN ('zygote', 'zygote64', '<pre-initialized>')
      OR process.cmdline GLOB '*' || process.name)
      THEN process.cmdline
    ELSE process.name
  END AS process_name,
  process.android_appid AS uid,
  CASE WHEN internal_uid_package_count.cnt > 1 THEN TRUE ELSE NULL END AS shared_uid,
  plist.package_name,
  plist.version_code,
  plist.debuggable
FROM process
LEFT JOIN internal_uid_package_count ON process.android_appid = internal_uid_package_count.uid
LEFT JOIN package_list plist
  ON (
    (
      process.android_appid = plist.uid
      AND internal_uid_package_count.uid = plist.uid
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      AND (
        -- unique match
        internal_uid_package_count.cnt = 1
        -- or process name starts with the package name
        OR process.name GLOB plist.package_name || '*')
    )
    OR
    (
      -- isolated processes can only be matched based on the name prefix
      process.android_appid >= 90000 AND process.android_appid < 100000
      AND STR_SPLIT(process.name, ':', 0) GLOB plist.package_name || '*'
    )
  );

)_d3l1m1t3r_"
;

const char kAndroidSlices[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Some slice names have params in them. This functions removes them to make it
-- possible to aggregate by name.
-- Some examples are:
--  - Lock/monitor contention slices. The name includes where the lock
--    contention is in the code. That part is removed.
--  - DrawFrames/ooFrame. The name also includes the frame number.
--  - Apk/oat/dex loading: The name of the apk is removed
--
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @arg name STRING   Raw name of the slice
-- @ret STRING        Simplified name.
CREATE PERFETTO FUNCTION android_standardize_slice_name(name STRING)
RETURNS STRING AS
SELECT
  CASE
    WHEN $name GLOB "Lock contention on*" THEN "Lock contention on <...>"
    WHEN $name GLOB "monitor contention with*" THEN "monitor contention with <...>"
    WHEN $name GLOB "SuspendThreadByThreadId*" THEN "SuspendThreadByThreadId <...>"
    WHEN $name GLOB "LoadApkAssetsFd*" THEN "LoadApkAssetsFd <...>"
    WHEN $name GLOB "relayoutWindow*" THEN "relayoutWindow <...>"
    WHEN $name GLOB "*CancellableContinuationImpl*" THEN "CoroutineContinuation"
    WHEN $name GLOB "Choreographer#doFrame*" THEN "Choreographer#doFrame"
    WHEN $name GLOB "DrawFrames*" THEN "DrawFrames"
    WHEN $name GLOB "/data/app*.apk" THEN "APK load"
    WHEN $name GLOB "OpenDexFilesFromOat*" THEN "OpenDexFilesFromOat"
    WHEN $name GLOB "Open oat file*" THEN "Open oat file"
    ELSE $name
  END;

)_d3l1m1t3r_"
;

const char kAndroidStatsd[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Statsd atoms.
--
-- A subset of the slice table containing statsd atom instant events.
--
-- @column id                        Unique identifier for this slice.
-- @column type                      The name of the "most-specific" child table containing this row.
-- @column ts                        The timestamp at the start of the slice (in nanoseconds).
-- @column dur                       The duration of the slice (in nanoseconds).
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column arg_set_id                The id of the argument set associated with this slice.
-- @column thread_instruction_count  The value of the CPU instruction counter at the start of the slice. This column will only be populated if thread instruction collection is enabled with track_event.
-- @column thread_instruction_delta  The change in value of the CPU instruction counter between the start and end of the slice. This column will only be populated if thread instruction collection is enabled with track_event.
-- @column track_id                  The id of the track this slice is located on.
-- @column category                  The "category" of the slice. If this slice originated with track_event, this column contains the category emitted. Otherwise, it is likely to be null (with limited exceptions).
-- @column name                      The name of the slice. The name describes what was happening during the slice.
-- @column depth                     The depth of the slice in the current stack of slices.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column stack_id                  A unique identifier obtained from the names of all slices in this stack. This is rarely useful and kept around only for legacy reasons.
-- @column parent_stack_id           The stack_id for the parent of this slice. Rarely useful.
-- @column parent_id                 The id of the parent (i.e. immediate ancestor) slice for this slice.
-- @column thread_ts                 The thread timestamp at the start of the slice. This column will only be populated if thread timestamp collection is enabled with track_event.
-- @column thread_dur                The thread time used by this slice. This column will only be populated if thread timestamp collection is enabled with track_event.
CREATE VIEW android_statsd_atoms AS
SELECT
  slice.id AS id,
  slice.type AS type,
  slice.ts AS ts,
  slice.dur AS dur,
  slice.arg_set_id AS arg_set_id,
  slice.thread_instruction_count AS thread_instruction_count,
  slice.thread_instruction_delta AS thread_instruction_delta,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  slice.track_id AS track_id,
  slice.category AS category,
  slice.name AS name,
  slice.depth AS depth,
  slice.stack_id AS stack_id,
  slice.parent_stack_id AS parent_stack_id,
  slice.parent_id AS parent_id,
  slice.thread_ts AS thread_ts,
  slice.thread_dur AS thread_dur
FROM slice
JOIN track ON slice.track_id = track.id
WHERE
  track.name = 'Statsd Atoms';



)_d3l1m1t3r_"
;

const char kAndroidThread[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

CREATE PERFETTO FUNCTION internal_thread_prefix(thread_name STRING)
RETURNS STRING AS
SELECT STR_SPLIT(STR_SPLIT(STR_SPLIT(STR_SPLIT($thread_name, "-", 0), "[", 0), ":", 0), " ", 0);

-- Per process stats of threads created in a process
--
-- @arg min_thread_dur FLOAT       Minimum duration between creating and destroying a thread before
-- their the thread creation event is considered. If NULL, considers all thread creations.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @arg sliding_window_dur FLOAT   Sliding window duration for counting the thread creations. Each
-- window starts at the first thread creation per <process, thread_name_prefix>.
--
-- @column process_name            Process name creating threads.
-- @column pid                     Process pid creating threads.
-- @column thread_name_prefix      String prefix of thread names created.
-- @column max_count_per_sec       Max number of threads created within a time window.
SELECT CREATE_VIEW_FUNCTION(
    'ANDROID_THREAD_CREATION_SPAM(min_thread_dur FLOAT, sliding_window_dur FLOAT)',
    'process_name STRING, pid INT, thread_name_prefix STRING, max_count_per_sec INT',
    '
    WITH
      x AS (
        SELECT
          pid,
          upid,
          INTERNAL_THREAD_PREFIX(thread.name) AS thread_name_prefix,
          process.name AS process_name,
          COUNT(thread.start_ts)
            OVER (
              PARTITION BY upid, thread.name
              ORDER BY thread.start_ts
              RANGE BETWEEN CURRENT ROW AND CAST($sliding_window_dur AS INT64) FOLLOWING
)_d3l1m1t3r_"
R"_d3l1m1t3r_(            ) AS count
        FROM thread
        JOIN process
          USING (upid)
        WHERE
          ($min_thread_dur AND (thread.end_ts - thread.start_ts) <= $min_thread_dur)
          OR $min_thread_dur IS NULL
      )
    SELECT process_name, pid, thread_name_prefix, MAX(count) AS max_count_per_sec
    FROM x
    GROUP BY upid, thread_name_prefix
    HAVING max_count_per_sec > 0
    ORDER BY count DESC;
    '
);

)_d3l1m1t3r_"
;

const char kChromeChromeScrollJanks[] = R"_d3l1m1t3r_(-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- TODO(b/286187288): Move this dependency to stdlib.
SELECT IMPORT('chrome.chrome_scrolls');
SELECT RUN_METRIC('chrome/chrome_scroll_jank_v3.sql');
SELECT IMPORT('common.slices');

-- Selects EventLatency slices that correspond with janks in a scroll. This is
-- based on the V3 version of scroll jank metrics.
--
-- @column id INT                     The slice id.
-- @column ts INT                     The start timestamp of the slice.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column dur INT                    The duration of the slice.
-- @column track_id INT               The track_id for the slice.
-- @column name STRING                The name of the slice (EventLatency).
-- @column cause_of_jank STRING       The stage of EventLatency that the caused
--                                    the jank.
-- @column sub_cause_of_jank STRING   The stage of cause_of_jank that caused the
--                                    jank.
-- @column delayed_frame_count INT    How many vsyncs this frame missed its
--                                    deadline by.
-- @column frame_jank_ts INT          The start timestamp where frame
--                                    frame presentation was delayed.
-- @column frame_jank_dur INT         The duration in ms of the delay in frame
--                                    presentation.
CREATE PERFETTO TABLE chrome_janky_event_latencies_v3 AS
SELECT
  s.id,
  s.ts,
  s.dur,
  s.track_id,
  s.name,
  e.cause_of_jank,
  e.sub_cause_of_jank,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  CAST((e.delay_since_last_frame/e.vsync_interval) - 1 AS INT) AS delayed_frame_count,
  CAST(s.ts + s.dur - ((e.delay_since_last_frame - e.vsync_interval) * 1e6) AS INT) AS frame_jank_ts,
  CAST((e.delay_since_last_frame - e.vsync_interval) * 1e6 AS INT) AS frame_jank_dur
FROM slice s
JOIN chrome_janky_frames e
  ON s.id = e. event_latency_id;

-- Frame presentation interval is the delta between when the frame was supposed
-- to be presented and when it was actually presented.
--
-- @column id INT                     Unique id.
-- @column ts INT                     The start timestamp of the slice.
-- @column dur INT                    The duration of the slice.
-- @column delayed_frame_count INT    How many vsyncs this frame missed its
--                                    deadline by.
-- @column cause_of_jank STRING       The stage of EventLatency that the caused
--                                    the jank.
-- @column sub_cause_of_jank STRING   The stage of cause_of_jank that caused the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--                                    jank.
-- @column event_latency_id STRING    The id of the associated event latency in
--                                    the slice table.
CREATE VIEW chrome_janky_frame_presentation_intervals AS
SELECT
  ROW_NUMBER() OVER(ORDER BY frame_jank_ts) AS id,
  frame_jank_ts AS ts,
  frame_jank_dur AS dur,
  delayed_frame_count,
  cause_of_jank,
  sub_cause_of_jank,
  id AS event_latency_id
FROM chrome_janky_event_latencies_v3;

-- Scroll jank frame presentation stats for individual scrolls.
--
-- @column scroll_id INT              Id of the individual scroll.
-- @column missed_vsyncs INT          The number of missed vsyncs in the scroll.
-- @column frame_count INT            The number of frames in the scroll.
-- @column presented_frame_count INT  The number presented frames in the scroll.
-- @column janky_frame_count INT      The number of janky frames in the scroll.
-- @column janky_frame_percent FLOAT  The % of frames that janked in the scroll.
CREATE VIEW chrome_scroll_stats AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WITH vsyncs AS (
  SELECT
    COUNT() AS presented_vsync_count,
    scroll.id AS scroll_id
  FROM chrome_unique_frame_presentation_ts frame
  JOIN chrome_scrolls scroll
    ON frame.presentation_timestamp >= scroll.ts
    AND frame.presentation_timestamp <= scroll.ts + scroll.dur
  GROUP BY scroll_id),
missed_vsyncs AS (
  SELECT
    CAST(SUM((delay_since_last_frame / vsync_interval) - 1) AS INT)  AS total_missed_vsyncs,
    scroll_id
  FROM chrome_janky_frames
  GROUP BY scroll_id),
frame_stats AS (
  SELECT
    scroll_id,
    num_frames AS presented_frame_count,
    IFNULL(num_janky_frames, 0) AS janky_frame_count,
    ROUND(IFNULL(scroll_jank_percentage, 0), 2) AS janky_frame_percent
  FROM frames_per_scroll
)
SELECT
  vsyncs.scroll_id,
  presented_vsync_count + IFNULL(total_missed_vsyncs, 0) AS frame_count,
  total_missed_vsyncs AS missed_vsyncs,
  presented_frame_count,
  janky_frame_count,
  janky_frame_percent
FROM vsyncs
LEFT JOIN missed_vsyncs
  USING (scroll_id)
LEFT JOIN frame_stats
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  USING (scroll_id);

-- Defines slices for all of janky scrolling intervals in a trace.
--
-- @column id            The unique identifier of the janky interval.
-- @column ts            The start timestamp of the janky interval.
-- @column dur           The duration of the janky interval.
CREATE PERFETTO TABLE chrome_scroll_jank_intervals_v3 AS
-- Sub-table to retrieve all janky slice timestamps. Ordering calculations are
-- based on timestamps rather than durations.
WITH janky_latencies AS (
  SELECT
    s.frame_jank_ts AS start_ts,
    s.frame_jank_ts + s.frame_jank_dur AS end_ts
  FROM chrome_janky_event_latencies_v3 s),
-- Determine the local maximum timestamp for janks thus far; this will allow
-- us to coalesce all earlier events up to the maximum.
ordered_jank_end_ts AS (
  SELECT
    *,
    MAX(end_ts) OVER (
      ORDER BY start_ts ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
      AS max_end_ts_so_far
  FROM janky_latencies),
-- Determine the local minimum timestamp for janks thus far; this will allow
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- us to coalesce all later events up to the nearest local maximum.
range_starts AS (
  SELECT
    *,
    CASE
      -- This is a two-pass calculation to calculate the first event in the
      -- group. An event is considered the first event in a group if all events
      -- which started before it also finished the current one started.
      WHEN start_ts <= 1 + LAG(max_end_ts_so_far) OVER (ORDER BY start_ts) THEN 0
      ELSE 1
    END AS range_start
  FROM ordered_jank_end_ts),
-- Assign an id to allow coalescing of individual slices.
range_groups AS (
  SELECT
    *,
    SUM(range_start) OVER (ORDER BY start_ts) AS range_group
  FROM range_starts)
-- Coalesce all slices within an interval.
SELECT
  range_group AS id,
  MIN(start_ts) AS ts,
  MAX(end_ts) - MIN(start_ts) AS dur
FROM range_groups
GROUP BY range_group;

)_d3l1m1t3r_"
;

const char kChromeChromeScrolls[] = R"_d3l1m1t3r_(-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Defines slices for all of the individual scrolls in a trace based on the
-- LatencyInfo-based scroll definition.
--
-- @column id            The unique identifier of the scroll.
-- @column ts            The start timestamp of the scroll.
-- @column dur           The duration of the scroll.
--
-- NOTE: this view of top level scrolls is based on the LatencyInfo definition
-- of a scroll, which differs subtly from the definition based on
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- EventLatencies.
-- TODO(b/278684408): add support for tracking scrolls across multiple Chrome/
-- WebView instances. Currently gesture_scroll_id unique within an instance, but
-- is not unique across multiple instances. Switching to an EventLatency based
-- definition of scrolls should resolve this.
CREATE PERFETTO TABLE chrome_scrolls AS
WITH all_scrolls AS (
  SELECT
    name,
    ts,
    dur,
    extract_arg(arg_set_id, 'chrome_latency_info.gesture_scroll_id') AS scroll_id
  FROM slice
  WHERE name GLOB 'InputLatency::GestureScroll*'
  AND extract_arg(arg_set_id, 'chrome_latency_info.gesture_scroll_id') IS NOT NULL
),
scroll_starts AS (
  SELECT
    scroll_id,
    MIN(ts) AS scroll_start_ts
  FROM all_scrolls
  WHERE name = 'InputLatency::GestureScrollBegin'
  GROUP BY scroll_id
), scroll_ends AS (
  SELECT
    scroll_id,
    MIN(ts) AS scroll_end_ts
  FROM all_scrolls
  WHERE name = 'InputLatency::GestureScrollEnd'
  GROUP BY scroll_id
)
SELECT
  sa.scroll_id AS id,
  MIN(ts) AS ts,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  CAST(MAX(ts + dur) - MIN(ts) AS INT) AS dur,
  ss.scroll_start_ts AS scroll_start_ts,
  se.scroll_end_ts AS scroll_end_ts
FROM all_scrolls sa
  LEFT JOIN scroll_starts ss ON
    sa.scroll_id = ss.scroll_id
  LEFT JOIN scroll_ends se ON
    sa.scroll_id = se.scroll_id
GROUP BY sa.scroll_id;

-- Defines slices for all of scrolls intervals in a trace based on the scroll
-- definition in chrome_scrolls. Note that scrolls may overlap (particularly in
-- cases of jank/broken traces, etc); so scrolling intervals are not exactly the
-- same as individual scrolls.
--
-- @column id            The unique identifier of the scroll interval. This may
--                       span multiple scrolls if they overlap.
-- @column ts            The start timestamp of the scroll interval.
-- @column dur           The duration of the scroll interval.
CREATE VIEW chrome_scrolling_intervals AS
WITH all_scrolls AS (
  SELECT
    id AS scroll_id,
    s.ts AS start_ts,
    s.ts + s.dur AS end_ts
  FROM chrome_scrolls s),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(ordered_end_ts AS (
  SELECT
    *,
    MAX(end_ts) OVER (ORDER BY start_ts) AS max_end_ts_so_far
  FROM all_scrolls),
range_starts AS (
  SELECT
    *,
    CASE
      WHEN start_ts <= 1 + LAG(max_end_ts_so_far) OVER (ORDER BY start_ts) THEN 0
      ELSE 1
    END AS range_start
  FROM ordered_end_ts),
range_groups AS (
  SELECT
    *,
    SUM(range_start) OVER (ORDER BY start_ts) AS range_group
  FROM range_starts)
SELECT
  range_group AS id,
  GROUP_CONCAT(scroll_id) AS scroll_ids,
  MIN(start_ts) AS ts,
  MAX(end_ts) - MIN(start_ts) AS dur
FROM range_groups
GROUP BY range_group;

)_d3l1m1t3r_"
;

const char kChromeCpuPowerups[] = R"_d3l1m1t3r_(-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Find causes for CPUs powering up.
--
-- The scripts below analyse traces with the following tracing options
-- enabled:
--
--  - Linux kernel:
---    "power/*", "sched/*", "task/*",
--  - Chromium:
--      "toplevel", "toplevel.flow".

-- Noteworthy tables:
--
--   chrome_cpu_power_first_toplevel_slice_after_powerup :: The top-level
--      slices that ran after a CPU power-up.

-- The CPU power transitions in the trace.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--
-- @column ts            The timestamp at the start of the slice.
-- @column dur           The duration of the slice.
-- @column cpu           The CPU on which the transition occurred
-- @column power_state   The power state that the CPU was in at time 'ts' for
--                       duration 'dur'.
-- @column previous_power_state The power state that the CPU was previously in.
-- @column powerup_id    A unique ID for the CPU power-up.
--
-- Power states are encoded as non-negative integers, with zero representing
-- full-power operation and positive values representing increasingly deep
-- sleep states.
--
-- On ARM systems, power state 1 represents the WFI (Wait For Interrupt) sleep
-- state that the CPU enters while idle.
CREATE VIEW chrome_cpu_power_slice AS
  WITH cpu_power_states AS (
    SELECT
      c.id AS id,
      cct.cpu AS cpu,
      c.ts,
      -- Encode the 'value' field as a power state.
      CAST((CASE c.value WHEN 4294967295 THEN 0 ELSE c.value + 1 END)
        AS INT) AS power_state
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    FROM counter AS c
    JOIN cpu_counter_track AS cct
      ON c.track_id = cct.id
    WHERE cct.name = 'cpuidle'
  )
  SELECT *
  FROM (
    SELECT
      ts,
      LEAD(ts) OVER (PARTITION BY cpu ORDER BY ts ASC) - ts
        AS dur,
      cpu,
      power_state,
      LAG(power_state) OVER (PARTITION BY cpu ORDER BY ts ASC)
        AS previous_power_state,
      id AS powerup_id
    FROM cpu_power_states
  )
  WHERE dur IS NOT NULL
    AND previous_power_state IS NOT NULL
    AND power_state = 0                      -- Track full-power states.
    AND power_state != previous_power_state  -- Skip missing spans.
    ORDER BY ts ASC;

-- We do not want scheduler slices with utid = 0 (the 'swapper' kernel thread).
CREATE VIEW internal_cpu_power_valid_sched_slice AS
  SELECT *
  FROM sched_slice
  WHERE utid != 0;

-- Join scheduler slices with the spans with CPU power slices.
--
-- There multiple scheduler slices could fall into one CPU power slice.
--
---  CPU Power:
--   |----------------------------|....................|---------|
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--   A       <cpu active>         B     <cpu idling>   C         D

--   Scheduler slices on that CPU:
--     |-----T1-----| |....T2....|                      |---T3--|
--     E            F G          H                      I       J
--
-- Here threads T1 and T2 executed in CPU power slice [A,B].  The
-- time between F and G represents time between threads in the kernel.
CREATE VIRTUAL TABLE internal_cpu_power_and_sched_slice
USING
  SPAN_JOIN(chrome_cpu_power_slice PARTITIONED cpu,
            internal_cpu_power_valid_sched_slice PARTITIONED cpu);

-- The Linux scheduler slices that executed immediately after a
-- CPU power up.
--
-- @column ts          The timestamp at the start of the slice.
-- @column dur         The duration of the slice.
-- @column cpu         The cpu on which the slice executed.
-- @column sched_id    Id for the sched_slice table.
-- @column utid        Unique id for the thread that ran within the slice.
-- @column previous_power_state   The CPU's power state before this slice.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO TABLE chrome_cpu_power_first_sched_slice_after_powerup AS
  SELECT
    ts,
    dur,
    cpu,
    id AS sched_id,
    utid,
    previous_power_state,
    powerup_id
  FROM internal_cpu_power_and_sched_slice
  WHERE power_state = 0     -- Power-ups only.
  GROUP BY cpu, powerup_id
  HAVING ts = MIN(ts)       -- There will only be one MIN sched slice
                            -- per CPU power up.
  ORDER BY ts ASC;

-- A view joining thread tracks and top-level slices.
--
-- This view is intended to be intersected by time with the scheduler
-- slices scheduled after a CPU power up.
--
--   utid      Thread unique id.
--   slice_id  The slice_id for the top-level slice.
--   ts        Starting timestamp for the slice.
--   dur       The duration for the slice.
CREATE VIEW internal_cpu_power_thread_and_toplevel_slice AS
  SELECT
    t.utid AS utid,
    s.id AS slice_id,
    s.ts,
    s.dur
  FROM slice AS s
  JOIN thread_track AS t
    ON s.track_id = t.id
  WHERE s.depth = 0   -- Top-level slices only.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ORDER BY ts ASC;

-- A table holding the slices that executed within the scheduler
-- slice that ran on a CPU immediately after power-up.
--
-- @column  ts        Timestamp of the resulting slice
-- @column dur        Duration of the slice.
-- @column cpu        The CPU the sched slice ran on.
-- @column utid       Unique thread id for the slice.
-- @column sched_id   'id' field from the sched_slice table.
-- @column type       From the sched_slice table, always 'sched_slice'.
-- @column end_state  The ending state for the sched_slice
-- @column priority   The kernel thread priority
-- @column slice_id   Id of the top-level slice for this (sched) slice.
CREATE VIRTUAL TABLE chrome_cpu_power_post_powerup_slice
USING
  SPAN_JOIN(chrome_cpu_power_first_sched_slice_after_powerup PARTITIONED utid,
            internal_cpu_power_thread_and_toplevel_slice PARTITIONED utid);

-- The first top-level slice that ran after a CPU power-up.
--
-- @column slice_id              ID of the slice in the slice table.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column previous_power_state  The power state of the CPU prior to power-up.
CREATE VIEW chrome_cpu_power_first_toplevel_slice_after_powerup AS
  SELECT slice_id, previous_power_state
  FROM chrome_cpu_power_post_powerup_slice
  GROUP BY cpu, powerup_id
  HAVING ts = MIN(ts)
  ORDER BY ts ASC;

)_d3l1m1t3r_"
;

const char kChromeHistograms[] = R"_d3l1m1t3r_(-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

DROP VIEW IF EXISTS chrome_histograms;

-- A helper view on top of the histogram events emitted by Chrome.
-- Requires "disabled-by-default-histogram_samples" Chrome category.
--
-- @column name          The name of the histogram.
-- @column value         The value of the histogram sample.
-- @column ts            Alias of |slice.ts|.
-- @column thread_name   Thread name.
-- @column utid          Utid of the thread.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column tid           Tid of the thread.
-- @column process_name  Process name.
-- @column upid          Upid of the process.
-- @column pid           Pid of the process.
CREATE VIEW chrome_histograms AS
SELECT
  extract_arg(slice.arg_set_id, "chrome_histogram_sample.name") as name,
  extract_arg(slice.arg_set_id, "chrome_histogram_sample.sample") as value,
  ts,
  thread.name as thread_name,
  thread.utid as utid,
  thread.tid as tid,
  process.name as process_name,
  process.upid as upid,
  process.pid as pid
FROM slice
JOIN thread_track ON thread_track.id = slice.track_id
JOIN thread USING (utid)
JOIN process USING (upid)
WHERE
  slice.name = "HistogramSample"
  AND category = "disabled-by-default-histogram_samples";
)_d3l1m1t3r_"
;

const char kChromeMetadata[] = R"_d3l1m1t3r_(-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Returns hardware class of the device, often use to find device brand
-- and model.
-- @ret STRING Hardware class name.
CREATE PERFETTO FUNCTION chrome_hardware_class()
RETURNS STRING AS
SELECT
  str_value
  FROM metadata
WHERE name = "cr-hardware-class";
)_d3l1m1t3r_"
;

const char kChromeSpeedometer[] = R"_d3l1m1t3r_(-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Annotates a trace with Speedometer 2.1 related information.
--
-- The scripts below analyse traces with the following tracing options
-- enabled:
--
--  - Chromium:
--      "blink.user_timing".
--
--  NOTE: A regular speedometer run (e.g. from the website) will generate the
--  required events. No need to add any extra JS or anything.
--
-- Noteworthy tables:
--   speedometer_mark: List of marks (event slices) emitted by Speedometer.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--       These are the points in time Speedometer makes a clock reading to
--       compute intervals of time for the final score.
--   speedometer_measure_slice: Augmented slices for Speedometer measurements.
--       These are the intervals of time Speedometer uses to compute the final
--       score.
--   speedometer_iteration_slice: Slice that covers one Speedometer iteration
--       and has the total_time and score for it. If you average all the scores
--       over all iterations you get the final Speedometer score for the run.

-- List of marks (event slices) emitted by Speedometer.
-- These are the points in time Speedometer makes a clock reading to compute
-- intervals of time for the final score.
--
-- @column slice_id      Slice this data refers to.
-- @column iteration     Speedometer iteration the mark belongs to.
-- @column suite_name    Suite name
-- @column test_name     Test name
-- @column mark_type     Type of mark (start, sync-end, async-end)
CREATE VIEW internal_chrome_speedometer_mark
)_d3l1m1t3r_"
R"_d3l1m1t3r_(AS
WITH
  speedometer_21_suite_name(suite_name) AS (
    VALUES
      ('VanillaJS-TodoMVC'),
      ('Vanilla-ES2015-TodoMVC'),
      ('Vanilla-ES2015-Babel-Webpack-TodoMVC'),
      ('React-TodoMVC'),
      ('React-Redux-TodoMVC'),
      ('EmberJS-TodoMVC'),
      ('EmberJS-Debug-TodoMVC'),
      ('BackboneJS-TodoMVC'),
      ('AngularJS-TodoMVC'),
      ('Angular2-TypeScript-TodoMVC'),
      ('VueJS-TodoMVC'),
      ('jQuery-TodoMVC'),
      ('Preact-TodoMVC'),
      ('Inferno-TodoMVC'),
      ('Elm-TodoMVC'),
      ('Flight-TodoMVC')
  ),
  speedometer_21_test_name(test_name) AS (
    VALUES
      ('Adding100Items'),
      ('CompletingAllItems'),
      -- This seems to be an issue with Speedometer 2.1. All tests delete all items,
      -- but for some reason the test names do not match for all suites.
      ('DeletingAllItems'),
      ('DeletingItems')
  ),
  speedometer_21_test_mark_type(mark_type) AS (
    VALUES
      ('start'),
      ('sync-end'),
      ('async-end')
  ),
  -- Make sure we only look at slices with names we expect.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  speedometer_mark_name AS (
    SELECT
      s.suite_name || '.' || t.test_name || '-' || m.mark_type AS name,
      s.suite_name,
      t.test_name,
      m.mark_type
    FROM
      speedometer_21_suite_name AS s,
      speedometer_21_test_name AS t,
      speedometer_21_test_mark_type AS m
  )
SELECT
  s.id AS slice_id,
  RANK() OVER (PARTITION BY name ORDER BY ts ASC) AS iteration,
  m.suite_name,
  m.test_name,
  m.mark_type
FROM slice AS s
JOIN speedometer_mark_name AS m
  USING (name)
WHERE category = 'blink.user_timing';

-- Augmented slices for Speedometer measurements.
-- These are the intervals of time Speedometer uses to compute the final score.
-- There are two intervals that are measured for every test: sync and async
-- sync is the time between the start and sync-end marks, async is the time
-- between the sync-end and async-end marks.
--
-- @column iteration     Speedometer iteration the mark belongs to.
-- @column suite_name    Suite name
-- @column test_name     Test name
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column measure_type  Type of the measure (sync or async)
-- @column ts            Start timestamp of the measure
-- @column dur           Duration of the measure
CREATE VIEW chrome_speedometer_measure
AS
WITH
  -- Get the 3 test timestamps (start, sync-end, async-end) in one row. Using a
  -- the LAG window function and partitioning by test. 2 out of the 3 rows
  -- generated per test will have some NULL ts values.
  augmented AS (
    SELECT
      iteration,
      suite_name,
      test_name,
      ts AS async_end_ts,
      LAG(ts, 1)
        OVER (PARTITION BY iteration, suite_name, test_name ORDER BY ts ASC)
        AS sync_end_ts,
      LAG(ts, 2)
        OVER (PARTITION BY iteration, suite_name, test_name ORDER BY ts ASC)
        AS start_ts,
      COUNT()
        OVER (PARTITION BY iteration, suite_name, test_name ORDER BY ts ASC)
        AS mark_count
    FROM internal_chrome_speedometer_mark
    JOIN slice
      USING (slice_id)
  ),
  filtered AS (
    SELECT *
    FROM augmented
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- This server 2 purposes: make sure we have all the marks (think truncated
    -- trace), and remove the NULL ts values due to the LAG window function.
    WHERE mark_count = 3
  )
SELECT
  iteration,
  suite_name,
  test_name,
  'async' AS measure_type,
  sync_end_ts AS ts,
  async_end_ts - sync_end_ts AS dur
FROM filtered
UNION ALL
SELECT
  iteration,
  suite_name,
  test_name,
  'sync' AS measure_type,
  start_ts AS ts,
  sync_end_ts - start_ts AS dur
FROM filtered;

-- Slice that covers one Speedometer iteration.
-- This slice is actually estimated as a default Speedometer run will not emit
-- marks to cover this interval. The metrics associated are the same ones
-- Speedometer would output, but note we use ns precision (Speedometer uses
-- ~100us) so the actual values might differ a bit. Also note Speedometer
-- returns the values in ms these here and in ns.
--
-- @column iteration Speedometer iteration.
-- @column ts        Start timestamp of the iteration
-- @column dur       Duration of the iteration
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column total     Total duration of the measures in this iteration
-- @column mean      Average suite duration for this iteration.
-- @column geomean   Geometric mean of the suite durations for this iteration.
-- @column score     Speedometer score for this iteration (The total score for a
--                   run in the average of all iteration scores).
CREATE VIEW chrome_speedometer_iteration
AS
SELECT
  iteration,
  MIN(start) AS ts,
  MAX(end) - MIN(start) AS dur,
  SUM(suite_total) AS total,
  AVG(suite_total)AS mean,
  -- Compute geometric mean using LN instead of multiplication to prevent
  -- overflows
  EXP(AVG(LN(suite_total))) AS geomean,
  1e9 / EXP(AVG(LN(suite_total))) * 60 / 3 AS score
FROM
  (
    SELECT
      iteration, SUM(dur) AS suite_total, MIN(ts) AS start, MAX(ts + dur) AS end
    FROM chrome_speedometer_measure
    GROUP BY suite_name, iteration
  )
GROUP BY iteration;

)_d3l1m1t3r_"
;

const char kChromeTasks[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

SELECT IMPORT("common.slices");

-- Returns the mojo ipc hash for a given task, looking it up from the
-- argument of descendant ScopedSetIpcHash slice.
-- This is relevant only for the older Chrome traces, where mojo IPC
-- hash was reported in a separate ScopedSetIpcHash slice.
CREATE PERFETTO FUNCTION internal_extract_mojo_ipc_hash(slice_id INT)
RETURNS INT AS
SELECT EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.ipc_hash")
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM descendant_slice($slice_id)
WHERE name="ScopedSetIpcHash"
ORDER BY id
LIMIT 1;

-- Returns the frame type (main frame vs subframe) for key navigation tasks
-- which capture the associated RenderFrameHost in an argument.
CREATE PERFETTO FUNCTION internal_extract_frame_type(slice_id INT)
RETURNS INT AS
SELECT EXTRACT_ARG(arg_set_id, "render_frame_host.frame_type")
FROM descendant_slice($slice_id)
WHERE name IN (
  "RenderFrameHostImpl::BeginNavigation",
  "RenderFrameHostImpl::DidCommitProvisionalLoad",
  "RenderFrameHostImpl::DidCommitSameDocumentNavigation",
  "RenderFrameHostImpl::DidStopLoading"
)
LIMIT 1;

-- Human-readable aliases for a few key navigation tasks.
CREATE PERFETTO FUNCTION internal_human_readable_navigation_task_name(task_name STRING)
RETURNS STRING AS
SELECT
  CASE
    WHEN $task_name = "content.mojom.FrameHost message (hash=2168461044)"
      THEN "FrameHost::BeginNavigation"
    WHEN $task_name = "content.mojom.FrameHost message (hash=3561497419)"
      THEN "FrameHost::DidCommitProvisionalLoad"
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHEN $task_name = "content.mojom.FrameHost message (hash=1421450774)"
      THEN "FrameHost::DidCommitSameDocumentNavigation"
    WHEN $task_name = "content.mojom.FrameHost message (hash=368650583)"
      THEN "FrameHost::DidStopLoading"
  END;

-- Takes a task name and formats it correctly for scheduler tasks.
CREATE PERFETTO FUNCTION internal_format_scheduler_task_name(task_name STRING)
RETURNS STRING AS
SELECT printf("RunTask(posted_from=%s)", $task_name);

-- Takes the category and determines whether it is "Java" only, as opposed to
-- "toplevel,Java".
CREATE PERFETTO FUNCTION internal_java_not_top_level_category(category STRING)
RETURNS BOOL AS
SELECT $category GLOB "*Java*" AND $category not GLOB "*toplevel*";

-- Takes the category and determines whether is any valid
-- toplevel category or combination of categories.
CREATE PERFETTO FUNCTION internal_any_top_level_category(category STRING)
RETURNS BOOL AS
SELECT $category IN ("toplevel", "toplevel,viz", "toplevel,Java");

-- TODO(altimin): the situations with kinds in this file is a bit of a mess.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- The idea is that it should work as `type` in the `slice` table, pointing to
-- a "child" table with more information about the task (e.g. posted_from for
-- scheduler tasks). Currently this is not the case and needs a cleanup.
-- Also we should align this with how table inheritance should work for
-- `CREATE PERFETTO TABLE`.

-- Get task type for a given task kind.
CREATE PERFETTO FUNCTION internal_get_java_views_task_type(kind STRING)
RETURNS STRING AS
SELECT
  CASE $kind
    WHEN "Choreographer" THEN "choreographer"
    WHEN "SingleThreadProxy::BeginMainFrame" THEN "ui_thread_begin_main_frame"
  END;

-- All slices corresponding to receiving mojo messages.
-- On the newer Chrome versions, it's just "Receive mojo message" and
-- "Receive mojo reply" slices (or "Receive {mojo_message_name}" if
-- built with `extended_tracing_enabled`. On legacy Chrome versions,
-- other appropriate messages (like "Connector::DispatchMessage") are used.
--
-- @column STRING interface_name    Name of the IPC interface.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column INT ipc_hash             Hash of a message name.
-- @column STRING message_type      Either 'message' or 'reply'.
-- @column INT id                   Slice id.
--
-- Note: this might include messages received within a sync mojo call.
-- TODO(altimin): This should use EXTEND_TABLE when it becomes available.
CREATE TABLE internal_chrome_mojo_slices AS
WITH
-- Select all new-style (post crrev.com/c/3270337) mojo slices and
-- generate |task_name| for them.
-- If extended tracing is enabled, the slice name will have the full method
-- name (i.e. "Receive content::mojom::FrameHost::DidStopLoading") and we
-- should use it as a full name.
-- If extended tracing is not enabled, we should include the interface name
-- and method hash into the full name.
new_mojo_slices AS (
  SELECT
    EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.mojo_interface_tag") AS interface_name,
    EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.ipc_hash") AS ipc_hash,
    CASE name
      WHEN "Receive mojo message" THEN "message"
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      WHEN "Receive mojo reply" THEN "reply"
    END AS message_type,
    id
  FROM slice
  WHERE
    category GLOB '*toplevel*'
    AND name GLOB 'Receive *'
),
-- Select old-style slices for channel-associated mojo events.
old_associated_mojo_slices AS (
  SELECT
    name AS interface_name,
    internal_extract_mojo_ipc_hash(id) AS ipc_hash,
    "message" AS message_type,
    id
  FROM slice
  WHERE
    category GLOB "*mojom*"
    AND name GLOB '*.mojom.*'
),
-- Select old-style slices for non-(channel-associated) mojo events.
old_non_associated_mojo_slices AS (
  SELECT
    COALESCE(
      EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.watcher_notify_interface_tag"),
      EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.mojo_interface_tag")
    ) AS interface_name,
    internal_extract_mojo_ipc_hash(id) AS ipc_hash,
    "message" AS message_type,
    id
  FROM slice
  WHERE
    category GLOB "*toplevel*" AND name = "Connector::DispatchMessage"
)
-- Merge all mojo slices.
SELECT * FROM new_mojo_slices
)_d3l1m1t3r_"
R"_d3l1m1t3r_(UNION ALL
SELECT * FROM old_associated_mojo_slices
UNION ALL
SELECT * FROM old_non_associated_mojo_slices;

-- As we lookup by ID on |internal_chrome_mojo_slices| table, add an index on
-- id to make lookups fast.
CREATE INDEX internal_chrome_mojo_slices_idx ON internal_chrome_mojo_slices(id);

-- This table contains a list of slices corresponding to the _representative_
-- Chrome Java view operations.
-- These are the outermost Java view slices after filtering out generic framework views
-- (like FitWindowsLinearLayout) and selecting the outermost slices from the remaining ones.
--
-- @column id INT                       Slice id.
-- @column ts INT                       Timestamp.
-- @column dur INT                      Duration.
-- @column name STRING                  Name of the view.
-- @column is_software_screenshot BOOL  Whether this slice is a part of non-accelerated
--                                      capture toolbar screenshot.
-- @column is_hardware_screenshot BOOL  Whether this slice is a part of accelerated
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--                                      capture toolbar screenshot.
CREATE TABLE internal_chrome_java_views AS
WITH
-- .draw, .onLayout and .onMeasure parts of the java view names don't add much, strip them.
java_slices_with_trimmed_names AS (
  SELECT
    id,
    REPLACE(
      REPLACE(
        REPLACE(
          REPLACE(
            REPLACE(
              s1.name,
              ".draw", ""),
            ".onLayout", ""),
          ".onMeasure", ""),
        ".Layout", ""),
      ".Measure", "") AS name,
      ts,
      dur
    FROM
      slice s1
    -- Ensure that toplevel Java slices are not included, as they may be logged
    -- with either category = "toplevel" or category = "toplevel,Java".
    -- Also filter out the zero duration slices as an attempt to reduce noise as
    -- "Java" category contains misc events (as it's hard to add new categories).
    WHERE internal_java_not_top_level_category(category) AND dur > 0
  ),
  -- We filter out generic slices from various UI frameworks which don't tell us much about
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- what exactly this view is doing.
  interesting_java_slices AS (
    SELECT
      id, name, ts, dur
    FROM java_slices_with_trimmed_names
    WHERE NOT name IN (
      -- AndroidX.
      "FitWindowsFrameLayout",
      "FitWindowsLinearLayout",
      "ContentFrameLayout",
      "CoordinatorLayout",
      -- Other non-Chrome UI libraries.
      "ComponentHost",
      -- Generic Chrome frameworks.
      "CompositorView:finalizeLayers",
      "CompositorViewHolder",
      "CompositorViewHolder:layout",
      "CompositorViewHolder:updateContentViewChildrenDimension",
      "CoordinatorLayoutForPointer",
      "OptimizedFrameLayout",
      "ViewResourceAdapter:getBitmap",
      "ViewResourceFrameLayout",
      -- Non-specific Chrome slices.
      "AppCompatImageButton",
      "ScrollingBottomViewResourceFrameLayout",
      -- Screenshots get their custom annotations below.
      "ViewResourceAdapter:captureWithHardwareDraw",
      "ViewResourceAdapter:captureWithSoftwareDraw",
      -- Non-bytecode generated slices.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      "LayoutDriver:onUpdate"
    )
)
SELECT
  s1.*,
  -- While the parent slices are too generic to be used by themselves,
  -- they can provide some useful metadata.
  has_parent_slice_with_name(
    s1.id,
    "ViewResourceAdapter:captureWithSoftwareDraw"
  ) AS is_software_screenshot,
  has_parent_slice_with_name(
    s1.id,
    "ViewResourceAdapter:captureWithHardwareDraw"
  ) AS is_hardware_screenshot
FROM interesting_java_slices s1
-- We select "outermost" interesting slices: interesting slices which
-- do not another interesting slice in their parent chain.
WHERE (SELECT count()
  FROM ancestor_slice(s1.id) s2
  JOIN interesting_java_slices s3 ON s2.id = s3.id) = 0;

-- A list of slices corresponding to operations on interesting (non-generic)
-- Chrome Java views. The view is considered interested if it's not a system
-- (ContentFrameLayout) or generic library (CompositorViewHolder) views.
--
-- @column filtered_name                Name of the view.
-- @column is_software_screenshot BOOL  Whether this slice is a part of non-accelerated
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--                                      capture toolbar screenshot.
-- @column is_hardware_screenshot BOOL  Whether this slice is a part of accelerated
--                                      capture toolbar screenshot.
-- TODO(altimin): Add "columns_from slice" annotation.
-- TODO(altimin): convert this to EXTEND_TABLE when it becomes available.
CREATE VIEW chrome_java_views AS
SELECT
  java_view.name AS filtered_name,
  java_view.is_software_screenshot,
  java_view.is_hardware_screenshot,
  slice.*
FROM internal_chrome_java_views java_view
JOIN slice USING (id);

-- A list of Choreographer tasks (Android frame generation) in Chrome.
CREATE VIEW internal_chrome_choreographer_tasks
AS
SELECT
  id,
  "Choreographer" AS kind,
  ts,
  dur,
  name
FROM slice
WHERE name GLOB "Looper.dispatch: android.view.Choreographer$FrameHandler*";

-- Extract task's posted_from information from task's arguments.
CREATE PERFETTO FUNCTION internal_get_posted_from(arg_set_id INT)
RETURNS STRING AS
WITH posted_from as (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SELECT
    EXTRACT_ARG($arg_set_id, "task.posted_from.file_name") AS file_name,
    EXTRACT_ARG($arg_set_id, "task.posted_from.function_name") AS function_name
)
SELECT file_name || ":" || function_name as posted_from
FROM posted_from;

-- Selects the BeginMainFrame slices (which as posted from ScheduledActionSendBeginMainFrame),
-- used for root-level processing. In top-level/Java based slices, these will correspond to the
-- ancestor of descendant slices; in long-task tracking, these tasks will be
-- on a custom track and will need to be associated with children by timestamp
-- and duration. Corresponds with the Choreographer root slices in
-- chrome_choreographer_tasks below.
--
-- Schema:
-- @column is            The slice id.
-- @column kind          The type of Java slice.
-- @column ts            The timestamp of the slice.
-- @column name          The name of the slice.
SELECT CREATE_VIEW_FUNCTION(
  'INTERNAL_SELECT_BEGIN_MAIN_FRAME_JAVA_SLICES(name STRING)',
  'id INT, kind STRING, ts LONG, dur LONG, name STRING',
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  'SELECT
      id,
      "SingleThreadProxy::BeginMainFrame" AS kind,
      ts,
      dur,
      name
    FROM slice
    WHERE
      (name = $name
        AND internal_get_posted_from(arg_set_id) =
            "cc/trees/single_thread_proxy.cc:ScheduledActionSendBeginMainFrame")
  '
);

-- A list of Chrome tasks which were performing operations with Java views,
-- together with the names of the these views.
-- @column id INT            Slice id.
-- @column kind STRING       Type of the task.
-- @column java_views STRING Concatenated names of Java views used by the task.
CREATE VIEW internal_chrome_slices_with_java_views AS
WITH
  -- Select UI thread BeginMainFrames (which are Chrome scheduler tasks) and
  -- Choreographer frames (which are looper tasks).
  root_slices AS (
    SELECT id, kind
    FROM INTERNAL_SELECT_BEGIN_MAIN_FRAME_JAVA_SLICES('ThreadControllerImpl::RunTask')
    UNION ALL
    SELECT id, kind FROM internal_chrome_choreographer_tasks
  ),
  -- Intermediate step to allow us to sort java view names.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  root_slice_and_java_view_not_grouped AS (
    SELECT
      root.id, root.kind, java_view.name AS java_view_name
    FROM root_slices root
    JOIN descendant_slice(root.id) child
    JOIN internal_chrome_java_views java_view ON java_view.id = child.id
  )
SELECT
  root.id,
  root.kind,
  GROUP_CONCAT(DISTINCT java_view.java_view_name) AS java_views
FROM root_slices root
LEFT JOIN root_slice_and_java_view_not_grouped java_view USING (id)
GROUP BY root.id;

-- A list of tasks executed by Chrome scheduler.
CREATE TABLE internal_chrome_scheduler_tasks AS
SELECT
  id
FROM slice
WHERE
  category GLOB "*toplevel*"
  AND (name = "ThreadControllerImpl::RunTask" OR name = "ThreadPool_RunTask")
ORDER BY id;

-- A list of tasks executed by Chrome scheduler.
--
-- @column id                    Slice id.
-- @column name                  Name of the task.
-- @column ts                    Timestamp.
-- @column dur                   Duration.
-- @column utid                  Utid of the thread this task run on.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column thread_name           Name of the thread this task run on.
-- @column upid                  Upid of the process of this task.
-- @column process_name          Name of the process of this task.
-- @column track_id              Same as slice.track_id.
-- @column depth                 Same as slice.depth.
-- @column parent_id             Same as slice.parent_id.
-- @column arg_set_id            Same as slice.arg_set_id.
-- @column thread_ts             Same as slice.thread_ts.
-- @column thread_dur            Same as slice.thread_dur.
-- @column posted_from           Source location where the PostTask was called.
CREATE VIEW chrome_scheduler_tasks AS
SELECT
  task.id,
  "chrome_scheduler_tasks" as type,
  internal_format_scheduler_task_name(
    internal_get_posted_from(slice.arg_set_id)) as name,
  slice.ts,
  slice.dur,
  thread.utid,
  thread.name as thread_name,
  process.upid,
  process.name as process_name,
  slice.track_id,
  slice.category,
  slice.depth,
  slice.parent_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  slice.arg_set_id,
  slice.thread_ts,
  slice.thread_dur,
  internal_get_posted_from(slice.arg_set_id) as posted_from
FROM internal_chrome_scheduler_tasks task
JOIN slice using (id)
JOIN thread_track ON slice.track_id = thread_track.id
JOIN thread using (utid)
JOIN process using (upid)
ORDER BY task.id;

-- Select the slice that might be the descendant mojo slice for the given task
-- slice if it exists.
CREATE PERFETTO FUNCTION internal_get_descendant_mojo_slice_candidate(
  slice_id INT
)
RETURNS INT AS
SELECT
  id
FROM descendant_slice($slice_id)
WHERE
  -- The tricky case here is dealing with sync mojo IPCs: we do not want to
  -- pick up sync IPCs when we are in a non-IPC task.
  -- So we look at all toplevel events and pick up the first one:
  -- for sync mojo messages, it will be "Send mojo message", which then
  -- will fail.
  -- Some events are excluded as they can legimately appear under "RunTask"
  -- before "Receive mojo message".
  category GLOB "*toplevel*" AND
  name NOT IN (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    "SimpleWatcher::OnHandleReady",
    "MessagePipe peer closed")
ORDER by depth, ts
LIMIT 1;

SELECT CREATE_VIEW_FUNCTION('INTERNAL_DESCENDANT_MOJO_SLICE(slice_id INT)',
  'task_name STRING',
  '
  SELECT
    printf("%s %s (hash=%d)",
      mojo.interface_name, mojo.message_type, mojo.ipc_hash) AS task_name
  FROM slice task
  JOIN internal_chrome_mojo_slices mojo
    ON mojo.id = internal_get_descendant_mojo_slice_candidate($slice_id)
  WHERE task.id = $slice_id
  ');

-- A list of "Chrome tasks": top-level execution units (e.g. scheduler tasks /
-- IPCs / system callbacks) run by Chrome. For a given thread, the tasks
-- will not intersect.
--
-- @column task_name STRING  Name for the given task.
-- @column task_type STRING  Type of the task (e.g. "scheduler").
-- @column scheduling_delay INT
CREATE TABLE internal_chrome_tasks AS
WITH
-- Select slices from "toplevel" category which do not have another
-- "toplevel" slice as ancestor. The possible cases include sync mojo messages
-- and tasks in nested runloops. Toplevel events may also be logged as with
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- the Java category.
non_embedded_toplevel_slices AS (
  SELECT * FROM slice
  WHERE
    internal_any_top_level_category(category)
    AND (SELECT count() FROM ancestor_slice(slice.id) anc
      WHERE anc.category GLOB "*toplevel*" or anc.category GLOB "*toplevel.viz*") = 0
),
-- Select slices from "Java" category which do not have another "Java" or
-- "toplevel" slice as parent. In the longer term they should probably belong
-- to "toplevel" category as well, but for now this will have to do. Ensure
-- that "Java" slices do not include "toplevel" slices as those would be
-- handled elsewhere.
non_embedded_java_slices AS (
  SELECT
    id,
    name AS task_name,
    "java" as task_type
  FROM slice s
  WHERE
    internal_java_not_top_level_category(category)
    AND (SELECT count()
      FROM ancestor_slice(s.id) s2
      WHERE s2.category GLOB "*toplevel*" OR s2.category GLOB "*Java*") = 0
),
-- Generate full names for tasks with java views.
java_views_tasks AS (
  SELECT
    id,
    printf('%s(java_views=%s)', kind, java_views) AS task_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    internal_get_java_views_task_type(kind) AS task_type
  FROM internal_chrome_slices_with_java_views
),
scheduler_tasks AS (
  SELECT
    id,
    name as task_name,
    "scheduler" as task_type
  FROM chrome_scheduler_tasks
),
-- Select scheduler tasks which are used to run mojo messages and use the mojo names
-- as full names for these slices.
-- We restrict this to specific scheduler tasks which are expected to run mojo
-- tasks due to sync mojo events, which also emit similar events.
scheduler_tasks_with_mojo AS (
  SELECT
    -- We use the "RunTask" as the task, and pick up the name from its child
    -- "Receive mojo message" event.
    task.id,
    receive_message.task_name,
    "mojo" AS task_type
  FROM
    chrome_scheduler_tasks task
  JOIN INTERNAL_DESCENDANT_MOJO_SLICE(task.id) receive_message
  WHERE
    task.posted_from IN (
      "mojo/public/cpp/system/simple_watcher.cc:Notify",
      "mojo/public/cpp/system/simple_watcher.cc:ArmOrNotify",
      "mojo/public/cpp/bindings/lib/connector.cc:PostDispatchNextMessageFromPipe",
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      "ipc/ipc_mojo_bootstrap.cc:Accept")
),
navigation_tasks AS (
  WITH tasks_with_readable_names AS (
    SELECT
      id,
      internal_human_readable_navigation_task_name(task_name) as readable_name,
      IFNULL(internal_extract_frame_type(id), 'unknown frame type') as frame_type
    FROM
      scheduler_tasks_with_mojo
  )
  SELECT
    id,
    printf("%s (%s)", readable_name, frame_type) as task_name,
    'navigation_task' AS task_type
  FROM tasks_with_readable_names
  WHERE readable_name IS NOT NULL
),
-- Add scheduler and mojo full names to non-embedded slices from
-- the "toplevel" category, with mojo ones taking precedence.
non_embedded_toplevel_slices_with_task_name AS (
  SELECT
    task.id AS id,
    COALESCE(
        navigation.task_name,
        java_views.task_name,
        mojo.task_name,
        scheduler.task_name,
        task.name
    ) AS name,
    COALESCE(
        navigation.task_type,
        java_views.task_type,
        mojo.task_type,
        scheduler.task_type,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        "other"
    ) AS task_type
  FROM non_embedded_toplevel_slices task
  LEFT JOIN scheduler_tasks_with_mojo mojo ON mojo.id = task.id
  LEFT JOIN scheduler_tasks scheduler ON scheduler.id = task.id
  LEFT JOIN java_views_tasks java_views ON java_views.id = task.id
  LEFT JOIN navigation_tasks navigation ON navigation.id = task.id
)
-- Merge slices from toplevel and Java categories.
SELECT * FROM non_embedded_toplevel_slices_with_task_name
UNION ALL
SELECT * FROM non_embedded_java_slices
ORDER BY id;

-- A list of "Chrome tasks": top-level execution units (e.g. scheduler tasks /
-- IPCs / system callbacks) run by Chrome. For a given thread, the slices
-- corresponding to these tasks will not intersect.
--
-- @column id INT              Id for the given task, also the id of the slice this task corresponds to.
-- @column name STRING         Name for the given task.
-- @column task_type STRING    Type of the task (e.g. "scheduler").
-- @column thread_name STRING  Thread name.
-- @column utid INT            Utid.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column process_name STRING Process name.
-- @column upid INT            Upid.
-- @column full_name STRING    Legacy alias for |task_name|.
-- @column ts INT              Alias of |slice.ts|.
-- @column dur INT             Alias of |slice.dur|.
-- @column track_id INT        Alias of |slice.track_id|.
-- @column category STRING     Alias of |slice.category|.
-- @column arg_set_id INT      Alias of |slice.arg_set_id|.
-- @column thread_ts INT       Alias of |slice.thread_ts|.
-- @column thread_dur INT      Alias of |slice.thread_dur|.
-- @column full_name STRING    Legacy alias for |name|.
CREATE VIEW chrome_tasks AS
SELECT
  cti.id,
  cti.name,
  task_type,
  thread.name AS thread_name,
  thread.utid,
  process.name AS process_name,
  thread.upid,
  s.ts,
  s.dur,
  s.track_id,
  s.category,
  s.arg_set_id,
  s.thread_ts,
  s.thread_dur,
  cti.name as full_name
FROM internal_chrome_tasks cti
JOIN slice s ON cti.id = s.id
JOIN thread_track tt ON s.track_id = tt.id
JOIN thread USING (utid)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(JOIN process USING (upid);

)_d3l1m1t3r_"
;

const char kCommonArgs[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Returns the formatted value of a given argument.
-- Similar to EXTRACT_ARG, but instead of returning the raw value, it returns
-- the value formatted according to the 'value_type' column (e.g. for booleans,
-- EXTRACT_ARG will return 0 or 1, while FORMATTED_ARG will return 'true' or
-- 'false').
-- @arg arg_set_id INT  Id of the arg set.
-- @arg key STRING      Key of the argument.
-- @ret STRING          Formatted value of the argument.
CREATE PERFETTO FUNCTION formatted_arg(arg_set_id INT, key STRING)
RETURNS STRING AS
SELECT display_value
FROM args
WHERE arg_set_id = $arg_set_id AND key = $key;
)_d3l1m1t3r_"
;

const char kCommonCounters[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

SELECT IMPORT('common.timestamps');

-- Timestamp of first counter value in a counter.
--
-- @arg counter_track_id  INT Id of a counter track with a counter.
-- @ret LONG                  Timestamp of first counter value. Null if doesn't exist.
CREATE PERFETTO FUNCTION earliest_timestamp_for_counter_track(counter_track_id INT)
RETURNS LONG AS
SELECT MIN(ts) FROM counter WHERE counter.track_id = $counter_track_id;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Counter values with details of counter track with calculated duration of each counter value.
-- Duration is calculated as time from counter to the next counter.
--
-- @arg counter_track_id INT   Id of track counter track.
-- @column ts                  Timestamp of the counter value.
-- @column dur                 Duration of the counter value.
-- @column value               Counter value.
-- @column track_id            If of the counter track.
-- @column track_name          Name of the counter track.
-- @column track_arg_set_id    Counter track set id.
-- @column arg_set_id          Counter arg set id.
SELECT CREATE_VIEW_FUNCTION(
  'COUNTER_WITH_DUR_FOR_TRACK(counter_track_id INT)',
  '
    ts LONG,
    dur LONG,
    value DOUBLE,
    track_id INT,
    track_name STRING,
    track_arg_set_id INT,
    arg_set_id INT
  ',
  '
    SELECT
        ts,
        LEAD(ts, 1, trace_end()) OVER(ORDER BY ts) - ts AS dur,
        value,
        track.id AS track_id,
        track.name AS track_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        track.source_arg_set_id AS track_arg_set_id,
        counter.arg_set_id AS arg_set_id
    FROM counter
    JOIN counter_track track ON track.id = counter.track_id
    WHERE track.id = $counter_track_id
  '
);

-- COUNTER_WITH_DUR_FOR_TRACK but in a specified time.
-- Does calculation over the table ends - creates an artificial counter value at
-- the start if needed and chops the duration of the last timestamps in range.
--
-- @arg counter_track_id INT   Id of track counter track.
-- @arg start_ts LONG          Timestamp of the timerange start.
-- Can be earlier than the first counter value.
-- @arg end_ts LONG            Timestamp of the timerange end.
-- @column ts                  Timestamp of the counter value.
-- @column dur                 Duration of the counter value.
-- @column value               Counter value.
-- @column track_id            If of the counter track.
-- @column track_name          Name of the counter track.
-- @column track_arg_set_id    Counter track set id.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column arg_set_id          Counter arg set id.
SELECT CREATE_VIEW_FUNCTION(
  'COUNTER_FOR_TIME_RANGE(counter_track_id INT, start_ts LONG, end_ts LONG)',
  '
    ts LONG,
    dur LONG,
    value DOUBLE,
    track_id INT,
    track_name STRING,
    track_arg_set_id INT,
    arg_set_id INT
  ',
  '
  SELECT
    IIF(ts < $start_ts, $start_ts, ts) AS ts,
    IIF(
      ts < $start_ts,
      dur - ($start_ts - ts),
      IIF(ts + dur > $end_ts, $end_ts - ts, dur)) AS dur,
    value,
    track_id,
    track_name,
    track_arg_set_id,
    arg_set_id
  FROM COUNTER_WITH_DUR_FOR_TRACK($counter_track_id)
  WHERE TRUE
    AND ts + dur >= $start_ts
    AND ts < $end_ts
  ORDER BY ts ASC;
'
);
)_d3l1m1t3r_"
;

const char kCommonCpus[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.


CREATE PERFETTO TABLE internal_cpu_sizes AS
SELECT 0 AS n, 'little' AS size
UNION
SELECT 1 AS n, 'mid' AS size
UNION
SELECT 2 AS n, 'big' AS size;

CREATE PERFETTO TABLE internal_ranked_cpus AS
SELECT
 (DENSE_RANK() OVER win) - 1 AS n,
 cpu
FROM (
  SELECT
    track.cpu AS cpu,
    MAX(counter.value) AS maxfreq
  FROM counter
  JOIN cpu_counter_track AS track
  ON (counter.track_id = track.id)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  WHERE track.name = "cpufreq"
  GROUP BY track.cpu
)
WINDOW win AS (ORDER BY maxfreq);

-- Guess size of CPU.
-- On some multicore devices the cores are heterogeneous and divided
-- into two or more 'sizes'. In a typical case a device might have 8
-- cores of which 4 are 'little' (low power & low performance) and 4
-- are 'big' (high power & high performance). This functions attempts
-- to map a given CPU index onto the relevant descriptor. For
-- homogeneous systems this returns NULL.
--
-- @arg cpu_index INT   Index of the CPU whose size we will guess.
-- @ret STRING          A descriptive size ('little', 'mid', 'big', etc) or NULL if we have insufficient information.
CREATE PERFETTO FUNCTION guess_cpu_size(cpu_index INT)
RETURNS STRING AS
SELECT
  IIF((SELECT COUNT(DISTINCT n) FROM internal_ranked_cpus) >= 2, size, null) as size
FROM internal_ranked_cpus
LEFT JOIN internal_cpu_sizes USING(n)
WHERE cpu = $cpu_index;

)_d3l1m1t3r_"
;

const char kCommonMetadata[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Extracts an int value with the given name from the metadata table.
--
-- @arg name STRING The name of the metadata entry.
-- @ret LONG int_value for the given name. NULL if there's no such entry.
CREATE PERFETTO FUNCTION extract_int_metadata(name STRING)
RETURNS LONG AS
SELECT int_value FROM metadata WHERE name = ($name);
)_d3l1m1t3r_"
;

const char kCommonPercentiles[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

SELECT IMPORT('common.counters');
SELECT IMPORT('common.timestamps');

SELECT CREATE_VIEW_FUNCTION(
    'INTERNAL_NUMBER_GENERATOR(to INT)',
    'num INT',
    'WITH NUMS AS
        (SELECT 1 num UNION SELECT num + 1
        from NUMS
        WHERE num < $to)
    SELECT num FROM NUMS;'
);

--
-- Get durations for percentile
--

-- All percentiles (range 1-100) for counter track ID in a given time range.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--
-- Percentiles are calculated by:
-- 1. Dividing the sum of duration in time range for each value in the counter
-- by duration of the counter in range. This gives us `percentile_for)value` (DOUBLE).
-- 2. Fetching each percentile by taking floor of each `percentile_for_value`, grouping by
-- resulting `percentile` and MIN from value for each grouping. As we are rounding down,
-- taking MIN assures most reliable data.
-- 3. Filling the possible gaps in percentiles by getting the minimal value from higher
-- percentiles for each gap.
--
-- @arg counter_track_id INT Id of the counter track.
-- @arg start_ts LONG        Timestamp of start of time range.
-- @arg end_ts LONG          Timestamp of end of time range.
-- @column percentile        All of the numbers from 1 to 100.
-- @column value             Value for the percentile.
SELECT CREATE_VIEW_FUNCTION(
    'COUNTER_PERCENTILES_FOR_TIME_RANGE(counter_track_id INT, start_ts LONG, end_ts LONG)',
    'percentile INT, value DOUBLE',
    'WITH percentiles_for_value AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        SELECT
            value,
            (CAST(SUM(dur) OVER(ORDER BY value ASC) AS DOUBLE) /
                ($end_ts - MAX($start_ts, earliest_timestamp_for_counter_track($counter_track_id)))) * 100
            AS percentile_for_value
        FROM COUNTER_FOR_TIME_RANGE($counter_track_id, $start_ts, $end_ts)
        ORDER BY value ASC
    ),
    with_gaps AS (
        SELECT
            CAST(percentile_for_value AS INT) AS percentile,
            MIN(value) AS value
        FROM percentiles_for_value
        GROUP BY percentile
        ORDER BY percentile ASC)
    SELECT
        num AS percentile,
        IFNULL(value, MIN(value) OVER (ORDER BY percentile DESC)) AS value
    FROM INTERNAL_NUMBER_GENERATOR(100) AS nums
    LEFT JOIN with_gaps ON with_gaps.percentile = nums.num
    ORDER BY percentile DESC
    '
);

-- All percentiles (range 1-100) for counter track ID.
--
-- @arg counter_track_id INT Id of the counter track.
-- @column percentile        All of the numbers from 1 to 100.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column value             Value for the percentile.
SELECT CREATE_VIEW_FUNCTION(
    'COUNTER_PERCENTILES_FOR_TRACK(counter_track_id INT)',
    'percentile INT, value DOUBLE',
    'SELECT * FROM COUNTER_PERCENTILES_FOR_TIME_RANGE($counter_track_id, trace_start(), trace_end());'
);

-- Value for specific percentile (range 1-100) for counter track ID in time range.
--
-- @arg counter_track_id INT Id of the counter track.
-- @arg percentile INT       Any of the numbers from 1 to 100.
-- @arg start_ts LONG        Timestamp of start of time range.
-- @arg end_ts LONG          Timestamp of end of time range.
-- @ret DOUBLE               Value for the percentile.
CREATE PERFETTO FUNCTION counter_track_percentile_for_time(counter_track_id INT,
                                                          percentile INT,
                                                          start_ts LONG,
                                                          end_ts LONG)
RETURNS DOUBLE AS
SELECT value
FROM COUNTER_PERCENTILES_FOR_TIME_RANGE($counter_track_id, $start_ts, $end_ts)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE percentile = $percentile;

-- Value for specific percentile (range 1-100) for counter track ID.
--
-- @arg counter_track_id INT Id of the counter track.
-- @arg percentile INT       Any of the numbers from 1 to 100.
-- @ret DOUBLE               Value for the percentile.
CREATE PERFETTO FUNCTION counter_track_percentile(counter_track_id INT,
                                                  percentile INT)
RETURNS DOUBLE AS
SELECT counter_track_percentile_for_time($counter_track_id,
                                         $percentile,
                                         trace_start(),
                                         trace_end());

)_d3l1m1t3r_"
;

const char kCommonSlices[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- All thread slices with data about thread, thread track and process.
-- Where possible, use available view functions which filter this view.
--
-- @column id                 Alias for `slice.id`.
-- @column type               Alias for `slice.type`.
-- @column ts                 Alias for `slice.ts`.
-- @column dur                Alias for `slice.dur`.
-- @column category           Alias for `slice.category`.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column name               Alias for `slice.name`.
-- @column track_id           Alias for `slice.track_id`.
-- @column track_name         Alias for `thread_track.name`.
-- @column thread_name        Alias for `thread.name`.
-- @column utid               Alias for `thread.utid`.
-- @column tid                Alias for `thread.tid`
-- @column process_name       Alias for `process.name`.
-- @column upid               Alias for `process.upid`.
-- @column pid                Alias for `process.pid`.
-- @column depth              Alias for `slice.depth`.
-- @column parent_id          Alias for `slice.parent_id`.
-- @column arg_set_id         Alias for `slice.arg_set_id`.
-- @column thread_ts          Alias for `slice.thread_ts`.
-- @column thread_dur         Alias for `slice.thread_dur`.
CREATE VIEW thread_slice AS
SELECT
  slice.id,
  slice.ts,
  slice.dur,
  slice.category,
  slice.name,
  slice.track_id,
  thread_track.name AS track_name,
  thread.name AS thread_name,
  thread.utid,
  thread.tid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  process.name AS process_name,
  process.upid,
  process.pid,
  slice.depth,
  slice.parent_id,
  slice.arg_set_id,
  slice.thread_ts,
  slice.thread_dur
FROM slice
JOIN thread_track ON slice.track_id = thread_track.id
JOIN thread USING (utid)
LEFT JOIN process USING (upid);

-- All process slices with data about process track and process.
-- Where possible, use available view functions which filter this view.
--
-- @column id                 Alias for `slice.id`.
-- @column type               Alias for `slice.type`.
-- @column ts                 Alias for `slice.ts`.
-- @column dur                Alias for `slice.dur`.
-- @column category           Alias for `slice.category`.
-- @column name               Alias for `slice.name`.
-- @column track_id           Alias for `slice.track_id`.
-- @column track_name         Alias for `process_track.name`.
-- @column process_name       Alias for `process.name`.
-- @column upid               Alias for `process.upid`.
-- @column pid                Alias for `process.pid`.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column depth              Alias for `slice.depth`.
-- @column parent_id          Alias for `slice.parent_id`.
-- @column arg_set_id         Alias for `slice.arg_set_id`.
-- @column thread_ts          Alias for `slice.thread_ts`.
-- @column thread_dur         Alias for `slice.thread_dur`.
CREATE VIEW process_slice AS
SELECT
  slice.id,
  slice.type,
  slice.ts,
  slice.dur,
  slice.category,
  slice.name,
  slice.track_id,
  process_track.name AS track_name,
  process.name AS process_name,
  process.upid,
  process.pid,
  slice.depth,
  slice.parent_id,
  slice.arg_set_id,
  slice.thread_ts,
  slice.thread_dur
FROM slice
JOIN process_track ON slice.track_id = process_track.id
JOIN process USING (upid);

-- Checks if slice has an ancestor with provided name.
--
-- @arg id INT              Id of the slice to check parents of.
-- @arg parent_name STRING  Name of potential ancestor slice.
-- @ret BOOL                Whether `parent_name` is a name of an ancestor slice.
CREATE PERFETTO FUNCTION has_parent_slice_with_name(id INT, parent_name STRING)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(RETURNS BOOL AS
SELECT EXISTS(
  SELECT 1
  FROM ancestor_slice($id)
  WHERE name = $parent_name
  LIMIT 1
);

-- Checks if slice has a descendant with provided name.
--
-- @arg id INT                  Id of the slice to check descendants of.
-- @arg descendant_name STRING  Name of potential descendant slice.
-- @ret BOOL                    Whether `descendant_name` is a name of an
--                              descendant slice.
CREATE PERFETTO FUNCTION has_descendant_slice_with_name(
  id INT,
  descendant_name STRING
)
RETURNS BOOL AS
SELECT EXISTS(
  SELECT 1
  FROM descendant_slice($id)
  WHERE name = $descendant_name
  LIMIT 1
);

-- Count slices with specified name.
--
-- @arg slice_glob STRING Name of the slices to counted.
-- @ret INT               Number of slices with the name.
CREATE PERFETTO FUNCTION slice_count(slice_glob STRING)
RETURNS INT AS
SELECT COUNT(1) FROM slice WHERE name GLOB $slice_glob;;

-- Finds the end timestamp for a given slice's descendant with a given name.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- If there are multiple descendants with a given name, the function will return the
-- first one, so it's most useful when working with a timeline broken down into phases,
-- where each subphase can happen only once.
-- @arg parent_id INT Id of the parent slice.
-- @arg child_name STRING name of the child with the desired end TS.
-- @ret INT end timestamp of the child or NULL if it doesn't exist.
CREATE PERFETTO FUNCTION descendant_slice_end(
  parent_id INT,
  child_name STRING
)
RETURNS INT AS
SELECT
  CASE WHEN s.dur
    IS NOT -1 THEN s.ts + s.dur
    ELSE NULL
  END
FROM descendant_slice($parent_id) s
WHERE s.name = $child_name
LIMIT 1;

)_d3l1m1t3r_"
;

const char kCommonTimestamps[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

--
-- Trace bounds
--

-- Fetch start of the trace.
-- @ret LONG  Start of the trace in nanoseconds.
CREATE PERFETTO FUNCTION trace_start()
RETURNS LONG AS
SELECT start_ts FROM trace_bounds;

-- Fetch end of the trace.
-- @ret LONG  End of the trace in nanoseconds.
CREATE PERFETTO FUNCTION trace_end()
RETURNS LONG AS
SELECT end_ts FROM trace_bounds;

-- Fetch duration of the trace.
-- @ret LONG  Duration of the trace in nanoseconds.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO FUNCTION trace_dur()
RETURNS LONG AS
SELECT trace_end() - trace_start();

-- Checks whether two spans are overlapping.
--
-- @arg ts1 LONG      Start of first span.
-- @arg ts_end1 LONG  End of first span.
-- @arg ts2 LONG      Start of second span.
-- @arg ts_end2 LONG  End of second span.
-- @ret BOOL          Whether two spans are overlapping.
CREATE PERFETTO FUNCTION is_spans_overlapping(ts1 LONG, ts_end1 LONG, ts2 LONG, ts_end2 LONG)
RETURNS BOOL AS
SELECT (IIF($ts1 < $ts2, $ts2, $ts1)
      < IIF($ts_end1 < $ts_end2, $ts_end1, $ts_end2));

--Return the overlapping duration between two spans.
--If either duration is less than 0 or there's no intersection, 0 is returned
--
-- @arg ts1 LONG Timestamp of first slice start.
-- @arg dur1 LONG Duration of first slice.
-- @arg ts2 LONG Timestamp of second slice start.
-- @arg dur2 LONG Duration of second slice.
-- @ret INT               Overlapping duration
CREATE PERFETTO FUNCTION spans_overlapping_dur(ts1 LONG, dur1 LONG, ts2 LONG, dur2 LONG)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(RETURNS INT AS
SELECT
  CASE
    WHEN $dur1 = -1 OR $dur2 = -1 THEN 0
    WHEN $ts1 + $dur1 < $ts2 OR $ts2 + $dur2 < $ts1 THEN 0
    WHEN ($ts1 >= $ts2) AND ($ts1 + $dur1 <= $ts2 + $dur2) THEN $dur1
    WHEN ($ts1 < $ts2) AND ($ts1 + $dur1 < $ts2 + $dur2) THEN $ts1 + $dur1 - $ts2
    WHEN ($ts1 > $ts2) AND ($ts1 + $dur1 > $ts2 + $dur2) THEN $ts2 + $dur2 - $ts1
    ELSE $dur2
  END;

)_d3l1m1t3r_"
;

const char kExperimentalAndroidBroadcast[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Provides a list of broadcast names and processes they were sent to by the
-- system_server process on U+ devices.
--
-- @column type          The name of the broadcast type which was sent.
-- @column process_name  The process name the broadcast was sent to.
-- @column queue_name    The name of the broacast queue the broadcast was
--                       dispatched from.
CREATE VIEW experimental_android_broadcasts_minsdk_u AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WITH
broadcast_queues AS (
  SELECT process_track.id, process_track.name AS queue_name
  FROM process_track
  JOIN process USING (upid)
  WHERE
    process_track.name GLOB 'BroadcastQueue.mRunning*'
    AND process.name = 'system_server'
),
broadcast_process_running AS (
  SELECT ts, dur, str_split(slice.name, '/', 0) AS process_name, queue_name
  FROM slice
  JOIN broadcast_queues ON broadcast_queues.id = slice.track_id
  WHERE slice.name GLOB '* running'
)
SELECT str_split(slice.name, '/', 0) AS type, process_name, queue_name
FROM broadcast_process_running
JOIN broadcast_queues USING (queue_name)
JOIN slice ON (
  broadcast_process_running.ts < slice.ts
  AND slice.ts < broadcast_process_running.ts + broadcast_process_running.dur
  AND slice.track_id = broadcast_queues.id
  )
WHERE slice.name GLOB '* scheduled';

)_d3l1m1t3r_"
;

const char kExperimentalFlatSlices[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- The concept of a "flat slice" is to take the data in the slice table and
-- remove all notion of nesting; we do this by projecting every slice in a stack to
-- their ancestor slice, i.e at any point in time, taking the  most specific active
-- slice (i.e. the slice at the bottom of the stack) and representing that as the
-- *only* slice that was running during that period.
--
-- This concept becomes very useful when you try and linearise a trace and
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- compare it with other traces spanning the same user action; "self time" (i.e.
-- time spent in a slice but *not* any children) is easily computed and span
-- joins with thread state become possible without limiting to only depth zero
--- slices.
--
-- Note that, no slices will be generated for intervals without without any slices.
--
-- As an example, consider the following slice stack:
-- A-------------B.
-- ----C----D----.
-- The flattened slice will be: A----C----D----B.
--
-- @column slice_id           Id of most active slice.
-- @column ts                 Timestamp when `slice.id` became the most active slice.
-- @column dur                Duration of `slice.id` as the most active slice until the next active slice.
-- @column depth              Depth of `slice.id` in the original stack.
-- @column name               Name of `slice.id`.
-- @column root_name          Name of the top most slice of the stack.
-- @column root_id            Id of of the top most slice of the stack.
-- @column track_id           Alias for `slice.track_id`.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column utid               Alias for `thread.utid`.
-- @column tid                Alias for `thread.tid`
-- @column thread_name        Alias for `thread.name`.
-- @column upid               Alias for `process.upid`.
-- @column pid                Alias for `process.pid`.
-- @column process_name       Alias for `process.name`.
CREATE TABLE experimental_slice_flattened AS
-- The algorithm proceeds as follows:
-- 1. Find the start and end timestamps of all slices.
-- 2. Iterate the generated timestamps within a stack in chronoligical order.
-- 3. Generate a slice for each timestamp pair (regardless of if it was a start or end)  .
-- 4. If the first timestamp in the pair was originally a start, the slice is the 'current' slice,
-- otherwise, the slice is the parent slice.
WITH
  begins AS (
    SELECT id AS slice_id, ts, name, track_id, depth
    FROM slice
    WHERE dur > 0
  ),
  ends AS (
    SELECT
      parent.id AS slice_id,
      current.ts + current.dur AS ts,
      parent.name as name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      current.track_id,
      current.depth - 1 AS depth
    FROM slice current
    LEFT JOIN slice parent
      ON current.parent_id = parent.id
    WHERE current.dur > 0
  ),
  events AS (
    SELECT * FROM begins
    UNION ALL
    SELECT * FROM ends
  ),
  data AS (
    SELECT
      events.slice_id,
      events.ts,
      LEAD(events.ts) OVER (
         PARTITION BY events.track_id
         ORDER BY events.ts) - events.ts AS dur,
      events.depth,
      events.name,
      events.track_id
    FROM events
  )
SELECT * FROM data WHERE depth != -1;

CREATE
  INDEX experimental_slice_flattened_id_idx
ON experimental_slice_flattened(slice_id);

CREATE
  INDEX experimental_slice_flattened_ts_idx
ON experimental_slice_flattened(ts);

)_d3l1m1t3r_"
;

const char kExperimentalProtoPath[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Creates a Stack consisting of one frame for a path in the
-- EXPERIMENTAL_PROTO_PATH table.
--
-- @arg path_id  INT LONG of the path in EXPERIMENTAL_PROTO_PATH
-- @ret BYTES    Stack with one frame
CREATE PERFETTO FUNCTON EXPERIMENTAL_PROTO_PATH_TO_FRAME(path_id LONG)
RETURNS BYTES AS
SELECT
  CAT_STACKS(
    'event.name:' || EXTRACT_ARG(arg_set_id, 'event.name'),
    'event.category:' || EXTRACT_ARG(arg_set_id, 'event.category'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    field_name,
    field_type)
FROM EXPERIMENTAL_PROTO_PATH
WHERE id = $path_id;

-- Creates a Stack following the parent relations in EXPERIMENTAL_PROTO_PATH
-- table starting at the given path_id.
--
-- @arg path_id  LONG Id of the path in EXPERIMENTAL_PROTO_PATH that will be
-- the leaf in the returned stack
-- @ret BYTES    Stack
CREATE PERFETTO FUNCTION experimental_proto_path_to_stack(path_id LONG)
RETURNS BYTES AS
WITH
  R AS (
    -- Starting at the given path_id generate a stack
    SELECT
      EXPERIMENTAL_PROTO_PATH_TO_FRAME($path_id) AS stack,
      parent_id AS parent_id
    FROM EXPERIMENTAL_PROTO_PATH AS p
    WHERE id = $path_id
    UNION ALL
    -- And recursively add parent paths to the stack
    SELECT
      CAT_STACKS(
        EXPERIMENTAL_PROTO_PATH_TO_FRAME(p.id),
        c.stack)
        AS stack,
      p.parent_id AS parent_id
    FROM EXPERIMENTAL_PROTO_PATH AS p, R AS c
    WHERE p.id = c.parent_id
  )
-- Select only the last row in the recursion (the one that stopped it because
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- it had no parent, i.e. the root) as this will be the row that has the full
-- stack. All the others will only have partial stacks.
SELECT stack
FROM R
WHERE
  parent_id IS NULL;
)_d3l1m1t3r_"
;

const char kExperimentalSlices[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

SELECT IMPORT('common.slices');

-- All slices with related process and thread info if available. Unlike
-- `thread_slice` and `process_slice`, this view contains all slices,
-- with thread- and process-related columns set to NULL if the slice
-- is not associated with a thread or a process.
--
-- @column id                 Alias for `slice.id`.
-- @column type               Alias for `slice.type`.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column ts                 Alias for `slice.ts`.
-- @column dur                Alias for `slice.dur`.
-- @column category           Alias for `slice.category`.
-- @column name               Alias for `slice.name`.
-- @column track_id           Alias for `slice.track_id`.
-- @column track_name         Alias for `track.name`.
-- @column thread_name        Alias for `thread.name`.
-- @column utid               Alias for `thread.utid`.
-- @column tid                Alias for `thread.tid`
-- @column process_name       Alias for `process.name`.
-- @column upid               Alias for `process.upid`.
-- @column pid                Alias for `process.pid`.
-- @column depth              Alias for `slice.depth`.
-- @column parent_id          Alias for `slice.parent_id`.
-- @column arg_set_id         Alias for `slice.arg_set_id`.
-- @column thread_ts          Alias for `slice.thread_ts`.
-- @column thread_dur         Alias for `slice.thread_dur`.
CREATE VIEW experimental_slice_with_thread_and_process_info AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  slice.id,
  slice.type,
  slice.ts,
  slice.dur,
  slice.category,
  slice.name,
  slice.track_id,
  track.name AS track_name,
  thread.name AS thread_name,
  thread.utid,
  thread.tid,
  COALESCE(process1.name, process2.name) AS process_name,
  COALESCE(process1.upid, process2.upid) AS upid,
  COALESCE(process1.pid, process2.pid) AS pid,
  slice.depth,
  slice.parent_id,
  slice.arg_set_id,
  slice.thread_ts,
  slice.thread_dur
FROM slice
JOIN track ON slice.track_id = track.id
LEFT JOIN thread_track ON slice.track_id = thread_track.id
LEFT JOIN thread USING (utid)
LEFT JOIN process process1 ON thread.upid = process1.upid
LEFT JOIN process_track ON slice.track_id = process_track.id
LEFT JOIN process process2 ON process_track.upid = process2.upid;

)_d3l1m1t3r_"
;

const char kExperimentalThreadExecutingSpan[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- A 'thread_executing_span' is thread_state span starting with a runnable slice
-- until the next runnable slice that's woken up by a process (as opposed
-- to an interrupt). Note that within a 'thread_executing_span' we can have sleep
-- spans blocked on an interrupt.
-- We consider the id of this span to be the id of the first thread_state in the span.

--
-- Finds all runnable states that are woken up by a process.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--
-- We achieve this by checking that the |thread_state.irq_context|
-- value is NOT 1. In otherwords, it is either 0 or NULL. The NULL check
-- is important to support older Android versions.
--
-- On older versions of Android (<U). We don't have IRQ context information,
-- so this table might contain wakeups from interrupt context, consequently, the
-- wakeup graph generated might not be accurate.
--
CREATE VIEW internal_runnable_state
AS
SELECT
  thread_state.id,
  thread_state.ts,
  thread_state.dur,
  thread_state.state,
  thread_state.utid,
  thread_state.waker_utid
FROM thread_state
WHERE thread_state.dur != -1 AND thread_state.waker_utid IS NOT NULL
   AND (thread_state.irq_context = 0 OR thread_state.irq_context IS NULL);

-- Similar to |internal_runnable_state| but finds the first runnable state at thread.
CREATE VIEW internal_first_runnable_state
AS
WITH
  first_state AS (
    SELECT
      MIN(thread_state.id) AS id
    FROM thread_state
    GROUP BY utid
  )
SELECT
  thread_state.id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  thread_state.ts,
  thread_state.dur,
  thread_state.state,
  thread_state.utid,
  thread_state.waker_utid
FROM thread_state
JOIN first_state USING (id)
WHERE thread_state.dur != -1 AND thread_state.state = 'R';

--
-- Finds all sleep states including interruptible (S) and uninterruptible (D).
CREATE VIEW internal_sleep_state
AS
SELECT
  thread_state.id,
  thread_state.ts,
  thread_state.dur,
  thread_state.state,
  thread_state.blocked_function,
  thread_state.utid
FROM thread_state
WHERE dur != -1 AND (state = 'S' OR state = 'D' OR state = 'I');

--
-- Finds the last execution for every thread to end executing_spans without a Sleep.
--
CREATE VIEW internal_thread_end_ts
AS
SELECT
  MAX(ts) + dur AS end_ts,
  utid
FROM thread_state
WHERE dur != -1
GROUP BY utid;

-- Similar to |internal_sleep_state| but finds the first sleep state in a thread.
CREATE VIEW internal_first_sleep_state
AS
SELECT
  MIN(s.id) AS id,
  s.ts,
  s.dur,
  s.state,
  s.blocked_function,
  s.utid
FROM internal_sleep_state s
)_d3l1m1t3r_"
R"_d3l1m1t3r_(JOIN internal_runnable_state r
  ON s.utid = r.utid AND (s.ts + s.dur = r.ts)
GROUP BY s.utid;

--
-- Finds all neighbouring ('Sleeping', 'Runnable') thread_states pairs from the same thread.
-- More succintly, pairs of S[n-1]-R[n] where R is woken by a process context and S is an
-- interruptible or uninterruptible sleep state.
--
-- This is achieved by joining the |internal_runnable_state|.ts with the
-- |internal_sleep_state|.|ts + dur|.
--
-- With the S-R pairs of a thread, we can re-align to [R-S) intervals with LEADS and LAGS.
--
-- Given the following thread_states on a thread:
-- S0__|R0__Running0___|S1__|R1__Running1___|S2__|R2__Running2__S2|.
--
-- We have 3 thread_executing_spans: [R0, S0), [R1, S1), [R2, S2).
--
-- We define the following markers in this table:
--
-- prev_start_id    = R0_id.
-- prev_start_ts    = R0_ts.
-- prev_start_dur   = R0_dur.
-- prev_start_state = 'R'.
--
-- prev_end_id      = S0_id.
-- prev_end_ts      = S0_ts.
-- prev_end_dur     = S0_dur.
-- prev_end_state   = 'S' or 'D'.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--
-- start_id         = R1_id.
-- start_ts         = R1_ts.
-- start_dur        = R1_dur.
-- start_state      = 'R'.
--
-- end_id           = S1_id.
-- end_ts           = S1_ts.
-- end_dur          = S1_dur.
-- end_state        = 'S' or 'D'.
CREATE TABLE internal_wakeup AS
  SELECT
  LAG(r.id, 1) OVER (PARTITION BY r.utid ORDER BY r.ts) AS prev_start_id,
  LAG(r.ts, 1) OVER (PARTITION BY r.utid ORDER BY r.ts) AS prev_start_ts,
  LAG(r.dur, 1) OVER (PARTITION BY r.utid ORDER BY r.ts) AS prev_start_dur,
  LAG(r.state, 1) OVER (PARTITION BY r.utid ORDER BY r.ts) AS prev_start_state,
  s.id AS prev_end_id,
  s.ts AS prev_end_ts,
  s.dur AS prev_end_dur,
  s.state AS prev_end_state,
  s.blocked_function AS prev_blocked_function,
  r.id AS start_id,
  r.ts AS start_ts,
  r.dur AS start_dur,
  r.state AS start_state,
  r.utid AS utid,
  r.waker_utid,
  LEAD(s.id, 1) OVER (PARTITION BY r.utid ORDER BY r.ts) AS end_id,
  IFNULL(LEAD(s.ts, 1) OVER (PARTITION BY r.utid ORDER BY r.ts), thread_end.end_ts)  AS end_ts,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  LEAD(s.dur, 1) OVER (PARTITION BY r.utid ORDER BY r.ts) AS end_dur,
  LEAD(s.state, 1) OVER (PARTITION BY r.utid ORDER BY r.ts) AS end_state,
  LEAD(s.blocked_function, 1) OVER (PARTITION BY r.utid ORDER BY r.ts) AS blocked_function
FROM internal_runnable_state r
JOIN internal_sleep_state s
  ON s.utid = r.utid AND (s.ts + s.dur = r.ts)
LEFT JOIN internal_thread_end_ts thread_end USING(utid)
UNION ALL
  SELECT
  NULL AS prev_start_id,
  NULL AS prev_start_ts,
  NULL AS prev_start_dur,
  NULL AS prev_start_state,
  NULL AS prev_end_id,
  NULL AS prev_end_ts,
  NULL AS prev_end_dur,
  NULL AS prev_end_state,
  NULL AS prev_blocked_function,
  r.id AS start_id,
  r.ts AS start_ts,
  r.dur AS start_dur,
  r.state AS start_state,
  r.utid AS utid,
  r.waker_utid,
  s.id AS end_id,
  IFNULL(s.ts, thread_end.end_ts)  AS end_ts,
  s.dur AS end_dur,
  s.state AS end_state,
  s.blocked_function AS blocked_function
FROM internal_first_runnable_state r
LEFT JOIN internal_first_sleep_state s
  ON s.utid = r.utid
)_d3l1m1t3r_"
R"_d3l1m1t3r_(LEFT JOIN internal_thread_end_ts thread_end USING(utid);

-- Improves performance of |internal_wakeup_chain| computation.
CREATE
  INDEX internal_wakeup_idx
ON internal_wakeup(waker_utid, start_ts);

--
-- Builds the parent-child chain from all thread_executing_spans. The parent is the waker and
-- child is the wakee.
--
-- Note that this doesn't include the roots. We'll compute the roots below.
-- This two step process improves performance because it's more efficient to scan
-- parent and find a child between than to scan child and find the parent it lies between.
CREATE VIEW internal_wakeup_chain
AS
SELECT parent.start_id AS parent_id, child.*
FROM internal_wakeup parent
JOIN internal_wakeup child
  ON (
    parent.utid = child.waker_utid
    AND child.start_ts BETWEEN parent.start_ts AND parent.end_ts);

--
-- Finds the roots of the |internal_wakeup_chain|.
CREATE VIEW internal_wakeup_root
AS
WITH
  internal_wakeup_root_id AS (
    SELECT DISTINCT parent_id AS id FROM internal_wakeup_chain
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    EXCEPT
    SELECT DISTINCT start_id AS id FROM internal_wakeup_chain
  )
SELECT NULL AS parent_id, internal_wakeup.*
FROM internal_wakeup
JOIN internal_wakeup_root_id
  ON internal_wakeup_root_id.id = internal_wakeup.start_id;

CREATE PERFETTO TABLE internal_wakeup_leaf AS
WITH
  internal_wakeup_leaf_id AS (
    SELECT DISTINCT start_id AS id FROM internal_wakeup_chain
    EXCEPT
    SELECT DISTINCT parent_id AS id FROM internal_wakeup_chain
  )
SELECT internal_wakeup_chain.*
FROM internal_wakeup_chain
JOIN internal_wakeup_leaf_id
  ON internal_wakeup_leaf_id.id = internal_wakeup_chain.start_id;

--
-- Merges the roots and the rest of the chain.
CREATE PERFETTO TABLE internal_wakeup_graph
AS
SELECT internal_wakeup_chain.*, 0 AS is_root, (internal_wakeup_leaf.start_id IS NOT NULL) AS is_leaf
FROM internal_wakeup_chain
LEFT JOIN internal_wakeup_leaf
  USING (start_id)
UNION ALL
SELECT *, 1 AS is_root, 0 AS is_leaf FROM internal_wakeup_root;

-- thread_executing_span graph of all wakeups across all processes.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--
-- @column parent_id          Id of thread_executing_span that directly woke |id|
-- @column id                 Id of the first (runnable) thread state in thread_executing_span.
-- @column ts                 Timestamp of first thread_state in thread_executing_span.
-- @column dur                Duration of thread_executing_span.
-- @column tid                Tid of thread with thread_state.
-- @column pid                Pid of process with thread_state.
-- @column utid               Utid of thread with thread_state.
-- @column upid               Upid of process with thread_state.
-- @column thread_name        Name of thread with thread_state.
-- @column process_name       Name of process with thread_state.
-- @column waker_tid          Tid of thread that woke the first thread_state in thread_executing_span.
-- @column waker_pid          Pid of process that woke the first thread_state in thread_executing_span.
-- @column waker_utid         Utid of thread that woke the first thread_state in thread_executing_span.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column waker_upid         Upid of process that woke the first thread_state in thread_executing_span.
-- @column waker_thread_name  Name of thread that woke the first thread_state in thread_executing_span.
-- @column waker_process_name Name of process that woke the first thread_state in thread_executing_span.
-- @column blocked_dur        Duration of blocking thread state before waking up.
-- @column blocked_state      Thread state ('D' or 'S') of blocked thread_state before waking up.
-- @column blocked_function   Kernel blocking function of thread state before waking up.
CREATE TABLE experimental_thread_executing_span_graph AS
SELECT
  graph.parent_id,
  graph.start_id AS id,
  graph.start_ts AS ts,
  graph.end_ts - graph.start_ts AS dur,
  thread.tid,
  process.pid,
  graph.utid,
  process.upid,
  thread.name AS thread_name,
  process.name AS process_name,
  waker_thread.tid AS waker_tid,
  waker_process.pid AS waker_pid,
  graph.waker_utid,
  waker_process.upid AS waker_upid,
  waker_thread.name AS waker_thread_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  waker_process.name AS waker_process_name,
  graph.prev_end_dur AS blocked_dur,
  graph.prev_end_state AS blocked_state,
  graph.prev_blocked_function AS blocked_function,
  graph.is_root,
  graph.is_leaf
FROM internal_wakeup_graph graph
JOIN thread
  ON thread.utid = graph.utid
LEFT JOIN process
  ON process.upid = thread.upid
LEFT JOIN thread waker_thread
  ON waker_thread.utid = graph.waker_utid
LEFT JOIN process waker_process
  ON waker_process.upid = waker_thread.upid;

CREATE
  INDEX experimental_thread_executing_span_graph_id_idx
  ON experimental_thread_executing_span_graph(id);

CREATE
  INDEX experimental_thread_executing_span_graph_parent_id_idx
ON experimental_thread_executing_span_graph(parent_id);


-- All thread_executing_spans that were recursively woken by |root_id|, all thread_executing_spans
-- in trace.
-- if root_id IS NULL, empty results if no matching thread_state id found.
--
-- @arg root_id INT           Thread state id to start recursion
--
-- @column parent_id          Id of thread_executing_span that directly woke |start_id|
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column id                 Id of the first (runnable) thread state in thread_executing_span.
-- @column ts                 Timestamp of first thread_state in thread_executing_span.
-- @column dur                Duration of thread_executing_span.
-- @column tid                Tid of thread with thread_state.
-- @column pid                Pid of process with thread_state.
-- @column utid               Utid of thread with thread_state.
-- @column upid               Upid of process with thread_state.
-- @column thread_name        Name of thread with thread_state.
-- @column process_name       Name of process with thread_state.
-- @column waker_tid          Tid of thread that woke the first thread_state in thread_executing_span.
-- @column waker_pid          Pid of process that woke the first thread_state in thread_executing_span.
-- @column waker_utid         Utid of thread that woke the first thread_state in thread_executing_span.
-- @column waker_upid         Upid of process that woke the first thread_state in thread_executing_span.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column waker_thread_name  Name of thread that woke the first thread_state in thread_executing_span.
-- @column waker_process_name Name of process that woke the first thread_state in thread_executing_span.
-- @column blocked_dur        Duration of blocking thread state before waking up.
-- @column blocked_state      Thread state ('D' or 'S') of blocked thread_state before waking up.
-- @column blocked_function   Kernel blocking function of thread state before waking up.
-- @column is_root            Whether this span is the root in the slice tree.
-- @column is_leaf            Whether this span is the leaf in the slice tree.
-- @column depth              Tree depth from |root_id|
-- @column root_id            Thread state id used to start the recursion. Helpful for SQL JOINs
SELECT CREATE_VIEW_FUNCTION(
'EXPERIMENTAL_THREAD_EXECUTING_SPAN_DESCENDANTS(root_id INT)',
'
  parent_id LONG,
  id LONG,
  ts LONG,
  dur LONG,
  tid INT,
  pid INT,
  utid INT,
  upid INT,
  thread_name STRING,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  process_name STRING,
  waker_tid INT,
  waker_pid INT,
  waker_utid INT,
  waker_upid INT,
  waker_thread_name STRING,
  waker_process_name STRING,
  blocked_dur LONG,
  blocked_state STRING,
  blocked_function STRING,
  is_root INT,
  is_leaf INT,
  depth INT,
  root_id INT
',
'
WITH chain AS (
  SELECT
    *,
    0 AS depth,
    id AS root_id
  FROM experimental_thread_executing_span_graph
  WHERE ($root_id IS NOT NULL AND id = $root_id) OR ($root_id IS NULL AND is_root)
  UNION ALL
  SELECT
    graph.*,
    chain.depth + 1 AS depth,
    chain.root_id
  FROM experimental_thread_executing_span_graph graph
  JOIN chain ON chain.id = graph.parent_id
)
SELECT * FROM chain
');

-- All thread_executing_spans that are ancestors of |leaf_id|.
--
-- @arg leaf_id INT                Thread state id to start recursion.
-- @arg leaf_utid INT              Thread utid to start recursion from.
--
-- @column parent_id               Id of thread_executing_span that directly woke |id|.
-- @column id                      Id of the first (runnable) thread state in thread_executing_span.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column ts                      Timestamp of first thread_state in thread_executing_span.
-- @column dur                     Duration of thread_executing_span.
-- @column tid                     Tid of thread with thread_state.
-- @column pid                     Pid of process with thread_state.
-- @column utid                    Utid of thread with thread_state.
-- @column upid                    Upid of process with thread_state.
-- @column thread_name             Name of thread with thread_state.
-- @column process_name            Name of process with thread_state.
-- @column waker_tid               Tid of thread that woke the first thread_state in thread_executing_span.
-- @column waker_pid               Pid of process that woke the first thread_state in thread_executing_span.
-- @column waker_utid              Utid of thread that woke the first thread_state in thread_executing_span.
-- @column waker_upid              Upid of process that woke the first thread_state in thread_executing_span.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column waker_thread_name       Name of thread that woke the first thread_state in thread_executing_span.
-- @column waker_process_name      Name of process that woke the first thread_state in thread_executing_span.
-- @column blocked_dur             Duration of blocking thread state before waking up.
-- @column blocked_state           Thread state ('D' or 'S') of blocked thread_state before waking up.
-- @column blocked_function        Kernel blocking function of thread state before waking up.
-- @column is_root                 Whether this span is the root in the slice tree.
-- @column is_leaf                 Whether this span is the leaf in the slice tree.
-- @column height                  Tree height from |leaf_id|.
-- @column leaf_id                 Thread state id used to start the recursion. Helpful for SQL JOINs.
-- @column leaf_ts                 Thread state timestamp of the |leaf_id|.
-- @column leaf_utid               Thread Utid of the |leaf_id|.
-- @column leaf_blocked_dur        Thread state duration blocked of the |leaf_id|.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column leaf_blocked_state      Thread state of the |leaf_id|.
-- @column leaf_blocked_function   Thread state blocked_function of the |leaf_id|.
SELECT CREATE_VIEW_FUNCTION(
'EXPERIMENTAL_THREAD_EXECUTING_SPAN_ANCESTORS(leaf_id INT, leaf_utid INT)',
'
  parent_id LONG,
  id LONG,
  ts LONG,
  dur LONG,
  tid INT,
  pid INT,
  utid INT,
  upid INT,
  thread_name STRING,
  process_name STRING,
  waker_tid INT,
  waker_pid INT,
  waker_utid INT,
  waker_upid INT,
  waker_thread_name STRING,
  waker_process_name STRING,
  blocked_dur LONG,
  blocked_state STRING,
  blocked_function STRING,
  is_root INT,
  is_leaf INT,
  height INT,
  leaf_id INT,
  leaf_ts LONG,
  leaf_utid INT,
  leaf_blocked_dur LONG,
  leaf_blocked_state STRING,
  leaf_blocked_function STRING
',
'
WITH
chain AS (
  SELECT
    *,
    0 AS height,
    id AS leaf_id,
    ts AS leaf_ts,
    utid AS leaf_utid,
    blocked_dur AS leaf_blocked_dur,
    blocked_state AS leaf_blocked_state,
    blocked_function AS leaf_blocked_function
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM experimental_thread_executing_span_graph
  WHERE (($leaf_id IS NOT NULL AND id = $leaf_id) OR ($leaf_id IS NULL))
    AND (($leaf_utid IS NOT NULL AND utid = $leaf_utid) OR ($leaf_utid IS NULL))
  UNION ALL
  SELECT
    graph.*,
    chain.height + 1 AS height,
    chain.leaf_id,
    chain.leaf_ts,
    chain.leaf_utid,
    chain.leaf_blocked_dur,
    chain.leaf_blocked_state,
    chain.leaf_blocked_function
  FROM experimental_thread_executing_span_graph graph
  JOIN chain ON chain.parent_id = graph.id AND chain.ts >= (leaf_ts - leaf_blocked_dur)
)
SELECT * FROM chain
');

-- Gets the thread_executing_span id a thread_state belongs to. Returns NULL if thread state is
-- sleeping and not blocked on an interrupt.
--
-- @arg thread_state_id INT   Id of the thread_state to get the thread_executing_span id for
-- @ret INT                   thread_executing_span id
CREATE PERFETTO FUNCTION
experimental_thread_executing_span_id_from_thread_state_id(thread_state_id INT)
RETURNS INT AS
WITH executing AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SELECT
    ts,
    utid
  FROM thread_state
  WHERE
    id = $thread_state_id
)
SELECT
  MAX(start_id) AS thread_executing_span_id
FROM internal_wakeup wakeup, executing
WHERE executing.utid = wakeup.utid AND executing.ts >= wakeup.start_ts AND executing.ts < wakeup.end_ts;

-- Gets the next thread_executing_span id after a sleeping state. Returns NULL if there is no
-- thread_executing_span after the |thread_state_id|.
--
-- @arg thread_state_id INT   Id of the thread_state to get the next thread_executing_span id for
-- @ret INT                   thread_executing_span id
CREATE PERFETTO FUNCTION
experimental_thread_executing_span_following_thread_state_id(thread_state_id INT)
RETURNS INT AS
WITH
  sleeping AS (
  SELECT
    ts,
    utid
  FROM thread_state
  WHERE
    id = $thread_state_id AND (state = 'S' OR state = 'D' OR state = 'I')
  )
SELECT MIN(start_id) AS thread_executing_span_id
FROM internal_wakeup wakeup, sleeping
WHERE sleeping.utid = wakeup.utid AND sleeping.ts < wakeup.start_ts;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Computes the start of each thread_executing_span in the critical path.

-- It finds the MAX between the start of the critical span and the start
-- of the blocked region. This ensures that the critical path doesn't overlap
-- the preceding thread_executing_span before the blocked region.
CREATE PERFETTO FUNCTION internal_critical_path_start_ts(ts LONG, leaf_ts LONG, leaf_blocked_dur LONG)
RETURNS LONG AS SELECT MAX($ts, IFNULL($leaf_ts - $leaf_blocked_dur, $ts));

-- Critical path of thread_executing_spans blocking the thread_executing_span with id,
-- |thread_executing_span_id|. For a given thread state span, its duration in the critical path
-- is the range between the start of the thread_executing_span and the start of the next span in the
-- critical path.
--
-- @arg thread_executing_span_id INT        Id of blocked thread_executing_span.
-- @arg utid INT                            Thread utid to pre-filter critical paths for.
--
-- @column parent_id                        Id of thread_executing_span that directly woke |id|.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column id                               Id of the first (runnable) thread state in thread_executing_span.
-- @column ts                               Timestamp of first thread_state in thread_executing_span.
-- @column dur                              Duration of thread_executing_span within the critical path.
-- @column tid                              Tid of thread with thread_state.
-- @column pid                              Pid of process with thread_state.
-- @column utid                             Utid of thread with thread_state.
-- @column upid                             Upid of process with thread_state.
-- @column thread_name                      Name of thread with thread_state.
-- @column process_name                     Name of process with thread_state.
-- @column waker_tid                        Tid of thread that woke the first thread_state in thread_executing_span.
-- @column waker_pid                        Pid of process that woke the first thread_state in thread_executing_span.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column waker_utid                       Utid of thread that woke the first thread_state in thread_executing_span.
-- @column waker_upid                       Upid of process that woke the first thread_state in thread_executing_span.
-- @column waker_thread_name                Name of thread that woke the first thread_state in thread_executing_span.
-- @column waker_process_name               Name of process that woke the first thread_state in thread_executing_span.
-- @column blocked_dur                      Duration of blocking thread state before waking up.
-- @column blocked_state                    Thread state ('D' or 'S') of blocked thread_state before waking up.
-- @column blocked_function                 Kernel blocking function of thread state before waking up.
-- @column is_root                          Whether this span is the root in the slice tree.
-- @column is_leaf                          Whether this span is the leaf in the slice tree.
-- @column height                           Tree height from |leaf_id|.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column leaf_id                          Thread state id used to start the recursion. Helpful for SQL JOINs.
-- @column leaf_ts                          Thread state timestamp of the |leaf_id|.
-- @column leaf_utid                        Thread Utid of the |leaf_id|. Helpful for post-filtering the critical path to those originating from a thread.
-- @column leaf_blocked_dur                 Thread state duration blocked of the |leaf_id|.
-- @column leaf_blocked_state               Thread state of the |leaf_id|.
-- @column leaf_blocked_function            Thread state blocked_function of the |leaf_id|.
CREATE PERFETTO FUNCTION experimental_thread_executing_span_critical_path(thread_executing_span_id INT, leaf_utid INT)
RETURNS TABLE(
  parent_id LONG,
  id LONG,
  ts LONG,
  dur LONG,
  tid INT,
  pid INT,
  utid INT,
  upid INT,
  thread_name STRING,
  process_name STRING,
  waker_tid INT,
  waker_pid INT,
  waker_utid INT,
  waker_upid INT,
  waker_thread_name STRING,
  waker_process_name STRING,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  blocked_dur LONG,
  blocked_state STRING,
  blocked_function STRING,
  is_root INT,
  is_leaf INT,
  height INT,
  leaf_id INT,
  leaf_ts LONG,
  leaf_utid INT,
  leaf_blocked_dur LONG,
  leaf_blocked_state STRING,
  leaf_blocked_function STRING
) AS
 SELECT
    parent_id,
    id,
    -- Here we compute the real ts and dur of a span in the critical_path.
    -- For the ts, we simply use the internal_critical_path_start_ts helper function.
    internal_critical_path_start_ts(ts, leaf_ts, leaf_blocked_dur) AS ts,
    -- For the dur, it is the MIN between the end of the current span and the start of
    -- the next span in the critical path. This ensures that the critical paths don't overlap.
    -- We are simply doing a MIN(real_ts + dur, lead(ts) - ts). It's written inline here for
    -- performance reasons. Note that we don't need the real_ts in the lead() because the real_ts
    -- is really only needed for the first ts in the critical path.
    MIN(internal_critical_path_start_ts(ts, leaf_ts, leaf_blocked_dur) + dur,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        IFNULL(LEAD(ts) OVER (PARTITION BY leaf_id ORDER BY height DESC), trace_bounds.end_ts))
    - internal_critical_path_start_ts(ts, leaf_ts, leaf_blocked_dur) AS dur,
    tid,
    pid,
    utid,
    upid,
    thread_name,
    process_name,
    waker_tid,
    waker_pid,
    waker_utid,
    waker_upid,
    waker_thread_name,
    waker_process_name,
    blocked_dur,
    blocked_state,
    blocked_function,
    is_root,
    is_leaf,
    height,
    leaf_id,
    leaf_ts,
    leaf_utid,
    leaf_blocked_dur,
    leaf_blocked_state,
    leaf_blocked_function
  FROM experimental_thread_executing_span_ancestors($thread_executing_span_id, $leaf_utid),
    trace_bounds;

)_d3l1m1t3r_"
;

const char kPkvmHypervisor[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Events when CPU entered hypervisor.
--
-- @column slice_id       Id of the corresponding slice in slices table.
-- @column cpu            CPU that entered hypervisor.
-- @column ts             Timestamp when CPU entered hypervisor (in nanoseconds).
-- @column dur            How much time CPU spent in hypervisor (in nanoseconds).
-- @column reason         Reason for entering hypervisor (e.g. host_hcall, host_mem_abort), or NULL if unknown.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE VIEW pkvm_hypervisor_events AS
SELECT
  slices.id as slice_id,
  cpu_track.cpu as cpu,
  slices.ts as ts,
  slices.dur as dur,
  EXTRACT_ARG(slices.arg_set_id, 'hyp_enter_reason') as reason
FROM slices
JOIN cpu_track ON cpu_track.id = slices.track_id
WHERE
  slices.category = 'pkvm_hyp'

)_d3l1m1t3r_"
;

struct FileToSql {
  const char* path;
  const char* sql;
};

const FileToSql kFileToSql[] = {
  {"android/startup/internal_startups_maxsdk28.sql", kAndroidStartupInternalStartupsMaxsdk28},

  {"android/startup/internal_startups_minsdk29.sql", kAndroidStartupInternalStartupsMinsdk29},

  {"android/startup/internal_startups_minsdk33.sql", kAndroidStartupInternalStartupsMinsdk33},

  {"android/startup/startups.sql", kAndroidStartupStartups},

  {"android/battery.sql", kAndroidBattery},

  {"android/battery_stats.sql", kAndroidBatteryStats},

  {"android/binder.sql", kAndroidBinder},

  {"android/io.sql", kAndroidIo},

  {"android/monitor_contention.sql", kAndroidMonitorContention},

  {"android/network_packets.sql", kAndroidNetworkPackets},

  {"android/process_metadata.sql", kAndroidProcessMetadata},

  {"android/slices.sql", kAndroidSlices},

  {"android/statsd.sql", kAndroidStatsd},

  {"android/thread.sql", kAndroidThread},

  {"chrome/chrome_scroll_janks.sql", kChromeChromeScrollJanks},

  {"chrome/chrome_scrolls.sql", kChromeChromeScrolls},

  {"chrome/cpu_powerups.sql", kChromeCpuPowerups},

  {"chrome/histograms.sql", kChromeHistograms},

  {"chrome/metadata.sql", kChromeMetadata},

  {"chrome/speedometer.sql", kChromeSpeedometer},

  {"chrome/tasks.sql", kChromeTasks},

  {"common/args.sql", kCommonArgs},

  {"common/counters.sql", kCommonCounters},

  {"common/cpus.sql", kCommonCpus},

  {"common/metadata.sql", kCommonMetadata},

  {"common/percentiles.sql", kCommonPercentiles},

  {"common/slices.sql", kCommonSlices},

  {"common/timestamps.sql", kCommonTimestamps},

  {"experimental/android_broadcast.sql", kExperimentalAndroidBroadcast},

  {"experimental/flat_slices.sql", kExperimentalFlatSlices},

  {"experimental/proto_path.sql", kExperimentalProtoPath},

  {"experimental/slices.sql", kExperimentalSlices},

  {"experimental/thread_executing_span.sql", kExperimentalThreadExecutingSpan},

  {"pkvm/hypervisor.sql", kPkvmHypervisor},
};

}  // namespace stdlib
}  // namespace trace_processor
}  // namespace perfetto
