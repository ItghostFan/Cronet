// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_MALI_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_MALI_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class MaliMaliCSFINTERRUPTENDFtraceEvent;
class MaliMaliCSFINTERRUPTSTARTFtraceEvent;
class MaliMaliKCPUFENCEWAITENDFtraceEvent;
class MaliMaliKCPUFENCEWAITSTARTFtraceEvent;
class MaliMaliKCPUFENCESIGNALFtraceEvent;
class MaliMaliKCPUCQSWAITENDFtraceEvent;
class MaliMaliKCPUCQSWAITSTARTFtraceEvent;
class MaliMaliKCPUCQSSETFtraceEvent;
class MaliTracingMarkWriteFtraceEvent;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT_COMPONENT MaliMaliCSFINTERRUPTENDFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kKctxTgidFieldNumber = 1,
    kKctxIdFieldNumber = 2,
    kInfoValFieldNumber = 3,
  };

  MaliMaliCSFINTERRUPTENDFtraceEvent();
  ~MaliMaliCSFINTERRUPTENDFtraceEvent() override;
  MaliMaliCSFINTERRUPTENDFtraceEvent(MaliMaliCSFINTERRUPTENDFtraceEvent&&) noexcept;
  MaliMaliCSFINTERRUPTENDFtraceEvent& operator=(MaliMaliCSFINTERRUPTENDFtraceEvent&&);
  MaliMaliCSFINTERRUPTENDFtraceEvent(const MaliMaliCSFINTERRUPTENDFtraceEvent&);
  MaliMaliCSFINTERRUPTENDFtraceEvent& operator=(const MaliMaliCSFINTERRUPTENDFtraceEvent&);
  bool operator==(const MaliMaliCSFINTERRUPTENDFtraceEvent&) const;
  bool operator!=(const MaliMaliCSFINTERRUPTENDFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_kctx_tgid() const { return _has_field_[1]; }
  int32_t kctx_tgid() const { return kctx_tgid_; }
  void set_kctx_tgid(int32_t value) { kctx_tgid_ = value; _has_field_.set(1); }

  bool has_kctx_id() const { return _has_field_[2]; }
  uint32_t kctx_id() const { return kctx_id_; }
  void set_kctx_id(uint32_t value) { kctx_id_ = value; _has_field_.set(2); }

  bool has_info_val() const { return _has_field_[3]; }
  uint64_t info_val() const { return info_val_; }
  void set_info_val(uint64_t value) { info_val_ = value; _has_field_.set(3); }

 private:
  int32_t kctx_tgid_{};
  uint32_t kctx_id_{};
  uint64_t info_val_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT MaliMaliCSFINTERRUPTSTARTFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kKctxTgidFieldNumber = 1,
    kKctxIdFieldNumber = 2,
    kInfoValFieldNumber = 3,
  };

  MaliMaliCSFINTERRUPTSTARTFtraceEvent();
  ~MaliMaliCSFINTERRUPTSTARTFtraceEvent() override;
  MaliMaliCSFINTERRUPTSTARTFtraceEvent(MaliMaliCSFINTERRUPTSTARTFtraceEvent&&) noexcept;
  MaliMaliCSFINTERRUPTSTARTFtraceEvent& operator=(MaliMaliCSFINTERRUPTSTARTFtraceEvent&&);
  MaliMaliCSFINTERRUPTSTARTFtraceEvent(const MaliMaliCSFINTERRUPTSTARTFtraceEvent&);
  MaliMaliCSFINTERRUPTSTARTFtraceEvent& operator=(const MaliMaliCSFINTERRUPTSTARTFtraceEvent&);
  bool operator==(const MaliMaliCSFINTERRUPTSTARTFtraceEvent&) const;
  bool operator!=(const MaliMaliCSFINTERRUPTSTARTFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_kctx_tgid() const { return _has_field_[1]; }
  int32_t kctx_tgid() const { return kctx_tgid_; }
  void set_kctx_tgid(int32_t value) { kctx_tgid_ = value; _has_field_.set(1); }

  bool has_kctx_id() const { return _has_field_[2]; }
  uint32_t kctx_id() const { return kctx_id_; }
  void set_kctx_id(uint32_t value) { kctx_id_ = value; _has_field_.set(2); }

  bool has_info_val() const { return _has_field_[3]; }
  uint64_t info_val() const { return info_val_; }
  void set_info_val(uint64_t value) { info_val_ = value; _has_field_.set(3); }

 private:
  int32_t kctx_tgid_{};
  uint32_t kctx_id_{};
  uint64_t info_val_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT MaliMaliKCPUFENCEWAITENDFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kInfoVal1FieldNumber = 1,
    kInfoVal2FieldNumber = 2,
    kKctxTgidFieldNumber = 3,
    kKctxIdFieldNumber = 4,
    kIdFieldNumber = 5,
  };

  MaliMaliKCPUFENCEWAITENDFtraceEvent();
  ~MaliMaliKCPUFENCEWAITENDFtraceEvent() override;
  MaliMaliKCPUFENCEWAITENDFtraceEvent(MaliMaliKCPUFENCEWAITENDFtraceEvent&&) noexcept;
  MaliMaliKCPUFENCEWAITENDFtraceEvent& operator=(MaliMaliKCPUFENCEWAITENDFtraceEvent&&);
  MaliMaliKCPUFENCEWAITENDFtraceEvent(const MaliMaliKCPUFENCEWAITENDFtraceEvent&);
  MaliMaliKCPUFENCEWAITENDFtraceEvent& operator=(const MaliMaliKCPUFENCEWAITENDFtraceEvent&);
  bool operator==(const MaliMaliKCPUFENCEWAITENDFtraceEvent&) const;
  bool operator!=(const MaliMaliKCPUFENCEWAITENDFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_info_val1() const { return _has_field_[1]; }
  uint64_t info_val1() const { return info_val1_; }
  void set_info_val1(uint64_t value) { info_val1_ = value; _has_field_.set(1); }

  bool has_info_val2() const { return _has_field_[2]; }
  uint64_t info_val2() const { return info_val2_; }
  void set_info_val2(uint64_t value) { info_val2_ = value; _has_field_.set(2); }

  bool has_kctx_tgid() const { return _has_field_[3]; }
  int32_t kctx_tgid() const { return kctx_tgid_; }
  void set_kctx_tgid(int32_t value) { kctx_tgid_ = value; _has_field_.set(3); }

  bool has_kctx_id() const { return _has_field_[4]; }
  uint32_t kctx_id() const { return kctx_id_; }
  void set_kctx_id(uint32_t value) { kctx_id_ = value; _has_field_.set(4); }

  bool has_id() const { return _has_field_[5]; }
  uint32_t id() const { return id_; }
  void set_id(uint32_t value) { id_ = value; _has_field_.set(5); }

 private:
  uint64_t info_val1_{};
  uint64_t info_val2_{};
  int32_t kctx_tgid_{};
  uint32_t kctx_id_{};
  uint32_t id_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT MaliMaliKCPUFENCEWAITSTARTFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kInfoVal1FieldNumber = 1,
    kInfoVal2FieldNumber = 2,
    kKctxTgidFieldNumber = 3,
    kKctxIdFieldNumber = 4,
    kIdFieldNumber = 5,
  };

  MaliMaliKCPUFENCEWAITSTARTFtraceEvent();
  ~MaliMaliKCPUFENCEWAITSTARTFtraceEvent() override;
  MaliMaliKCPUFENCEWAITSTARTFtraceEvent(MaliMaliKCPUFENCEWAITSTARTFtraceEvent&&) noexcept;
  MaliMaliKCPUFENCEWAITSTARTFtraceEvent& operator=(MaliMaliKCPUFENCEWAITSTARTFtraceEvent&&);
  MaliMaliKCPUFENCEWAITSTARTFtraceEvent(const MaliMaliKCPUFENCEWAITSTARTFtraceEvent&);
  MaliMaliKCPUFENCEWAITSTARTFtraceEvent& operator=(const MaliMaliKCPUFENCEWAITSTARTFtraceEvent&);
  bool operator==(const MaliMaliKCPUFENCEWAITSTARTFtraceEvent&) const;
  bool operator!=(const MaliMaliKCPUFENCEWAITSTARTFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_info_val1() const { return _has_field_[1]; }
  uint64_t info_val1() const { return info_val1_; }
  void set_info_val1(uint64_t value) { info_val1_ = value; _has_field_.set(1); }

  bool has_info_val2() const { return _has_field_[2]; }
  uint64_t info_val2() const { return info_val2_; }
  void set_info_val2(uint64_t value) { info_val2_ = value; _has_field_.set(2); }

  bool has_kctx_tgid() const { return _has_field_[3]; }
  int32_t kctx_tgid() const { return kctx_tgid_; }
  void set_kctx_tgid(int32_t value) { kctx_tgid_ = value; _has_field_.set(3); }

  bool has_kctx_id() const { return _has_field_[4]; }
  uint32_t kctx_id() const { return kctx_id_; }
  void set_kctx_id(uint32_t value) { kctx_id_ = value; _has_field_.set(4); }

  bool has_id() const { return _has_field_[5]; }
  uint32_t id() const { return id_; }
  void set_id(uint32_t value) { id_ = value; _has_field_.set(5); }

 private:
  uint64_t info_val1_{};
  uint64_t info_val2_{};
  int32_t kctx_tgid_{};
  uint32_t kctx_id_{};
  uint32_t id_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT MaliMaliKCPUFENCESIGNALFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kInfoVal1FieldNumber = 1,
    kInfoVal2FieldNumber = 2,
    kKctxTgidFieldNumber = 3,
    kKctxIdFieldNumber = 4,
    kIdFieldNumber = 5,
  };

  MaliMaliKCPUFENCESIGNALFtraceEvent();
  ~MaliMaliKCPUFENCESIGNALFtraceEvent() override;
  MaliMaliKCPUFENCESIGNALFtraceEvent(MaliMaliKCPUFENCESIGNALFtraceEvent&&) noexcept;
  MaliMaliKCPUFENCESIGNALFtraceEvent& operator=(MaliMaliKCPUFENCESIGNALFtraceEvent&&);
  MaliMaliKCPUFENCESIGNALFtraceEvent(const MaliMaliKCPUFENCESIGNALFtraceEvent&);
  MaliMaliKCPUFENCESIGNALFtraceEvent& operator=(const MaliMaliKCPUFENCESIGNALFtraceEvent&);
  bool operator==(const MaliMaliKCPUFENCESIGNALFtraceEvent&) const;
  bool operator!=(const MaliMaliKCPUFENCESIGNALFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_info_val1() const { return _has_field_[1]; }
  uint64_t info_val1() const { return info_val1_; }
  void set_info_val1(uint64_t value) { info_val1_ = value; _has_field_.set(1); }

  bool has_info_val2() const { return _has_field_[2]; }
  uint64_t info_val2() const { return info_val2_; }
  void set_info_val2(uint64_t value) { info_val2_ = value; _has_field_.set(2); }

  bool has_kctx_tgid() const { return _has_field_[3]; }
  int32_t kctx_tgid() const { return kctx_tgid_; }
  void set_kctx_tgid(int32_t value) { kctx_tgid_ = value; _has_field_.set(3); }

  bool has_kctx_id() const { return _has_field_[4]; }
  uint32_t kctx_id() const { return kctx_id_; }
  void set_kctx_id(uint32_t value) { kctx_id_ = value; _has_field_.set(4); }

  bool has_id() const { return _has_field_[5]; }
  uint32_t id() const { return id_; }
  void set_id(uint32_t value) { id_ = value; _has_field_.set(5); }

 private:
  uint64_t info_val1_{};
  uint64_t info_val2_{};
  int32_t kctx_tgid_{};
  uint32_t kctx_id_{};
  uint32_t id_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT MaliMaliKCPUCQSWAITENDFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kIdFieldNumber = 1,
    kInfoVal1FieldNumber = 2,
    kInfoVal2FieldNumber = 3,
    kKctxIdFieldNumber = 4,
    kKctxTgidFieldNumber = 5,
  };

  MaliMaliKCPUCQSWAITENDFtraceEvent();
  ~MaliMaliKCPUCQSWAITENDFtraceEvent() override;
  MaliMaliKCPUCQSWAITENDFtraceEvent(MaliMaliKCPUCQSWAITENDFtraceEvent&&) noexcept;
  MaliMaliKCPUCQSWAITENDFtraceEvent& operator=(MaliMaliKCPUCQSWAITENDFtraceEvent&&);
  MaliMaliKCPUCQSWAITENDFtraceEvent(const MaliMaliKCPUCQSWAITENDFtraceEvent&);
  MaliMaliKCPUCQSWAITENDFtraceEvent& operator=(const MaliMaliKCPUCQSWAITENDFtraceEvent&);
  bool operator==(const MaliMaliKCPUCQSWAITENDFtraceEvent&) const;
  bool operator!=(const MaliMaliKCPUCQSWAITENDFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_id() const { return _has_field_[1]; }
  uint32_t id() const { return id_; }
  void set_id(uint32_t value) { id_ = value; _has_field_.set(1); }

  bool has_info_val1() const { return _has_field_[2]; }
  uint64_t info_val1() const { return info_val1_; }
  void set_info_val1(uint64_t value) { info_val1_ = value; _has_field_.set(2); }

  bool has_info_val2() const { return _has_field_[3]; }
  uint64_t info_val2() const { return info_val2_; }
  void set_info_val2(uint64_t value) { info_val2_ = value; _has_field_.set(3); }

  bool has_kctx_id() const { return _has_field_[4]; }
  uint32_t kctx_id() const { return kctx_id_; }
  void set_kctx_id(uint32_t value) { kctx_id_ = value; _has_field_.set(4); }

  bool has_kctx_tgid() const { return _has_field_[5]; }
  int32_t kctx_tgid() const { return kctx_tgid_; }
  void set_kctx_tgid(int32_t value) { kctx_tgid_ = value; _has_field_.set(5); }

 private:
  uint32_t id_{};
  uint64_t info_val1_{};
  uint64_t info_val2_{};
  uint32_t kctx_id_{};
  int32_t kctx_tgid_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT MaliMaliKCPUCQSWAITSTARTFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kIdFieldNumber = 1,
    kInfoVal1FieldNumber = 2,
    kInfoVal2FieldNumber = 3,
    kKctxIdFieldNumber = 4,
    kKctxTgidFieldNumber = 5,
  };

  MaliMaliKCPUCQSWAITSTARTFtraceEvent();
  ~MaliMaliKCPUCQSWAITSTARTFtraceEvent() override;
  MaliMaliKCPUCQSWAITSTARTFtraceEvent(MaliMaliKCPUCQSWAITSTARTFtraceEvent&&) noexcept;
  MaliMaliKCPUCQSWAITSTARTFtraceEvent& operator=(MaliMaliKCPUCQSWAITSTARTFtraceEvent&&);
  MaliMaliKCPUCQSWAITSTARTFtraceEvent(const MaliMaliKCPUCQSWAITSTARTFtraceEvent&);
  MaliMaliKCPUCQSWAITSTARTFtraceEvent& operator=(const MaliMaliKCPUCQSWAITSTARTFtraceEvent&);
  bool operator==(const MaliMaliKCPUCQSWAITSTARTFtraceEvent&) const;
  bool operator!=(const MaliMaliKCPUCQSWAITSTARTFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_id() const { return _has_field_[1]; }
  uint32_t id() const { return id_; }
  void set_id(uint32_t value) { id_ = value; _has_field_.set(1); }

  bool has_info_val1() const { return _has_field_[2]; }
  uint64_t info_val1() const { return info_val1_; }
  void set_info_val1(uint64_t value) { info_val1_ = value; _has_field_.set(2); }

  bool has_info_val2() const { return _has_field_[3]; }
  uint64_t info_val2() const { return info_val2_; }
  void set_info_val2(uint64_t value) { info_val2_ = value; _has_field_.set(3); }

  bool has_kctx_id() const { return _has_field_[4]; }
  uint32_t kctx_id() const { return kctx_id_; }
  void set_kctx_id(uint32_t value) { kctx_id_ = value; _has_field_.set(4); }

  bool has_kctx_tgid() const { return _has_field_[5]; }
  int32_t kctx_tgid() const { return kctx_tgid_; }
  void set_kctx_tgid(int32_t value) { kctx_tgid_ = value; _has_field_.set(5); }

 private:
  uint32_t id_{};
  uint64_t info_val1_{};
  uint64_t info_val2_{};
  uint32_t kctx_id_{};
  int32_t kctx_tgid_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT MaliMaliKCPUCQSSETFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kIdFieldNumber = 1,
    kInfoVal1FieldNumber = 2,
    kInfoVal2FieldNumber = 3,
    kKctxIdFieldNumber = 4,
    kKctxTgidFieldNumber = 5,
  };

  MaliMaliKCPUCQSSETFtraceEvent();
  ~MaliMaliKCPUCQSSETFtraceEvent() override;
  MaliMaliKCPUCQSSETFtraceEvent(MaliMaliKCPUCQSSETFtraceEvent&&) noexcept;
  MaliMaliKCPUCQSSETFtraceEvent& operator=(MaliMaliKCPUCQSSETFtraceEvent&&);
  MaliMaliKCPUCQSSETFtraceEvent(const MaliMaliKCPUCQSSETFtraceEvent&);
  MaliMaliKCPUCQSSETFtraceEvent& operator=(const MaliMaliKCPUCQSSETFtraceEvent&);
  bool operator==(const MaliMaliKCPUCQSSETFtraceEvent&) const;
  bool operator!=(const MaliMaliKCPUCQSSETFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_id() const { return _has_field_[1]; }
  uint32_t id() const { return id_; }
  void set_id(uint32_t value) { id_ = value; _has_field_.set(1); }

  bool has_info_val1() const { return _has_field_[2]; }
  uint64_t info_val1() const { return info_val1_; }
  void set_info_val1(uint64_t value) { info_val1_ = value; _has_field_.set(2); }

  bool has_info_val2() const { return _has_field_[3]; }
  uint64_t info_val2() const { return info_val2_; }
  void set_info_val2(uint64_t value) { info_val2_ = value; _has_field_.set(3); }

  bool has_kctx_id() const { return _has_field_[4]; }
  uint32_t kctx_id() const { return kctx_id_; }
  void set_kctx_id(uint32_t value) { kctx_id_ = value; _has_field_.set(4); }

  bool has_kctx_tgid() const { return _has_field_[5]; }
  int32_t kctx_tgid() const { return kctx_tgid_; }
  void set_kctx_tgid(int32_t value) { kctx_tgid_ = value; _has_field_.set(5); }

 private:
  uint32_t id_{};
  uint64_t info_val1_{};
  uint64_t info_val2_{};
  uint32_t kctx_id_{};
  int32_t kctx_tgid_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT MaliTracingMarkWriteFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNameFieldNumber = 1,
    kPidFieldNumber = 2,
    kTypeFieldNumber = 3,
    kValueFieldNumber = 4,
  };

  MaliTracingMarkWriteFtraceEvent();
  ~MaliTracingMarkWriteFtraceEvent() override;
  MaliTracingMarkWriteFtraceEvent(MaliTracingMarkWriteFtraceEvent&&) noexcept;
  MaliTracingMarkWriteFtraceEvent& operator=(MaliTracingMarkWriteFtraceEvent&&);
  MaliTracingMarkWriteFtraceEvent(const MaliTracingMarkWriteFtraceEvent&);
  MaliTracingMarkWriteFtraceEvent& operator=(const MaliTracingMarkWriteFtraceEvent&);
  bool operator==(const MaliTracingMarkWriteFtraceEvent&) const;
  bool operator!=(const MaliTracingMarkWriteFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_name() const { return _has_field_[1]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(1); }

  bool has_pid() const { return _has_field_[2]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(2); }

  bool has_type() const { return _has_field_[3]; }
  uint32_t type() const { return type_; }
  void set_type(uint32_t value) { type_ = value; _has_field_.set(3); }

  bool has_value() const { return _has_field_[4]; }
  int32_t value() const { return value_; }
  void set_value(int32_t value) { value_ = value; _has_field_.set(4); }

 private:
  std::string name_{};
  int32_t pid_{};
  uint32_t type_{};
  int32_t value_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_MALI_PROTO_CPP_H_
