// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/ftrace/kvm.proto

#include "protos/perfetto/trace/ftrace/kvm.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace perfetto {
namespace protos {
PROTOBUF_CONSTEXPR KvmAccessFaultFtraceEvent::KvmAccessFaultFtraceEvent(
    ::_pbi::ConstantInitialized)
  : ipa_(uint64_t{0u}){}
struct KvmAccessFaultFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmAccessFaultFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmAccessFaultFtraceEventDefaultTypeInternal() {}
  union {
    KvmAccessFaultFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmAccessFaultFtraceEventDefaultTypeInternal _KvmAccessFaultFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmAckIrqFtraceEvent::KvmAckIrqFtraceEvent(
    ::_pbi::ConstantInitialized)
  : irqchip_(0u)
  , pin_(0u){}
struct KvmAckIrqFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmAckIrqFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmAckIrqFtraceEventDefaultTypeInternal() {}
  union {
    KvmAckIrqFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmAckIrqFtraceEventDefaultTypeInternal _KvmAckIrqFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmAgeHvaFtraceEvent::KvmAgeHvaFtraceEvent(
    ::_pbi::ConstantInitialized)
  : end_(uint64_t{0u})
  , start_(uint64_t{0u}){}
struct KvmAgeHvaFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmAgeHvaFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmAgeHvaFtraceEventDefaultTypeInternal() {}
  union {
    KvmAgeHvaFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmAgeHvaFtraceEventDefaultTypeInternal _KvmAgeHvaFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmAgePageFtraceEvent::KvmAgePageFtraceEvent(
    ::_pbi::ConstantInitialized)
  : gfn_(uint64_t{0u})
  , hva_(uint64_t{0u})
  , level_(0u)
  , referenced_(0u){}
struct KvmAgePageFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmAgePageFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmAgePageFtraceEventDefaultTypeInternal() {}
  union {
    KvmAgePageFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmAgePageFtraceEventDefaultTypeInternal _KvmAgePageFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmArmClearDebugFtraceEvent::KvmArmClearDebugFtraceEvent(
    ::_pbi::ConstantInitialized)
  : guest_debug_(0u){}
struct KvmArmClearDebugFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmArmClearDebugFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmArmClearDebugFtraceEventDefaultTypeInternal() {}
  union {
    KvmArmClearDebugFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmArmClearDebugFtraceEventDefaultTypeInternal _KvmArmClearDebugFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmArmSetDreg32FtraceEvent::KvmArmSetDreg32FtraceEvent(
    ::_pbi::ConstantInitialized)
  : name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , value_(0u){}
struct KvmArmSetDreg32FtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmArmSetDreg32FtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmArmSetDreg32FtraceEventDefaultTypeInternal() {}
  union {
    KvmArmSetDreg32FtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmArmSetDreg32FtraceEventDefaultTypeInternal _KvmArmSetDreg32FtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmArmSetRegsetFtraceEvent::KvmArmSetRegsetFtraceEvent(
    ::_pbi::ConstantInitialized)
  : name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , len_(0){}
struct KvmArmSetRegsetFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmArmSetRegsetFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmArmSetRegsetFtraceEventDefaultTypeInternal() {}
  union {
    KvmArmSetRegsetFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmArmSetRegsetFtraceEventDefaultTypeInternal _KvmArmSetRegsetFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmArmSetupDebugFtraceEvent::KvmArmSetupDebugFtraceEvent(
    ::_pbi::ConstantInitialized)
  : vcpu_(uint64_t{0u})
  , guest_debug_(0u){}
struct KvmArmSetupDebugFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmArmSetupDebugFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmArmSetupDebugFtraceEventDefaultTypeInternal() {}
  union {
    KvmArmSetupDebugFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmArmSetupDebugFtraceEventDefaultTypeInternal _KvmArmSetupDebugFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmEntryFtraceEvent::KvmEntryFtraceEvent(
    ::_pbi::ConstantInitialized)
  : vcpu_pc_(uint64_t{0u}){}
struct KvmEntryFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmEntryFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmEntryFtraceEventDefaultTypeInternal() {}
  union {
    KvmEntryFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmEntryFtraceEventDefaultTypeInternal _KvmEntryFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmExitFtraceEvent::KvmExitFtraceEvent(
    ::_pbi::ConstantInitialized)
  : esr_ec_(0u)
  , ret_(0)
  , vcpu_pc_(uint64_t{0u}){}
struct KvmExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmExitFtraceEventDefaultTypeInternal() {}
  union {
    KvmExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmExitFtraceEventDefaultTypeInternal _KvmExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmFpuFtraceEvent::KvmFpuFtraceEvent(
    ::_pbi::ConstantInitialized)
  : load_(0u){}
struct KvmFpuFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmFpuFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmFpuFtraceEventDefaultTypeInternal() {}
  union {
    KvmFpuFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmFpuFtraceEventDefaultTypeInternal _KvmFpuFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmGetTimerMapFtraceEvent::KvmGetTimerMapFtraceEvent(
    ::_pbi::ConstantInitialized)
  : direct_ptimer_(0)
  , direct_vtimer_(0)
  , vcpu_id_(uint64_t{0u})
  , emul_ptimer_(0){}
struct KvmGetTimerMapFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmGetTimerMapFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmGetTimerMapFtraceEventDefaultTypeInternal() {}
  union {
    KvmGetTimerMapFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmGetTimerMapFtraceEventDefaultTypeInternal _KvmGetTimerMapFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmGuestFaultFtraceEvent::KvmGuestFaultFtraceEvent(
    ::_pbi::ConstantInitialized)
  : hsr_(uint64_t{0u})
  , hxfar_(uint64_t{0u})
  , ipa_(uint64_t{0u})
  , vcpu_pc_(uint64_t{0u}){}
struct KvmGuestFaultFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmGuestFaultFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmGuestFaultFtraceEventDefaultTypeInternal() {}
  union {
    KvmGuestFaultFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmGuestFaultFtraceEventDefaultTypeInternal _KvmGuestFaultFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmHandleSysRegFtraceEvent::KvmHandleSysRegFtraceEvent(
    ::_pbi::ConstantInitialized)
  : hsr_(uint64_t{0u}){}
struct KvmHandleSysRegFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmHandleSysRegFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmHandleSysRegFtraceEventDefaultTypeInternal() {}
  union {
    KvmHandleSysRegFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmHandleSysRegFtraceEventDefaultTypeInternal _KvmHandleSysRegFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmHvcArm64FtraceEvent::KvmHvcArm64FtraceEvent(
    ::_pbi::ConstantInitialized)
  : imm_(uint64_t{0u})
  , r0_(uint64_t{0u})
  , vcpu_pc_(uint64_t{0u}){}
struct KvmHvcArm64FtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmHvcArm64FtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmHvcArm64FtraceEventDefaultTypeInternal() {}
  union {
    KvmHvcArm64FtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmHvcArm64FtraceEventDefaultTypeInternal _KvmHvcArm64FtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmIrqLineFtraceEvent::KvmIrqLineFtraceEvent(
    ::_pbi::ConstantInitialized)
  : irq_num_(0)
  , level_(0)
  , type_(0u)
  , vcpu_idx_(0){}
struct KvmIrqLineFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmIrqLineFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmIrqLineFtraceEventDefaultTypeInternal() {}
  union {
    KvmIrqLineFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmIrqLineFtraceEventDefaultTypeInternal _KvmIrqLineFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmMmioFtraceEvent::KvmMmioFtraceEvent(
    ::_pbi::ConstantInitialized)
  : gpa_(uint64_t{0u})
  , len_(0u)
  , type_(0u)
  , val_(uint64_t{0u}){}
struct KvmMmioFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmMmioFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmMmioFtraceEventDefaultTypeInternal() {}
  union {
    KvmMmioFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmMmioFtraceEventDefaultTypeInternal _KvmMmioFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmMmioEmulateFtraceEvent::KvmMmioEmulateFtraceEvent(
    ::_pbi::ConstantInitialized)
  : cpsr_(uint64_t{0u})
  , instr_(uint64_t{0u})
  , vcpu_pc_(uint64_t{0u}){}
struct KvmMmioEmulateFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmMmioEmulateFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmMmioEmulateFtraceEventDefaultTypeInternal() {}
  union {
    KvmMmioEmulateFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmMmioEmulateFtraceEventDefaultTypeInternal _KvmMmioEmulateFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmSetGuestDebugFtraceEvent::KvmSetGuestDebugFtraceEvent(
    ::_pbi::ConstantInitialized)
  : vcpu_(uint64_t{0u})
  , guest_debug_(0u){}
struct KvmSetGuestDebugFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmSetGuestDebugFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmSetGuestDebugFtraceEventDefaultTypeInternal() {}
  union {
    KvmSetGuestDebugFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmSetGuestDebugFtraceEventDefaultTypeInternal _KvmSetGuestDebugFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmSetIrqFtraceEvent::KvmSetIrqFtraceEvent(
    ::_pbi::ConstantInitialized)
  : gsi_(0u)
  , irq_source_id_(0)
  , level_(0){}
struct KvmSetIrqFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmSetIrqFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmSetIrqFtraceEventDefaultTypeInternal() {}
  union {
    KvmSetIrqFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmSetIrqFtraceEventDefaultTypeInternal _KvmSetIrqFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmSetSpteHvaFtraceEvent::KvmSetSpteHvaFtraceEvent(
    ::_pbi::ConstantInitialized)
  : hva_(uint64_t{0u}){}
struct KvmSetSpteHvaFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmSetSpteHvaFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmSetSpteHvaFtraceEventDefaultTypeInternal() {}
  union {
    KvmSetSpteHvaFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmSetSpteHvaFtraceEventDefaultTypeInternal _KvmSetSpteHvaFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmSetWayFlushFtraceEvent::KvmSetWayFlushFtraceEvent(
    ::_pbi::ConstantInitialized)
  : vcpu_pc_(uint64_t{0u})
  , cache_(0u){}
struct KvmSetWayFlushFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmSetWayFlushFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmSetWayFlushFtraceEventDefaultTypeInternal() {}
  union {
    KvmSetWayFlushFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmSetWayFlushFtraceEventDefaultTypeInternal _KvmSetWayFlushFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmSysAccessFtraceEvent::KvmSysAccessFtraceEvent(
    ::_pbi::ConstantInitialized)
  : name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , crm_(0u)
  , crn_(0u)
  , op0_(0u)
  , op1_(0u)
  , op2_(0u)
  , is_write_(0u)
  , vcpu_pc_(uint64_t{0u}){}
struct KvmSysAccessFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmSysAccessFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmSysAccessFtraceEventDefaultTypeInternal() {}
  union {
    KvmSysAccessFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmSysAccessFtraceEventDefaultTypeInternal _KvmSysAccessFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmTestAgeHvaFtraceEvent::KvmTestAgeHvaFtraceEvent(
    ::_pbi::ConstantInitialized)
  : hva_(uint64_t{0u}){}
struct KvmTestAgeHvaFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmTestAgeHvaFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmTestAgeHvaFtraceEventDefaultTypeInternal() {}
  union {
    KvmTestAgeHvaFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmTestAgeHvaFtraceEventDefaultTypeInternal _KvmTestAgeHvaFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmTimerEmulateFtraceEvent::KvmTimerEmulateFtraceEvent(
    ::_pbi::ConstantInitialized)
  : should_fire_(0u)
  , timer_idx_(0){}
struct KvmTimerEmulateFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmTimerEmulateFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmTimerEmulateFtraceEventDefaultTypeInternal() {}
  union {
    KvmTimerEmulateFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmTimerEmulateFtraceEventDefaultTypeInternal _KvmTimerEmulateFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmTimerHrtimerExpireFtraceEvent::KvmTimerHrtimerExpireFtraceEvent(
    ::_pbi::ConstantInitialized)
  : timer_idx_(0){}
struct KvmTimerHrtimerExpireFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmTimerHrtimerExpireFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmTimerHrtimerExpireFtraceEventDefaultTypeInternal() {}
  union {
    KvmTimerHrtimerExpireFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmTimerHrtimerExpireFtraceEventDefaultTypeInternal _KvmTimerHrtimerExpireFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmTimerRestoreStateFtraceEvent::KvmTimerRestoreStateFtraceEvent(
    ::_pbi::ConstantInitialized)
  : ctl_(uint64_t{0u})
  , cval_(uint64_t{0u})
  , timer_idx_(0){}
struct KvmTimerRestoreStateFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmTimerRestoreStateFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmTimerRestoreStateFtraceEventDefaultTypeInternal() {}
  union {
    KvmTimerRestoreStateFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmTimerRestoreStateFtraceEventDefaultTypeInternal _KvmTimerRestoreStateFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmTimerSaveStateFtraceEvent::KvmTimerSaveStateFtraceEvent(
    ::_pbi::ConstantInitialized)
  : ctl_(uint64_t{0u})
  , cval_(uint64_t{0u})
  , timer_idx_(0){}
struct KvmTimerSaveStateFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmTimerSaveStateFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmTimerSaveStateFtraceEventDefaultTypeInternal() {}
  union {
    KvmTimerSaveStateFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmTimerSaveStateFtraceEventDefaultTypeInternal _KvmTimerSaveStateFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmTimerUpdateIrqFtraceEvent::KvmTimerUpdateIrqFtraceEvent(
    ::_pbi::ConstantInitialized)
  : irq_(0u)
  , level_(0)
  , vcpu_id_(uint64_t{0u}){}
struct KvmTimerUpdateIrqFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmTimerUpdateIrqFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmTimerUpdateIrqFtraceEventDefaultTypeInternal() {}
  union {
    KvmTimerUpdateIrqFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmTimerUpdateIrqFtraceEventDefaultTypeInternal _KvmTimerUpdateIrqFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmToggleCacheFtraceEvent::KvmToggleCacheFtraceEvent(
    ::_pbi::ConstantInitialized)
  : vcpu_pc_(uint64_t{0u})
  , now_(0u)
  , was_(0u){}
struct KvmToggleCacheFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmToggleCacheFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmToggleCacheFtraceEventDefaultTypeInternal() {}
  union {
    KvmToggleCacheFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmToggleCacheFtraceEventDefaultTypeInternal _KvmToggleCacheFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmUnmapHvaRangeFtraceEvent::KvmUnmapHvaRangeFtraceEvent(
    ::_pbi::ConstantInitialized)
  : end_(uint64_t{0u})
  , start_(uint64_t{0u}){}
struct KvmUnmapHvaRangeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmUnmapHvaRangeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmUnmapHvaRangeFtraceEventDefaultTypeInternal() {}
  union {
    KvmUnmapHvaRangeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmUnmapHvaRangeFtraceEventDefaultTypeInternal _KvmUnmapHvaRangeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmUserspaceExitFtraceEvent::KvmUserspaceExitFtraceEvent(
    ::_pbi::ConstantInitialized)
  : reason_(0u){}
struct KvmUserspaceExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmUserspaceExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmUserspaceExitFtraceEventDefaultTypeInternal() {}
  union {
    KvmUserspaceExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmUserspaceExitFtraceEventDefaultTypeInternal _KvmUserspaceExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmVcpuWakeupFtraceEvent::KvmVcpuWakeupFtraceEvent(
    ::_pbi::ConstantInitialized)
  : ns_(uint64_t{0u})
  , valid_(0u)
  , waited_(0u){}
struct KvmVcpuWakeupFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmVcpuWakeupFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmVcpuWakeupFtraceEventDefaultTypeInternal() {}
  union {
    KvmVcpuWakeupFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmVcpuWakeupFtraceEventDefaultTypeInternal _KvmVcpuWakeupFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmWfxArm64FtraceEvent::KvmWfxArm64FtraceEvent(
    ::_pbi::ConstantInitialized)
  : vcpu_pc_(uint64_t{0u})
  , is_wfe_(0u){}
struct KvmWfxArm64FtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmWfxArm64FtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmWfxArm64FtraceEventDefaultTypeInternal() {}
  union {
    KvmWfxArm64FtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmWfxArm64FtraceEventDefaultTypeInternal _KvmWfxArm64FtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR TrapRegFtraceEvent::TrapRegFtraceEvent(
    ::_pbi::ConstantInitialized)
  : fn_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , is_write_(0u)
  , reg_(0)
  , write_value_(uint64_t{0u}){}
struct TrapRegFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrapRegFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrapRegFtraceEventDefaultTypeInternal() {}
  union {
    TrapRegFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrapRegFtraceEventDefaultTypeInternal _TrapRegFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR VgicUpdateIrqPendingFtraceEvent::VgicUpdateIrqPendingFtraceEvent(
    ::_pbi::ConstantInitialized)
  : irq_(0u)
  , level_(0u)
  , vcpu_id_(uint64_t{0u}){}
struct VgicUpdateIrqPendingFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VgicUpdateIrqPendingFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VgicUpdateIrqPendingFtraceEventDefaultTypeInternal() {}
  union {
    VgicUpdateIrqPendingFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VgicUpdateIrqPendingFtraceEventDefaultTypeInternal _VgicUpdateIrqPendingFtraceEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
namespace perfetto {
namespace protos {

// ===================================================================

class KvmAccessFaultFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmAccessFaultFtraceEvent>()._has_bits_);
  static void set_has_ipa(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmAccessFaultFtraceEvent::KvmAccessFaultFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmAccessFaultFtraceEvent)
}
KvmAccessFaultFtraceEvent::KvmAccessFaultFtraceEvent(const KvmAccessFaultFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ipa_ = from.ipa_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmAccessFaultFtraceEvent)
}

inline void KvmAccessFaultFtraceEvent::SharedCtor() {
ipa_ = uint64_t{0u};
}

KvmAccessFaultFtraceEvent::~KvmAccessFaultFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmAccessFaultFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmAccessFaultFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmAccessFaultFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmAccessFaultFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmAccessFaultFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ipa_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmAccessFaultFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 ipa = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ipa(&has_bits);
          ipa_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmAccessFaultFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmAccessFaultFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 ipa = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_ipa(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmAccessFaultFtraceEvent)
  return target;
}

size_t KvmAccessFaultFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmAccessFaultFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 ipa = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ipa());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmAccessFaultFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmAccessFaultFtraceEvent*>(
      &from));
}

void KvmAccessFaultFtraceEvent::MergeFrom(const KvmAccessFaultFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmAccessFaultFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_ipa()) {
    _internal_set_ipa(from._internal_ipa());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmAccessFaultFtraceEvent::CopyFrom(const KvmAccessFaultFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmAccessFaultFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmAccessFaultFtraceEvent::IsInitialized() const {
  return true;
}

void KvmAccessFaultFtraceEvent::InternalSwap(KvmAccessFaultFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(ipa_, other->ipa_);
}

std::string KvmAccessFaultFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmAccessFaultFtraceEvent";
}


// ===================================================================

class KvmAckIrqFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmAckIrqFtraceEvent>()._has_bits_);
  static void set_has_irqchip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pin(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KvmAckIrqFtraceEvent::KvmAckIrqFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmAckIrqFtraceEvent)
}
KvmAckIrqFtraceEvent::KvmAckIrqFtraceEvent(const KvmAckIrqFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&irqchip_, &from.irqchip_,
    static_cast<size_t>(reinterpret_cast<char*>(&pin_) -
    reinterpret_cast<char*>(&irqchip_)) + sizeof(pin_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmAckIrqFtraceEvent)
}

inline void KvmAckIrqFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&irqchip_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&pin_) -
    reinterpret_cast<char*>(&irqchip_)) + sizeof(pin_));
}

KvmAckIrqFtraceEvent::~KvmAckIrqFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmAckIrqFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmAckIrqFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmAckIrqFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmAckIrqFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmAckIrqFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&irqchip_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pin_) -
        reinterpret_cast<char*>(&irqchip_)) + sizeof(pin_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmAckIrqFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 irqchip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_irqchip(&has_bits);
          irqchip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pin = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pin(&has_bits);
          pin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmAckIrqFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmAckIrqFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 irqchip = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_irqchip(), target);
  }

  // optional uint32 pin = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_pin(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmAckIrqFtraceEvent)
  return target;
}

size_t KvmAckIrqFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmAckIrqFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 irqchip = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_irqchip());
    }

    // optional uint32 pin = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pin());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmAckIrqFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmAckIrqFtraceEvent*>(
      &from));
}

void KvmAckIrqFtraceEvent::MergeFrom(const KvmAckIrqFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmAckIrqFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      irqchip_ = from.irqchip_;
    }
    if (cached_has_bits & 0x00000002u) {
      pin_ = from.pin_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmAckIrqFtraceEvent::CopyFrom(const KvmAckIrqFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmAckIrqFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmAckIrqFtraceEvent::IsInitialized() const {
  return true;
}

void KvmAckIrqFtraceEvent::InternalSwap(KvmAckIrqFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmAckIrqFtraceEvent, pin_)
      + sizeof(KvmAckIrqFtraceEvent::pin_)
      - PROTOBUF_FIELD_OFFSET(KvmAckIrqFtraceEvent, irqchip_)>(
          reinterpret_cast<char*>(&irqchip_),
          reinterpret_cast<char*>(&other->irqchip_));
}

std::string KvmAckIrqFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmAckIrqFtraceEvent";
}


// ===================================================================

class KvmAgeHvaFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmAgeHvaFtraceEvent>()._has_bits_);
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KvmAgeHvaFtraceEvent::KvmAgeHvaFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmAgeHvaFtraceEvent)
}
KvmAgeHvaFtraceEvent::KvmAgeHvaFtraceEvent(const KvmAgeHvaFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&end_, &from.end_,
    static_cast<size_t>(reinterpret_cast<char*>(&start_) -
    reinterpret_cast<char*>(&end_)) + sizeof(start_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmAgeHvaFtraceEvent)
}

inline void KvmAgeHvaFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&end_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&start_) -
    reinterpret_cast<char*>(&end_)) + sizeof(start_));
}

KvmAgeHvaFtraceEvent::~KvmAgeHvaFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmAgeHvaFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmAgeHvaFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmAgeHvaFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmAgeHvaFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmAgeHvaFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&end_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&start_) -
        reinterpret_cast<char*>(&end_)) + sizeof(start_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmAgeHvaFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 end = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_end(&has_bits);
          end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_start(&has_bits);
          start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmAgeHvaFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmAgeHvaFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 end = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_end(), target);
  }

  // optional uint64 start = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_start(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmAgeHvaFtraceEvent)
  return target;
}

size_t KvmAgeHvaFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmAgeHvaFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 end = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_end());
    }

    // optional uint64 start = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_start());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmAgeHvaFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmAgeHvaFtraceEvent*>(
      &from));
}

void KvmAgeHvaFtraceEvent::MergeFrom(const KvmAgeHvaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmAgeHvaFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      end_ = from.end_;
    }
    if (cached_has_bits & 0x00000002u) {
      start_ = from.start_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmAgeHvaFtraceEvent::CopyFrom(const KvmAgeHvaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmAgeHvaFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmAgeHvaFtraceEvent::IsInitialized() const {
  return true;
}

void KvmAgeHvaFtraceEvent::InternalSwap(KvmAgeHvaFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmAgeHvaFtraceEvent, start_)
      + sizeof(KvmAgeHvaFtraceEvent::start_)
      - PROTOBUF_FIELD_OFFSET(KvmAgeHvaFtraceEvent, end_)>(
          reinterpret_cast<char*>(&end_),
          reinterpret_cast<char*>(&other->end_));
}

std::string KvmAgeHvaFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmAgeHvaFtraceEvent";
}


// ===================================================================

class KvmAgePageFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmAgePageFtraceEvent>()._has_bits_);
  static void set_has_gfn(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hva(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_referenced(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

KvmAgePageFtraceEvent::KvmAgePageFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmAgePageFtraceEvent)
}
KvmAgePageFtraceEvent::KvmAgePageFtraceEvent(const KvmAgePageFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gfn_, &from.gfn_,
    static_cast<size_t>(reinterpret_cast<char*>(&referenced_) -
    reinterpret_cast<char*>(&gfn_)) + sizeof(referenced_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmAgePageFtraceEvent)
}

inline void KvmAgePageFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gfn_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&referenced_) -
    reinterpret_cast<char*>(&gfn_)) + sizeof(referenced_));
}

KvmAgePageFtraceEvent::~KvmAgePageFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmAgePageFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmAgePageFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmAgePageFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmAgePageFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmAgePageFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&gfn_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&referenced_) -
        reinterpret_cast<char*>(&gfn_)) + sizeof(referenced_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmAgePageFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 gfn = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gfn(&has_bits);
          gfn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 hva = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_hva(&has_bits);
          hva_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 level = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_level(&has_bits);
          level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 referenced = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_referenced(&has_bits);
          referenced_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmAgePageFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmAgePageFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 gfn = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_gfn(), target);
  }

  // optional uint64 hva = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_hva(), target);
  }

  // optional uint32 level = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_level(), target);
  }

  // optional uint32 referenced = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_referenced(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmAgePageFtraceEvent)
  return target;
}

size_t KvmAgePageFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmAgePageFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 gfn = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_gfn());
    }

    // optional uint64 hva = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_hva());
    }

    // optional uint32 level = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_level());
    }

    // optional uint32 referenced = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_referenced());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmAgePageFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmAgePageFtraceEvent*>(
      &from));
}

void KvmAgePageFtraceEvent::MergeFrom(const KvmAgePageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmAgePageFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      gfn_ = from.gfn_;
    }
    if (cached_has_bits & 0x00000002u) {
      hva_ = from.hva_;
    }
    if (cached_has_bits & 0x00000004u) {
      level_ = from.level_;
    }
    if (cached_has_bits & 0x00000008u) {
      referenced_ = from.referenced_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmAgePageFtraceEvent::CopyFrom(const KvmAgePageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmAgePageFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmAgePageFtraceEvent::IsInitialized() const {
  return true;
}

void KvmAgePageFtraceEvent::InternalSwap(KvmAgePageFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmAgePageFtraceEvent, referenced_)
      + sizeof(KvmAgePageFtraceEvent::referenced_)
      - PROTOBUF_FIELD_OFFSET(KvmAgePageFtraceEvent, gfn_)>(
          reinterpret_cast<char*>(&gfn_),
          reinterpret_cast<char*>(&other->gfn_));
}

std::string KvmAgePageFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmAgePageFtraceEvent";
}


// ===================================================================

class KvmArmClearDebugFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmArmClearDebugFtraceEvent>()._has_bits_);
  static void set_has_guest_debug(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmArmClearDebugFtraceEvent::KvmArmClearDebugFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmArmClearDebugFtraceEvent)
}
KvmArmClearDebugFtraceEvent::KvmArmClearDebugFtraceEvent(const KvmArmClearDebugFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  guest_debug_ = from.guest_debug_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmArmClearDebugFtraceEvent)
}

inline void KvmArmClearDebugFtraceEvent::SharedCtor() {
guest_debug_ = 0u;
}

KvmArmClearDebugFtraceEvent::~KvmArmClearDebugFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmArmClearDebugFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmArmClearDebugFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmArmClearDebugFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmArmClearDebugFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmArmClearDebugFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  guest_debug_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmArmClearDebugFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 guest_debug = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_guest_debug(&has_bits);
          guest_debug_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmArmClearDebugFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmArmClearDebugFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 guest_debug = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_guest_debug(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmArmClearDebugFtraceEvent)
  return target;
}

size_t KvmArmClearDebugFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmArmClearDebugFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 guest_debug = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_guest_debug());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmArmClearDebugFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmArmClearDebugFtraceEvent*>(
      &from));
}

void KvmArmClearDebugFtraceEvent::MergeFrom(const KvmArmClearDebugFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmArmClearDebugFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_guest_debug()) {
    _internal_set_guest_debug(from._internal_guest_debug());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmArmClearDebugFtraceEvent::CopyFrom(const KvmArmClearDebugFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmArmClearDebugFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmArmClearDebugFtraceEvent::IsInitialized() const {
  return true;
}

void KvmArmClearDebugFtraceEvent::InternalSwap(KvmArmClearDebugFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(guest_debug_, other->guest_debug_);
}

std::string KvmArmClearDebugFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmArmClearDebugFtraceEvent";
}


// ===================================================================

class KvmArmSetDreg32FtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmArmSetDreg32FtraceEvent>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KvmArmSetDreg32FtraceEvent::KvmArmSetDreg32FtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmArmSetDreg32FtraceEvent)
}
KvmArmSetDreg32FtraceEvent::KvmArmSetDreg32FtraceEvent(const KvmArmSetDreg32FtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  value_ = from.value_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmArmSetDreg32FtraceEvent)
}

inline void KvmArmSetDreg32FtraceEvent::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
value_ = 0u;
}

KvmArmSetDreg32FtraceEvent::~KvmArmSetDreg32FtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmArmSetDreg32FtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmArmSetDreg32FtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
}

void KvmArmSetDreg32FtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmArmSetDreg32FtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmArmSetDreg32FtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  value_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmArmSetDreg32FtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_value(&has_bits);
          value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmArmSetDreg32FtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmArmSetDreg32FtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional uint32 value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmArmSetDreg32FtraceEvent)
  return target;
}

size_t KvmArmSetDreg32FtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmArmSetDreg32FtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmArmSetDreg32FtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmArmSetDreg32FtraceEvent*>(
      &from));
}

void KvmArmSetDreg32FtraceEvent::MergeFrom(const KvmArmSetDreg32FtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmArmSetDreg32FtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      value_ = from.value_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmArmSetDreg32FtraceEvent::CopyFrom(const KvmArmSetDreg32FtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmArmSetDreg32FtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmArmSetDreg32FtraceEvent::IsInitialized() const {
  return true;
}

void KvmArmSetDreg32FtraceEvent::InternalSwap(KvmArmSetDreg32FtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  swap(value_, other->value_);
}

std::string KvmArmSetDreg32FtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmArmSetDreg32FtraceEvent";
}


// ===================================================================

class KvmArmSetRegsetFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmArmSetRegsetFtraceEvent>()._has_bits_);
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmArmSetRegsetFtraceEvent::KvmArmSetRegsetFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmArmSetRegsetFtraceEvent)
}
KvmArmSetRegsetFtraceEvent::KvmArmSetRegsetFtraceEvent(const KvmArmSetRegsetFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  len_ = from.len_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmArmSetRegsetFtraceEvent)
}

inline void KvmArmSetRegsetFtraceEvent::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
len_ = 0;
}

KvmArmSetRegsetFtraceEvent::~KvmArmSetRegsetFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmArmSetRegsetFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmArmSetRegsetFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
}

void KvmArmSetRegsetFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmArmSetRegsetFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmArmSetRegsetFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  len_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmArmSetRegsetFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 len = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmArmSetRegsetFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmArmSetRegsetFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 len = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_len(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmArmSetRegsetFtraceEvent)
  return target;
}

size_t KvmArmSetRegsetFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmArmSetRegsetFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional int32 len = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmArmSetRegsetFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmArmSetRegsetFtraceEvent*>(
      &from));
}

void KvmArmSetRegsetFtraceEvent::MergeFrom(const KvmArmSetRegsetFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmArmSetRegsetFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmArmSetRegsetFtraceEvent::CopyFrom(const KvmArmSetRegsetFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmArmSetRegsetFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmArmSetRegsetFtraceEvent::IsInitialized() const {
  return true;
}

void KvmArmSetRegsetFtraceEvent::InternalSwap(KvmArmSetRegsetFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  swap(len_, other->len_);
}

std::string KvmArmSetRegsetFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmArmSetRegsetFtraceEvent";
}


// ===================================================================

class KvmArmSetupDebugFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmArmSetupDebugFtraceEvent>()._has_bits_);
  static void set_has_guest_debug(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmArmSetupDebugFtraceEvent::KvmArmSetupDebugFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmArmSetupDebugFtraceEvent)
}
KvmArmSetupDebugFtraceEvent::KvmArmSetupDebugFtraceEvent(const KvmArmSetupDebugFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&vcpu_, &from.vcpu_,
    static_cast<size_t>(reinterpret_cast<char*>(&guest_debug_) -
    reinterpret_cast<char*>(&vcpu_)) + sizeof(guest_debug_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmArmSetupDebugFtraceEvent)
}

inline void KvmArmSetupDebugFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&vcpu_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&guest_debug_) -
    reinterpret_cast<char*>(&vcpu_)) + sizeof(guest_debug_));
}

KvmArmSetupDebugFtraceEvent::~KvmArmSetupDebugFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmArmSetupDebugFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmArmSetupDebugFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmArmSetupDebugFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmArmSetupDebugFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmArmSetupDebugFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&vcpu_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&guest_debug_) -
        reinterpret_cast<char*>(&vcpu_)) + sizeof(guest_debug_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmArmSetupDebugFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 guest_debug = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_guest_debug(&has_bits);
          guest_debug_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_vcpu(&has_bits);
          vcpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmArmSetupDebugFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmArmSetupDebugFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 guest_debug = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_guest_debug(), target);
  }

  // optional uint64 vcpu = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_vcpu(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmArmSetupDebugFtraceEvent)
  return target;
}

size_t KvmArmSetupDebugFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmArmSetupDebugFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 vcpu = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu());
    }

    // optional uint32 guest_debug = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_guest_debug());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmArmSetupDebugFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmArmSetupDebugFtraceEvent*>(
      &from));
}

void KvmArmSetupDebugFtraceEvent::MergeFrom(const KvmArmSetupDebugFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmArmSetupDebugFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      vcpu_ = from.vcpu_;
    }
    if (cached_has_bits & 0x00000002u) {
      guest_debug_ = from.guest_debug_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmArmSetupDebugFtraceEvent::CopyFrom(const KvmArmSetupDebugFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmArmSetupDebugFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmArmSetupDebugFtraceEvent::IsInitialized() const {
  return true;
}

void KvmArmSetupDebugFtraceEvent::InternalSwap(KvmArmSetupDebugFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmArmSetupDebugFtraceEvent, guest_debug_)
      + sizeof(KvmArmSetupDebugFtraceEvent::guest_debug_)
      - PROTOBUF_FIELD_OFFSET(KvmArmSetupDebugFtraceEvent, vcpu_)>(
          reinterpret_cast<char*>(&vcpu_),
          reinterpret_cast<char*>(&other->vcpu_));
}

std::string KvmArmSetupDebugFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmArmSetupDebugFtraceEvent";
}


// ===================================================================

class KvmEntryFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmEntryFtraceEvent>()._has_bits_);
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmEntryFtraceEvent::KvmEntryFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmEntryFtraceEvent)
}
KvmEntryFtraceEvent::KvmEntryFtraceEvent(const KvmEntryFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  vcpu_pc_ = from.vcpu_pc_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmEntryFtraceEvent)
}

inline void KvmEntryFtraceEvent::SharedCtor() {
vcpu_pc_ = uint64_t{0u};
}

KvmEntryFtraceEvent::~KvmEntryFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmEntryFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmEntryFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmEntryFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmEntryFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmEntryFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vcpu_pc_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmEntryFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 vcpu_pc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmEntryFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmEntryFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 vcpu_pc = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmEntryFtraceEvent)
  return target;
}

size_t KvmEntryFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmEntryFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 vcpu_pc = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_pc());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmEntryFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmEntryFtraceEvent*>(
      &from));
}

void KvmEntryFtraceEvent::MergeFrom(const KvmEntryFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmEntryFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_vcpu_pc()) {
    _internal_set_vcpu_pc(from._internal_vcpu_pc());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmEntryFtraceEvent::CopyFrom(const KvmEntryFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmEntryFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmEntryFtraceEvent::IsInitialized() const {
  return true;
}

void KvmEntryFtraceEvent::InternalSwap(KvmEntryFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(vcpu_pc_, other->vcpu_pc_);
}

std::string KvmEntryFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmEntryFtraceEvent";
}


// ===================================================================

class KvmExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmExitFtraceEvent>()._has_bits_);
  static void set_has_esr_ec(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmExitFtraceEvent::KvmExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmExitFtraceEvent)
}
KvmExitFtraceEvent::KvmExitFtraceEvent(const KvmExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&esr_ec_, &from.esr_ec_,
    static_cast<size_t>(reinterpret_cast<char*>(&vcpu_pc_) -
    reinterpret_cast<char*>(&esr_ec_)) + sizeof(vcpu_pc_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmExitFtraceEvent)
}

inline void KvmExitFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&esr_ec_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&vcpu_pc_) -
    reinterpret_cast<char*>(&esr_ec_)) + sizeof(vcpu_pc_));
}

KvmExitFtraceEvent::~KvmExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&esr_ec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&vcpu_pc_) -
        reinterpret_cast<char*>(&esr_ec_)) + sizeof(vcpu_pc_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 esr_ec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_esr_ec(&has_bits);
          esr_ec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu_pc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 esr_ec = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_esr_ec(), target);
  }

  // optional int32 ret = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_ret(), target);
  }

  // optional uint64 vcpu_pc = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmExitFtraceEvent)
  return target;
}

size_t KvmExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 esr_ec = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_esr_ec());
    }

    // optional int32 ret = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

    // optional uint64 vcpu_pc = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_pc());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmExitFtraceEvent*>(
      &from));
}

void KvmExitFtraceEvent::MergeFrom(const KvmExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      esr_ec_ = from.esr_ec_;
    }
    if (cached_has_bits & 0x00000002u) {
      ret_ = from.ret_;
    }
    if (cached_has_bits & 0x00000004u) {
      vcpu_pc_ = from.vcpu_pc_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmExitFtraceEvent::CopyFrom(const KvmExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmExitFtraceEvent::IsInitialized() const {
  return true;
}

void KvmExitFtraceEvent::InternalSwap(KvmExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmExitFtraceEvent, vcpu_pc_)
      + sizeof(KvmExitFtraceEvent::vcpu_pc_)
      - PROTOBUF_FIELD_OFFSET(KvmExitFtraceEvent, esr_ec_)>(
          reinterpret_cast<char*>(&esr_ec_),
          reinterpret_cast<char*>(&other->esr_ec_));
}

std::string KvmExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmExitFtraceEvent";
}


// ===================================================================

class KvmFpuFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmFpuFtraceEvent>()._has_bits_);
  static void set_has_load(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmFpuFtraceEvent::KvmFpuFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmFpuFtraceEvent)
}
KvmFpuFtraceEvent::KvmFpuFtraceEvent(const KvmFpuFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  load_ = from.load_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmFpuFtraceEvent)
}

inline void KvmFpuFtraceEvent::SharedCtor() {
load_ = 0u;
}

KvmFpuFtraceEvent::~KvmFpuFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmFpuFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmFpuFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmFpuFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmFpuFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmFpuFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  load_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmFpuFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 load = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_load(&has_bits);
          load_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmFpuFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmFpuFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 load = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_load(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmFpuFtraceEvent)
  return target;
}

size_t KvmFpuFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmFpuFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 load = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_load());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmFpuFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmFpuFtraceEvent*>(
      &from));
}

void KvmFpuFtraceEvent::MergeFrom(const KvmFpuFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmFpuFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_load()) {
    _internal_set_load(from._internal_load());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmFpuFtraceEvent::CopyFrom(const KvmFpuFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmFpuFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmFpuFtraceEvent::IsInitialized() const {
  return true;
}

void KvmFpuFtraceEvent::InternalSwap(KvmFpuFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(load_, other->load_);
}

std::string KvmFpuFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmFpuFtraceEvent";
}


// ===================================================================

class KvmGetTimerMapFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmGetTimerMapFtraceEvent>()._has_bits_);
  static void set_has_direct_ptimer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_direct_vtimer(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_emul_ptimer(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_vcpu_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmGetTimerMapFtraceEvent::KvmGetTimerMapFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmGetTimerMapFtraceEvent)
}
KvmGetTimerMapFtraceEvent::KvmGetTimerMapFtraceEvent(const KvmGetTimerMapFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&direct_ptimer_, &from.direct_ptimer_,
    static_cast<size_t>(reinterpret_cast<char*>(&emul_ptimer_) -
    reinterpret_cast<char*>(&direct_ptimer_)) + sizeof(emul_ptimer_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmGetTimerMapFtraceEvent)
}

inline void KvmGetTimerMapFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&direct_ptimer_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&emul_ptimer_) -
    reinterpret_cast<char*>(&direct_ptimer_)) + sizeof(emul_ptimer_));
}

KvmGetTimerMapFtraceEvent::~KvmGetTimerMapFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmGetTimerMapFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmGetTimerMapFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmGetTimerMapFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmGetTimerMapFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmGetTimerMapFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&direct_ptimer_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&emul_ptimer_) -
        reinterpret_cast<char*>(&direct_ptimer_)) + sizeof(emul_ptimer_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmGetTimerMapFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 direct_ptimer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_direct_ptimer(&has_bits);
          direct_ptimer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 direct_vtimer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_direct_vtimer(&has_bits);
          direct_vtimer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 emul_ptimer = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_emul_ptimer(&has_bits);
          emul_ptimer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_vcpu_id(&has_bits);
          vcpu_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmGetTimerMapFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmGetTimerMapFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 direct_ptimer = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_direct_ptimer(), target);
  }

  // optional int32 direct_vtimer = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_direct_vtimer(), target);
  }

  // optional int32 emul_ptimer = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_emul_ptimer(), target);
  }

  // optional uint64 vcpu_id = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_vcpu_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmGetTimerMapFtraceEvent)
  return target;
}

size_t KvmGetTimerMapFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmGetTimerMapFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 direct_ptimer = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_direct_ptimer());
    }

    // optional int32 direct_vtimer = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_direct_vtimer());
    }

    // optional uint64 vcpu_id = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_id());
    }

    // optional int32 emul_ptimer = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_emul_ptimer());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmGetTimerMapFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmGetTimerMapFtraceEvent*>(
      &from));
}

void KvmGetTimerMapFtraceEvent::MergeFrom(const KvmGetTimerMapFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmGetTimerMapFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      direct_ptimer_ = from.direct_ptimer_;
    }
    if (cached_has_bits & 0x00000002u) {
      direct_vtimer_ = from.direct_vtimer_;
    }
    if (cached_has_bits & 0x00000004u) {
      vcpu_id_ = from.vcpu_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      emul_ptimer_ = from.emul_ptimer_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmGetTimerMapFtraceEvent::CopyFrom(const KvmGetTimerMapFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmGetTimerMapFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmGetTimerMapFtraceEvent::IsInitialized() const {
  return true;
}

void KvmGetTimerMapFtraceEvent::InternalSwap(KvmGetTimerMapFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmGetTimerMapFtraceEvent, emul_ptimer_)
      + sizeof(KvmGetTimerMapFtraceEvent::emul_ptimer_)
      - PROTOBUF_FIELD_OFFSET(KvmGetTimerMapFtraceEvent, direct_ptimer_)>(
          reinterpret_cast<char*>(&direct_ptimer_),
          reinterpret_cast<char*>(&other->direct_ptimer_));
}

std::string KvmGetTimerMapFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmGetTimerMapFtraceEvent";
}


// ===================================================================

class KvmGuestFaultFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmGuestFaultFtraceEvent>()._has_bits_);
  static void set_has_hsr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hxfar(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ipa(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

KvmGuestFaultFtraceEvent::KvmGuestFaultFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmGuestFaultFtraceEvent)
}
KvmGuestFaultFtraceEvent::KvmGuestFaultFtraceEvent(const KvmGuestFaultFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&hsr_, &from.hsr_,
    static_cast<size_t>(reinterpret_cast<char*>(&vcpu_pc_) -
    reinterpret_cast<char*>(&hsr_)) + sizeof(vcpu_pc_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmGuestFaultFtraceEvent)
}

inline void KvmGuestFaultFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&hsr_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&vcpu_pc_) -
    reinterpret_cast<char*>(&hsr_)) + sizeof(vcpu_pc_));
}

KvmGuestFaultFtraceEvent::~KvmGuestFaultFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmGuestFaultFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmGuestFaultFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmGuestFaultFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmGuestFaultFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmGuestFaultFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&hsr_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&vcpu_pc_) -
        reinterpret_cast<char*>(&hsr_)) + sizeof(vcpu_pc_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmGuestFaultFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 hsr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hsr(&has_bits);
          hsr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 hxfar = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_hxfar(&has_bits);
          hxfar_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ipa = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ipa(&has_bits);
          ipa_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu_pc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmGuestFaultFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmGuestFaultFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 hsr = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_hsr(), target);
  }

  // optional uint64 hxfar = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_hxfar(), target);
  }

  // optional uint64 ipa = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_ipa(), target);
  }

  // optional uint64 vcpu_pc = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmGuestFaultFtraceEvent)
  return target;
}

size_t KvmGuestFaultFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmGuestFaultFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 hsr = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_hsr());
    }

    // optional uint64 hxfar = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_hxfar());
    }

    // optional uint64 ipa = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ipa());
    }

    // optional uint64 vcpu_pc = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_pc());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmGuestFaultFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmGuestFaultFtraceEvent*>(
      &from));
}

void KvmGuestFaultFtraceEvent::MergeFrom(const KvmGuestFaultFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmGuestFaultFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      hsr_ = from.hsr_;
    }
    if (cached_has_bits & 0x00000002u) {
      hxfar_ = from.hxfar_;
    }
    if (cached_has_bits & 0x00000004u) {
      ipa_ = from.ipa_;
    }
    if (cached_has_bits & 0x00000008u) {
      vcpu_pc_ = from.vcpu_pc_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmGuestFaultFtraceEvent::CopyFrom(const KvmGuestFaultFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmGuestFaultFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmGuestFaultFtraceEvent::IsInitialized() const {
  return true;
}

void KvmGuestFaultFtraceEvent::InternalSwap(KvmGuestFaultFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmGuestFaultFtraceEvent, vcpu_pc_)
      + sizeof(KvmGuestFaultFtraceEvent::vcpu_pc_)
      - PROTOBUF_FIELD_OFFSET(KvmGuestFaultFtraceEvent, hsr_)>(
          reinterpret_cast<char*>(&hsr_),
          reinterpret_cast<char*>(&other->hsr_));
}

std::string KvmGuestFaultFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmGuestFaultFtraceEvent";
}


// ===================================================================

class KvmHandleSysRegFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmHandleSysRegFtraceEvent>()._has_bits_);
  static void set_has_hsr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmHandleSysRegFtraceEvent::KvmHandleSysRegFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmHandleSysRegFtraceEvent)
}
KvmHandleSysRegFtraceEvent::KvmHandleSysRegFtraceEvent(const KvmHandleSysRegFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  hsr_ = from.hsr_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmHandleSysRegFtraceEvent)
}

inline void KvmHandleSysRegFtraceEvent::SharedCtor() {
hsr_ = uint64_t{0u};
}

KvmHandleSysRegFtraceEvent::~KvmHandleSysRegFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmHandleSysRegFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmHandleSysRegFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmHandleSysRegFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmHandleSysRegFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmHandleSysRegFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  hsr_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmHandleSysRegFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 hsr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hsr(&has_bits);
          hsr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmHandleSysRegFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmHandleSysRegFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 hsr = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_hsr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmHandleSysRegFtraceEvent)
  return target;
}

size_t KvmHandleSysRegFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmHandleSysRegFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 hsr = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_hsr());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmHandleSysRegFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmHandleSysRegFtraceEvent*>(
      &from));
}

void KvmHandleSysRegFtraceEvent::MergeFrom(const KvmHandleSysRegFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmHandleSysRegFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_hsr()) {
    _internal_set_hsr(from._internal_hsr());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmHandleSysRegFtraceEvent::CopyFrom(const KvmHandleSysRegFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmHandleSysRegFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmHandleSysRegFtraceEvent::IsInitialized() const {
  return true;
}

void KvmHandleSysRegFtraceEvent::InternalSwap(KvmHandleSysRegFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(hsr_, other->hsr_);
}

std::string KvmHandleSysRegFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmHandleSysRegFtraceEvent";
}


// ===================================================================

class KvmHvcArm64FtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmHvcArm64FtraceEvent>()._has_bits_);
  static void set_has_imm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_r0(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmHvcArm64FtraceEvent::KvmHvcArm64FtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmHvcArm64FtraceEvent)
}
KvmHvcArm64FtraceEvent::KvmHvcArm64FtraceEvent(const KvmHvcArm64FtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&imm_, &from.imm_,
    static_cast<size_t>(reinterpret_cast<char*>(&vcpu_pc_) -
    reinterpret_cast<char*>(&imm_)) + sizeof(vcpu_pc_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmHvcArm64FtraceEvent)
}

inline void KvmHvcArm64FtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&imm_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&vcpu_pc_) -
    reinterpret_cast<char*>(&imm_)) + sizeof(vcpu_pc_));
}

KvmHvcArm64FtraceEvent::~KvmHvcArm64FtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmHvcArm64FtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmHvcArm64FtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmHvcArm64FtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmHvcArm64FtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmHvcArm64FtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&imm_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&vcpu_pc_) -
        reinterpret_cast<char*>(&imm_)) + sizeof(vcpu_pc_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmHvcArm64FtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 imm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_imm(&has_bits);
          imm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 r0 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_r0(&has_bits);
          r0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu_pc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmHvcArm64FtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmHvcArm64FtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 imm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_imm(), target);
  }

  // optional uint64 r0 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_r0(), target);
  }

  // optional uint64 vcpu_pc = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmHvcArm64FtraceEvent)
  return target;
}

size_t KvmHvcArm64FtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmHvcArm64FtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 imm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_imm());
    }

    // optional uint64 r0 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_r0());
    }

    // optional uint64 vcpu_pc = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_pc());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmHvcArm64FtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmHvcArm64FtraceEvent*>(
      &from));
}

void KvmHvcArm64FtraceEvent::MergeFrom(const KvmHvcArm64FtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmHvcArm64FtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      imm_ = from.imm_;
    }
    if (cached_has_bits & 0x00000002u) {
      r0_ = from.r0_;
    }
    if (cached_has_bits & 0x00000004u) {
      vcpu_pc_ = from.vcpu_pc_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmHvcArm64FtraceEvent::CopyFrom(const KvmHvcArm64FtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmHvcArm64FtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmHvcArm64FtraceEvent::IsInitialized() const {
  return true;
}

void KvmHvcArm64FtraceEvent::InternalSwap(KvmHvcArm64FtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmHvcArm64FtraceEvent, vcpu_pc_)
      + sizeof(KvmHvcArm64FtraceEvent::vcpu_pc_)
      - PROTOBUF_FIELD_OFFSET(KvmHvcArm64FtraceEvent, imm_)>(
          reinterpret_cast<char*>(&imm_),
          reinterpret_cast<char*>(&other->imm_));
}

std::string KvmHvcArm64FtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmHvcArm64FtraceEvent";
}


// ===================================================================

class KvmIrqLineFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmIrqLineFtraceEvent>()._has_bits_);
  static void set_has_irq_num(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_vcpu_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

KvmIrqLineFtraceEvent::KvmIrqLineFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmIrqLineFtraceEvent)
}
KvmIrqLineFtraceEvent::KvmIrqLineFtraceEvent(const KvmIrqLineFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&irq_num_, &from.irq_num_,
    static_cast<size_t>(reinterpret_cast<char*>(&vcpu_idx_) -
    reinterpret_cast<char*>(&irq_num_)) + sizeof(vcpu_idx_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmIrqLineFtraceEvent)
}

inline void KvmIrqLineFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&irq_num_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&vcpu_idx_) -
    reinterpret_cast<char*>(&irq_num_)) + sizeof(vcpu_idx_));
}

KvmIrqLineFtraceEvent::~KvmIrqLineFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmIrqLineFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmIrqLineFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmIrqLineFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmIrqLineFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmIrqLineFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&irq_num_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&vcpu_idx_) -
        reinterpret_cast<char*>(&irq_num_)) + sizeof(vcpu_idx_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmIrqLineFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 irq_num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_irq_num(&has_bits);
          irq_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_level(&has_bits);
          level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 vcpu_idx = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_vcpu_idx(&has_bits);
          vcpu_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmIrqLineFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmIrqLineFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 irq_num = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_irq_num(), target);
  }

  // optional int32 level = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_level(), target);
  }

  // optional uint32 type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_type(), target);
  }

  // optional int32 vcpu_idx = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_vcpu_idx(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmIrqLineFtraceEvent)
  return target;
}

size_t KvmIrqLineFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmIrqLineFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 irq_num = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_irq_num());
    }

    // optional int32 level = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_level());
    }

    // optional uint32 type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
    }

    // optional int32 vcpu_idx = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_vcpu_idx());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmIrqLineFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmIrqLineFtraceEvent*>(
      &from));
}

void KvmIrqLineFtraceEvent::MergeFrom(const KvmIrqLineFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmIrqLineFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      irq_num_ = from.irq_num_;
    }
    if (cached_has_bits & 0x00000002u) {
      level_ = from.level_;
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      vcpu_idx_ = from.vcpu_idx_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmIrqLineFtraceEvent::CopyFrom(const KvmIrqLineFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmIrqLineFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmIrqLineFtraceEvent::IsInitialized() const {
  return true;
}

void KvmIrqLineFtraceEvent::InternalSwap(KvmIrqLineFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmIrqLineFtraceEvent, vcpu_idx_)
      + sizeof(KvmIrqLineFtraceEvent::vcpu_idx_)
      - PROTOBUF_FIELD_OFFSET(KvmIrqLineFtraceEvent, irq_num_)>(
          reinterpret_cast<char*>(&irq_num_),
          reinterpret_cast<char*>(&other->irq_num_));
}

std::string KvmIrqLineFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmIrqLineFtraceEvent";
}


// ===================================================================

class KvmMmioFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmMmioFtraceEvent>()._has_bits_);
  static void set_has_gpa(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_val(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

KvmMmioFtraceEvent::KvmMmioFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmMmioFtraceEvent)
}
KvmMmioFtraceEvent::KvmMmioFtraceEvent(const KvmMmioFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gpa_, &from.gpa_,
    static_cast<size_t>(reinterpret_cast<char*>(&val_) -
    reinterpret_cast<char*>(&gpa_)) + sizeof(val_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmMmioFtraceEvent)
}

inline void KvmMmioFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gpa_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&val_) -
    reinterpret_cast<char*>(&gpa_)) + sizeof(val_));
}

KvmMmioFtraceEvent::~KvmMmioFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmMmioFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmMmioFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmMmioFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmMmioFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmMmioFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&gpa_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&val_) -
        reinterpret_cast<char*>(&gpa_)) + sizeof(val_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmMmioFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 gpa = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gpa(&has_bits);
          gpa_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 val = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_val(&has_bits);
          val_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmMmioFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmMmioFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 gpa = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_gpa(), target);
  }

  // optional uint32 len = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_len(), target);
  }

  // optional uint32 type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_type(), target);
  }

  // optional uint64 val = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_val(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmMmioFtraceEvent)
  return target;
}

size_t KvmMmioFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmMmioFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 gpa = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_gpa());
    }

    // optional uint32 len = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint32 type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
    }

    // optional uint64 val = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_val());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmMmioFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmMmioFtraceEvent*>(
      &from));
}

void KvmMmioFtraceEvent::MergeFrom(const KvmMmioFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmMmioFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      gpa_ = from.gpa_;
    }
    if (cached_has_bits & 0x00000002u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      val_ = from.val_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmMmioFtraceEvent::CopyFrom(const KvmMmioFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmMmioFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmMmioFtraceEvent::IsInitialized() const {
  return true;
}

void KvmMmioFtraceEvent::InternalSwap(KvmMmioFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmMmioFtraceEvent, val_)
      + sizeof(KvmMmioFtraceEvent::val_)
      - PROTOBUF_FIELD_OFFSET(KvmMmioFtraceEvent, gpa_)>(
          reinterpret_cast<char*>(&gpa_),
          reinterpret_cast<char*>(&other->gpa_));
}

std::string KvmMmioFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmMmioFtraceEvent";
}


// ===================================================================

class KvmMmioEmulateFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmMmioEmulateFtraceEvent>()._has_bits_);
  static void set_has_cpsr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_instr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmMmioEmulateFtraceEvent::KvmMmioEmulateFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmMmioEmulateFtraceEvent)
}
KvmMmioEmulateFtraceEvent::KvmMmioEmulateFtraceEvent(const KvmMmioEmulateFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&cpsr_, &from.cpsr_,
    static_cast<size_t>(reinterpret_cast<char*>(&vcpu_pc_) -
    reinterpret_cast<char*>(&cpsr_)) + sizeof(vcpu_pc_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmMmioEmulateFtraceEvent)
}

inline void KvmMmioEmulateFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&cpsr_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&vcpu_pc_) -
    reinterpret_cast<char*>(&cpsr_)) + sizeof(vcpu_pc_));
}

KvmMmioEmulateFtraceEvent::~KvmMmioEmulateFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmMmioEmulateFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmMmioEmulateFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmMmioEmulateFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmMmioEmulateFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmMmioEmulateFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&cpsr_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&vcpu_pc_) -
        reinterpret_cast<char*>(&cpsr_)) + sizeof(vcpu_pc_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmMmioEmulateFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 cpsr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cpsr(&has_bits);
          cpsr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 instr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_instr(&has_bits);
          instr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu_pc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmMmioEmulateFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmMmioEmulateFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 cpsr = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_cpsr(), target);
  }

  // optional uint64 instr = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_instr(), target);
  }

  // optional uint64 vcpu_pc = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmMmioEmulateFtraceEvent)
  return target;
}

size_t KvmMmioEmulateFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmMmioEmulateFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 cpsr = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_cpsr());
    }

    // optional uint64 instr = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_instr());
    }

    // optional uint64 vcpu_pc = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_pc());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmMmioEmulateFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmMmioEmulateFtraceEvent*>(
      &from));
}

void KvmMmioEmulateFtraceEvent::MergeFrom(const KvmMmioEmulateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmMmioEmulateFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      cpsr_ = from.cpsr_;
    }
    if (cached_has_bits & 0x00000002u) {
      instr_ = from.instr_;
    }
    if (cached_has_bits & 0x00000004u) {
      vcpu_pc_ = from.vcpu_pc_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmMmioEmulateFtraceEvent::CopyFrom(const KvmMmioEmulateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmMmioEmulateFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmMmioEmulateFtraceEvent::IsInitialized() const {
  return true;
}

void KvmMmioEmulateFtraceEvent::InternalSwap(KvmMmioEmulateFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmMmioEmulateFtraceEvent, vcpu_pc_)
      + sizeof(KvmMmioEmulateFtraceEvent::vcpu_pc_)
      - PROTOBUF_FIELD_OFFSET(KvmMmioEmulateFtraceEvent, cpsr_)>(
          reinterpret_cast<char*>(&cpsr_),
          reinterpret_cast<char*>(&other->cpsr_));
}

std::string KvmMmioEmulateFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmMmioEmulateFtraceEvent";
}


// ===================================================================

class KvmSetGuestDebugFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmSetGuestDebugFtraceEvent>()._has_bits_);
  static void set_has_guest_debug(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmSetGuestDebugFtraceEvent::KvmSetGuestDebugFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmSetGuestDebugFtraceEvent)
}
KvmSetGuestDebugFtraceEvent::KvmSetGuestDebugFtraceEvent(const KvmSetGuestDebugFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&vcpu_, &from.vcpu_,
    static_cast<size_t>(reinterpret_cast<char*>(&guest_debug_) -
    reinterpret_cast<char*>(&vcpu_)) + sizeof(guest_debug_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmSetGuestDebugFtraceEvent)
}

inline void KvmSetGuestDebugFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&vcpu_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&guest_debug_) -
    reinterpret_cast<char*>(&vcpu_)) + sizeof(guest_debug_));
}

KvmSetGuestDebugFtraceEvent::~KvmSetGuestDebugFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmSetGuestDebugFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmSetGuestDebugFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmSetGuestDebugFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmSetGuestDebugFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmSetGuestDebugFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&vcpu_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&guest_debug_) -
        reinterpret_cast<char*>(&vcpu_)) + sizeof(guest_debug_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmSetGuestDebugFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 guest_debug = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_guest_debug(&has_bits);
          guest_debug_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_vcpu(&has_bits);
          vcpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmSetGuestDebugFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmSetGuestDebugFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 guest_debug = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_guest_debug(), target);
  }

  // optional uint64 vcpu = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_vcpu(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmSetGuestDebugFtraceEvent)
  return target;
}

size_t KvmSetGuestDebugFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmSetGuestDebugFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 vcpu = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu());
    }

    // optional uint32 guest_debug = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_guest_debug());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmSetGuestDebugFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmSetGuestDebugFtraceEvent*>(
      &from));
}

void KvmSetGuestDebugFtraceEvent::MergeFrom(const KvmSetGuestDebugFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmSetGuestDebugFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      vcpu_ = from.vcpu_;
    }
    if (cached_has_bits & 0x00000002u) {
      guest_debug_ = from.guest_debug_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmSetGuestDebugFtraceEvent::CopyFrom(const KvmSetGuestDebugFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmSetGuestDebugFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmSetGuestDebugFtraceEvent::IsInitialized() const {
  return true;
}

void KvmSetGuestDebugFtraceEvent::InternalSwap(KvmSetGuestDebugFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmSetGuestDebugFtraceEvent, guest_debug_)
      + sizeof(KvmSetGuestDebugFtraceEvent::guest_debug_)
      - PROTOBUF_FIELD_OFFSET(KvmSetGuestDebugFtraceEvent, vcpu_)>(
          reinterpret_cast<char*>(&vcpu_),
          reinterpret_cast<char*>(&other->vcpu_));
}

std::string KvmSetGuestDebugFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmSetGuestDebugFtraceEvent";
}


// ===================================================================

class KvmSetIrqFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmSetIrqFtraceEvent>()._has_bits_);
  static void set_has_gsi(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_irq_source_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmSetIrqFtraceEvent::KvmSetIrqFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmSetIrqFtraceEvent)
}
KvmSetIrqFtraceEvent::KvmSetIrqFtraceEvent(const KvmSetIrqFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&gsi_, &from.gsi_,
    static_cast<size_t>(reinterpret_cast<char*>(&level_) -
    reinterpret_cast<char*>(&gsi_)) + sizeof(level_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmSetIrqFtraceEvent)
}

inline void KvmSetIrqFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gsi_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&level_) -
    reinterpret_cast<char*>(&gsi_)) + sizeof(level_));
}

KvmSetIrqFtraceEvent::~KvmSetIrqFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmSetIrqFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmSetIrqFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmSetIrqFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmSetIrqFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmSetIrqFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&gsi_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&level_) -
        reinterpret_cast<char*>(&gsi_)) + sizeof(level_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmSetIrqFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 gsi = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gsi(&has_bits);
          gsi_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 irq_source_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_irq_source_id(&has_bits);
          irq_source_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 level = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_level(&has_bits);
          level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmSetIrqFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmSetIrqFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 gsi = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gsi(), target);
  }

  // optional int32 irq_source_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_irq_source_id(), target);
  }

  // optional int32 level = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmSetIrqFtraceEvent)
  return target;
}

size_t KvmSetIrqFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmSetIrqFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 gsi = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gsi());
    }

    // optional int32 irq_source_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_irq_source_id());
    }

    // optional int32 level = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_level());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmSetIrqFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmSetIrqFtraceEvent*>(
      &from));
}

void KvmSetIrqFtraceEvent::MergeFrom(const KvmSetIrqFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmSetIrqFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      gsi_ = from.gsi_;
    }
    if (cached_has_bits & 0x00000002u) {
      irq_source_id_ = from.irq_source_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      level_ = from.level_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmSetIrqFtraceEvent::CopyFrom(const KvmSetIrqFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmSetIrqFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmSetIrqFtraceEvent::IsInitialized() const {
  return true;
}

void KvmSetIrqFtraceEvent::InternalSwap(KvmSetIrqFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmSetIrqFtraceEvent, level_)
      + sizeof(KvmSetIrqFtraceEvent::level_)
      - PROTOBUF_FIELD_OFFSET(KvmSetIrqFtraceEvent, gsi_)>(
          reinterpret_cast<char*>(&gsi_),
          reinterpret_cast<char*>(&other->gsi_));
}

std::string KvmSetIrqFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmSetIrqFtraceEvent";
}


// ===================================================================

class KvmSetSpteHvaFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmSetSpteHvaFtraceEvent>()._has_bits_);
  static void set_has_hva(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmSetSpteHvaFtraceEvent::KvmSetSpteHvaFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmSetSpteHvaFtraceEvent)
}
KvmSetSpteHvaFtraceEvent::KvmSetSpteHvaFtraceEvent(const KvmSetSpteHvaFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  hva_ = from.hva_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmSetSpteHvaFtraceEvent)
}

inline void KvmSetSpteHvaFtraceEvent::SharedCtor() {
hva_ = uint64_t{0u};
}

KvmSetSpteHvaFtraceEvent::~KvmSetSpteHvaFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmSetSpteHvaFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmSetSpteHvaFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmSetSpteHvaFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmSetSpteHvaFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmSetSpteHvaFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  hva_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmSetSpteHvaFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 hva = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hva(&has_bits);
          hva_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmSetSpteHvaFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmSetSpteHvaFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 hva = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_hva(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmSetSpteHvaFtraceEvent)
  return target;
}

size_t KvmSetSpteHvaFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmSetSpteHvaFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 hva = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_hva());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmSetSpteHvaFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmSetSpteHvaFtraceEvent*>(
      &from));
}

void KvmSetSpteHvaFtraceEvent::MergeFrom(const KvmSetSpteHvaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmSetSpteHvaFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_hva()) {
    _internal_set_hva(from._internal_hva());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmSetSpteHvaFtraceEvent::CopyFrom(const KvmSetSpteHvaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmSetSpteHvaFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmSetSpteHvaFtraceEvent::IsInitialized() const {
  return true;
}

void KvmSetSpteHvaFtraceEvent::InternalSwap(KvmSetSpteHvaFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(hva_, other->hva_);
}

std::string KvmSetSpteHvaFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmSetSpteHvaFtraceEvent";
}


// ===================================================================

class KvmSetWayFlushFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmSetWayFlushFtraceEvent>()._has_bits_);
  static void set_has_cache(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmSetWayFlushFtraceEvent::KvmSetWayFlushFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmSetWayFlushFtraceEvent)
}
KvmSetWayFlushFtraceEvent::KvmSetWayFlushFtraceEvent(const KvmSetWayFlushFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&vcpu_pc_, &from.vcpu_pc_,
    static_cast<size_t>(reinterpret_cast<char*>(&cache_) -
    reinterpret_cast<char*>(&vcpu_pc_)) + sizeof(cache_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmSetWayFlushFtraceEvent)
}

inline void KvmSetWayFlushFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&vcpu_pc_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&cache_) -
    reinterpret_cast<char*>(&vcpu_pc_)) + sizeof(cache_));
}

KvmSetWayFlushFtraceEvent::~KvmSetWayFlushFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmSetWayFlushFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmSetWayFlushFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmSetWayFlushFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmSetWayFlushFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmSetWayFlushFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&vcpu_pc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cache_) -
        reinterpret_cast<char*>(&vcpu_pc_)) + sizeof(cache_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmSetWayFlushFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 cache = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cache(&has_bits);
          cache_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu_pc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmSetWayFlushFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmSetWayFlushFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 cache = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_cache(), target);
  }

  // optional uint64 vcpu_pc = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmSetWayFlushFtraceEvent)
  return target;
}

size_t KvmSetWayFlushFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmSetWayFlushFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 vcpu_pc = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_pc());
    }

    // optional uint32 cache = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cache());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmSetWayFlushFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmSetWayFlushFtraceEvent*>(
      &from));
}

void KvmSetWayFlushFtraceEvent::MergeFrom(const KvmSetWayFlushFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmSetWayFlushFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      vcpu_pc_ = from.vcpu_pc_;
    }
    if (cached_has_bits & 0x00000002u) {
      cache_ = from.cache_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmSetWayFlushFtraceEvent::CopyFrom(const KvmSetWayFlushFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmSetWayFlushFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmSetWayFlushFtraceEvent::IsInitialized() const {
  return true;
}

void KvmSetWayFlushFtraceEvent::InternalSwap(KvmSetWayFlushFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmSetWayFlushFtraceEvent, cache_)
      + sizeof(KvmSetWayFlushFtraceEvent::cache_)
      - PROTOBUF_FIELD_OFFSET(KvmSetWayFlushFtraceEvent, vcpu_pc_)>(
          reinterpret_cast<char*>(&vcpu_pc_),
          reinterpret_cast<char*>(&other->vcpu_pc_));
}

std::string KvmSetWayFlushFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmSetWayFlushFtraceEvent";
}


// ===================================================================

class KvmSysAccessFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmSysAccessFtraceEvent>()._has_bits_);
  static void set_has_crm(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_crn(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_op0(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_op1(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_op2(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_is_write(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

KvmSysAccessFtraceEvent::KvmSysAccessFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmSysAccessFtraceEvent)
}
KvmSysAccessFtraceEvent::KvmSysAccessFtraceEvent(const KvmSysAccessFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&crm_, &from.crm_,
    static_cast<size_t>(reinterpret_cast<char*>(&vcpu_pc_) -
    reinterpret_cast<char*>(&crm_)) + sizeof(vcpu_pc_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmSysAccessFtraceEvent)
}

inline void KvmSysAccessFtraceEvent::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&crm_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&vcpu_pc_) -
    reinterpret_cast<char*>(&crm_)) + sizeof(vcpu_pc_));
}

KvmSysAccessFtraceEvent::~KvmSysAccessFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmSysAccessFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmSysAccessFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
}

void KvmSysAccessFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmSysAccessFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmSysAccessFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&crm_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&vcpu_pc_) -
        reinterpret_cast<char*>(&crm_)) + sizeof(vcpu_pc_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmSysAccessFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 CRm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_crm(&has_bits);
          crm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 CRn = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_crn(&has_bits);
          crn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 Op0 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_op0(&has_bits);
          op0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 Op1 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_op1(&has_bits);
          op1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 Op2 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_op2(&has_bits);
          op2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 is_write = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_is_write(&has_bits);
          is_write_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu_pc = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmSysAccessFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmSysAccessFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 CRm = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_crm(), target);
  }

  // optional uint32 CRn = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_crn(), target);
  }

  // optional uint32 Op0 = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_op0(), target);
  }

  // optional uint32 Op1 = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_op1(), target);
  }

  // optional uint32 Op2 = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_op2(), target);
  }

  // optional uint32 is_write = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_is_write(), target);
  }

  // optional string name = 7;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_name(), target);
  }

  // optional uint64 vcpu_pc = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmSysAccessFtraceEvent)
  return target;
}

size_t KvmSysAccessFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmSysAccessFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 CRm = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_crm());
    }

    // optional uint32 CRn = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_crn());
    }

    // optional uint32 Op0 = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_op0());
    }

    // optional uint32 Op1 = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_op1());
    }

    // optional uint32 Op2 = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_op2());
    }

    // optional uint32 is_write = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_is_write());
    }

    // optional uint64 vcpu_pc = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_pc());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmSysAccessFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmSysAccessFtraceEvent*>(
      &from));
}

void KvmSysAccessFtraceEvent::MergeFrom(const KvmSysAccessFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmSysAccessFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      crm_ = from.crm_;
    }
    if (cached_has_bits & 0x00000004u) {
      crn_ = from.crn_;
    }
    if (cached_has_bits & 0x00000008u) {
      op0_ = from.op0_;
    }
    if (cached_has_bits & 0x00000010u) {
      op1_ = from.op1_;
    }
    if (cached_has_bits & 0x00000020u) {
      op2_ = from.op2_;
    }
    if (cached_has_bits & 0x00000040u) {
      is_write_ = from.is_write_;
    }
    if (cached_has_bits & 0x00000080u) {
      vcpu_pc_ = from.vcpu_pc_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmSysAccessFtraceEvent::CopyFrom(const KvmSysAccessFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmSysAccessFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmSysAccessFtraceEvent::IsInitialized() const {
  return true;
}

void KvmSysAccessFtraceEvent::InternalSwap(KvmSysAccessFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmSysAccessFtraceEvent, vcpu_pc_)
      + sizeof(KvmSysAccessFtraceEvent::vcpu_pc_)
      - PROTOBUF_FIELD_OFFSET(KvmSysAccessFtraceEvent, crm_)>(
          reinterpret_cast<char*>(&crm_),
          reinterpret_cast<char*>(&other->crm_));
}

std::string KvmSysAccessFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmSysAccessFtraceEvent";
}


// ===================================================================

class KvmTestAgeHvaFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmTestAgeHvaFtraceEvent>()._has_bits_);
  static void set_has_hva(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmTestAgeHvaFtraceEvent::KvmTestAgeHvaFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmTestAgeHvaFtraceEvent)
}
KvmTestAgeHvaFtraceEvent::KvmTestAgeHvaFtraceEvent(const KvmTestAgeHvaFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  hva_ = from.hva_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmTestAgeHvaFtraceEvent)
}

inline void KvmTestAgeHvaFtraceEvent::SharedCtor() {
hva_ = uint64_t{0u};
}

KvmTestAgeHvaFtraceEvent::~KvmTestAgeHvaFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmTestAgeHvaFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmTestAgeHvaFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmTestAgeHvaFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmTestAgeHvaFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmTestAgeHvaFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  hva_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmTestAgeHvaFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 hva = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hva(&has_bits);
          hva_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmTestAgeHvaFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmTestAgeHvaFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 hva = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_hva(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmTestAgeHvaFtraceEvent)
  return target;
}

size_t KvmTestAgeHvaFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmTestAgeHvaFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 hva = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_hva());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmTestAgeHvaFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmTestAgeHvaFtraceEvent*>(
      &from));
}

void KvmTestAgeHvaFtraceEvent::MergeFrom(const KvmTestAgeHvaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmTestAgeHvaFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_hva()) {
    _internal_set_hva(from._internal_hva());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmTestAgeHvaFtraceEvent::CopyFrom(const KvmTestAgeHvaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmTestAgeHvaFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmTestAgeHvaFtraceEvent::IsInitialized() const {
  return true;
}

void KvmTestAgeHvaFtraceEvent::InternalSwap(KvmTestAgeHvaFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(hva_, other->hva_);
}

std::string KvmTestAgeHvaFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmTestAgeHvaFtraceEvent";
}


// ===================================================================

class KvmTimerEmulateFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmTimerEmulateFtraceEvent>()._has_bits_);
  static void set_has_should_fire(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timer_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KvmTimerEmulateFtraceEvent::KvmTimerEmulateFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmTimerEmulateFtraceEvent)
}
KvmTimerEmulateFtraceEvent::KvmTimerEmulateFtraceEvent(const KvmTimerEmulateFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&should_fire_, &from.should_fire_,
    static_cast<size_t>(reinterpret_cast<char*>(&timer_idx_) -
    reinterpret_cast<char*>(&should_fire_)) + sizeof(timer_idx_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmTimerEmulateFtraceEvent)
}

inline void KvmTimerEmulateFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&should_fire_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&timer_idx_) -
    reinterpret_cast<char*>(&should_fire_)) + sizeof(timer_idx_));
}

KvmTimerEmulateFtraceEvent::~KvmTimerEmulateFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmTimerEmulateFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmTimerEmulateFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmTimerEmulateFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmTimerEmulateFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmTimerEmulateFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&should_fire_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&timer_idx_) -
        reinterpret_cast<char*>(&should_fire_)) + sizeof(timer_idx_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmTimerEmulateFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 should_fire = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_should_fire(&has_bits);
          should_fire_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 timer_idx = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_timer_idx(&has_bits);
          timer_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmTimerEmulateFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmTimerEmulateFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 should_fire = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_should_fire(), target);
  }

  // optional int32 timer_idx = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_timer_idx(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmTimerEmulateFtraceEvent)
  return target;
}

size_t KvmTimerEmulateFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmTimerEmulateFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 should_fire = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_should_fire());
    }

    // optional int32 timer_idx = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_timer_idx());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmTimerEmulateFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmTimerEmulateFtraceEvent*>(
      &from));
}

void KvmTimerEmulateFtraceEvent::MergeFrom(const KvmTimerEmulateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmTimerEmulateFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      should_fire_ = from.should_fire_;
    }
    if (cached_has_bits & 0x00000002u) {
      timer_idx_ = from.timer_idx_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmTimerEmulateFtraceEvent::CopyFrom(const KvmTimerEmulateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmTimerEmulateFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmTimerEmulateFtraceEvent::IsInitialized() const {
  return true;
}

void KvmTimerEmulateFtraceEvent::InternalSwap(KvmTimerEmulateFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmTimerEmulateFtraceEvent, timer_idx_)
      + sizeof(KvmTimerEmulateFtraceEvent::timer_idx_)
      - PROTOBUF_FIELD_OFFSET(KvmTimerEmulateFtraceEvent, should_fire_)>(
          reinterpret_cast<char*>(&should_fire_),
          reinterpret_cast<char*>(&other->should_fire_));
}

std::string KvmTimerEmulateFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmTimerEmulateFtraceEvent";
}


// ===================================================================

class KvmTimerHrtimerExpireFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmTimerHrtimerExpireFtraceEvent>()._has_bits_);
  static void set_has_timer_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmTimerHrtimerExpireFtraceEvent::KvmTimerHrtimerExpireFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
}
KvmTimerHrtimerExpireFtraceEvent::KvmTimerHrtimerExpireFtraceEvent(const KvmTimerHrtimerExpireFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  timer_idx_ = from.timer_idx_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
}

inline void KvmTimerHrtimerExpireFtraceEvent::SharedCtor() {
timer_idx_ = 0;
}

KvmTimerHrtimerExpireFtraceEvent::~KvmTimerHrtimerExpireFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmTimerHrtimerExpireFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmTimerHrtimerExpireFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmTimerHrtimerExpireFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  timer_idx_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmTimerHrtimerExpireFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 timer_idx = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timer_idx(&has_bits);
          timer_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmTimerHrtimerExpireFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 timer_idx = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_timer_idx(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
  return target;
}

size_t KvmTimerHrtimerExpireFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 timer_idx = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_timer_idx());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmTimerHrtimerExpireFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmTimerHrtimerExpireFtraceEvent*>(
      &from));
}

void KvmTimerHrtimerExpireFtraceEvent::MergeFrom(const KvmTimerHrtimerExpireFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_timer_idx()) {
    _internal_set_timer_idx(from._internal_timer_idx());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmTimerHrtimerExpireFtraceEvent::CopyFrom(const KvmTimerHrtimerExpireFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmTimerHrtimerExpireFtraceEvent::IsInitialized() const {
  return true;
}

void KvmTimerHrtimerExpireFtraceEvent::InternalSwap(KvmTimerHrtimerExpireFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(timer_idx_, other->timer_idx_);
}

std::string KvmTimerHrtimerExpireFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmTimerHrtimerExpireFtraceEvent";
}


// ===================================================================

class KvmTimerRestoreStateFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmTimerRestoreStateFtraceEvent>()._has_bits_);
  static void set_has_ctl(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cval(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timer_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmTimerRestoreStateFtraceEvent::KvmTimerRestoreStateFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
}
KvmTimerRestoreStateFtraceEvent::KvmTimerRestoreStateFtraceEvent(const KvmTimerRestoreStateFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&ctl_, &from.ctl_,
    static_cast<size_t>(reinterpret_cast<char*>(&timer_idx_) -
    reinterpret_cast<char*>(&ctl_)) + sizeof(timer_idx_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
}

inline void KvmTimerRestoreStateFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ctl_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&timer_idx_) -
    reinterpret_cast<char*>(&ctl_)) + sizeof(timer_idx_));
}

KvmTimerRestoreStateFtraceEvent::~KvmTimerRestoreStateFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmTimerRestoreStateFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmTimerRestoreStateFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmTimerRestoreStateFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&ctl_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&timer_idx_) -
        reinterpret_cast<char*>(&ctl_)) + sizeof(timer_idx_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmTimerRestoreStateFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 ctl = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ctl(&has_bits);
          ctl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 cval = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_cval(&has_bits);
          cval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 timer_idx = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_timer_idx(&has_bits);
          timer_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmTimerRestoreStateFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 ctl = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_ctl(), target);
  }

  // optional uint64 cval = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_cval(), target);
  }

  // optional int32 timer_idx = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_timer_idx(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
  return target;
}

size_t KvmTimerRestoreStateFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 ctl = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ctl());
    }

    // optional uint64 cval = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_cval());
    }

    // optional int32 timer_idx = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_timer_idx());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmTimerRestoreStateFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmTimerRestoreStateFtraceEvent*>(
      &from));
}

void KvmTimerRestoreStateFtraceEvent::MergeFrom(const KvmTimerRestoreStateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ctl_ = from.ctl_;
    }
    if (cached_has_bits & 0x00000002u) {
      cval_ = from.cval_;
    }
    if (cached_has_bits & 0x00000004u) {
      timer_idx_ = from.timer_idx_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmTimerRestoreStateFtraceEvent::CopyFrom(const KvmTimerRestoreStateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmTimerRestoreStateFtraceEvent::IsInitialized() const {
  return true;
}

void KvmTimerRestoreStateFtraceEvent::InternalSwap(KvmTimerRestoreStateFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmTimerRestoreStateFtraceEvent, timer_idx_)
      + sizeof(KvmTimerRestoreStateFtraceEvent::timer_idx_)
      - PROTOBUF_FIELD_OFFSET(KvmTimerRestoreStateFtraceEvent, ctl_)>(
          reinterpret_cast<char*>(&ctl_),
          reinterpret_cast<char*>(&other->ctl_));
}

std::string KvmTimerRestoreStateFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmTimerRestoreStateFtraceEvent";
}


// ===================================================================

class KvmTimerSaveStateFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmTimerSaveStateFtraceEvent>()._has_bits_);
  static void set_has_ctl(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cval(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timer_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmTimerSaveStateFtraceEvent::KvmTimerSaveStateFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmTimerSaveStateFtraceEvent)
}
KvmTimerSaveStateFtraceEvent::KvmTimerSaveStateFtraceEvent(const KvmTimerSaveStateFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&ctl_, &from.ctl_,
    static_cast<size_t>(reinterpret_cast<char*>(&timer_idx_) -
    reinterpret_cast<char*>(&ctl_)) + sizeof(timer_idx_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmTimerSaveStateFtraceEvent)
}

inline void KvmTimerSaveStateFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ctl_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&timer_idx_) -
    reinterpret_cast<char*>(&ctl_)) + sizeof(timer_idx_));
}

KvmTimerSaveStateFtraceEvent::~KvmTimerSaveStateFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmTimerSaveStateFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmTimerSaveStateFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmTimerSaveStateFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmTimerSaveStateFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmTimerSaveStateFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&ctl_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&timer_idx_) -
        reinterpret_cast<char*>(&ctl_)) + sizeof(timer_idx_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmTimerSaveStateFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 ctl = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ctl(&has_bits);
          ctl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 cval = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_cval(&has_bits);
          cval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 timer_idx = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_timer_idx(&has_bits);
          timer_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmTimerSaveStateFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmTimerSaveStateFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 ctl = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_ctl(), target);
  }

  // optional uint64 cval = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_cval(), target);
  }

  // optional int32 timer_idx = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_timer_idx(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmTimerSaveStateFtraceEvent)
  return target;
}

size_t KvmTimerSaveStateFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmTimerSaveStateFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 ctl = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ctl());
    }

    // optional uint64 cval = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_cval());
    }

    // optional int32 timer_idx = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_timer_idx());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmTimerSaveStateFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmTimerSaveStateFtraceEvent*>(
      &from));
}

void KvmTimerSaveStateFtraceEvent::MergeFrom(const KvmTimerSaveStateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmTimerSaveStateFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ctl_ = from.ctl_;
    }
    if (cached_has_bits & 0x00000002u) {
      cval_ = from.cval_;
    }
    if (cached_has_bits & 0x00000004u) {
      timer_idx_ = from.timer_idx_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmTimerSaveStateFtraceEvent::CopyFrom(const KvmTimerSaveStateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmTimerSaveStateFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmTimerSaveStateFtraceEvent::IsInitialized() const {
  return true;
}

void KvmTimerSaveStateFtraceEvent::InternalSwap(KvmTimerSaveStateFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmTimerSaveStateFtraceEvent, timer_idx_)
      + sizeof(KvmTimerSaveStateFtraceEvent::timer_idx_)
      - PROTOBUF_FIELD_OFFSET(KvmTimerSaveStateFtraceEvent, ctl_)>(
          reinterpret_cast<char*>(&ctl_),
          reinterpret_cast<char*>(&other->ctl_));
}

std::string KvmTimerSaveStateFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmTimerSaveStateFtraceEvent";
}


// ===================================================================

class KvmTimerUpdateIrqFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmTimerUpdateIrqFtraceEvent>()._has_bits_);
  static void set_has_irq(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmTimerUpdateIrqFtraceEvent::KvmTimerUpdateIrqFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
}
KvmTimerUpdateIrqFtraceEvent::KvmTimerUpdateIrqFtraceEvent(const KvmTimerUpdateIrqFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&irq_, &from.irq_,
    static_cast<size_t>(reinterpret_cast<char*>(&vcpu_id_) -
    reinterpret_cast<char*>(&irq_)) + sizeof(vcpu_id_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
}

inline void KvmTimerUpdateIrqFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&irq_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&vcpu_id_) -
    reinterpret_cast<char*>(&irq_)) + sizeof(vcpu_id_));
}

KvmTimerUpdateIrqFtraceEvent::~KvmTimerUpdateIrqFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmTimerUpdateIrqFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmTimerUpdateIrqFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmTimerUpdateIrqFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&irq_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&vcpu_id_) -
        reinterpret_cast<char*>(&irq_)) + sizeof(vcpu_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmTimerUpdateIrqFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 irq = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_irq(&has_bits);
          irq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_level(&has_bits);
          level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_vcpu_id(&has_bits);
          vcpu_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmTimerUpdateIrqFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 irq = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_irq(), target);
  }

  // optional int32 level = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_level(), target);
  }

  // optional uint64 vcpu_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_vcpu_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
  return target;
}

size_t KvmTimerUpdateIrqFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 irq = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_irq());
    }

    // optional int32 level = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_level());
    }

    // optional uint64 vcpu_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmTimerUpdateIrqFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmTimerUpdateIrqFtraceEvent*>(
      &from));
}

void KvmTimerUpdateIrqFtraceEvent::MergeFrom(const KvmTimerUpdateIrqFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      irq_ = from.irq_;
    }
    if (cached_has_bits & 0x00000002u) {
      level_ = from.level_;
    }
    if (cached_has_bits & 0x00000004u) {
      vcpu_id_ = from.vcpu_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmTimerUpdateIrqFtraceEvent::CopyFrom(const KvmTimerUpdateIrqFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmTimerUpdateIrqFtraceEvent::IsInitialized() const {
  return true;
}

void KvmTimerUpdateIrqFtraceEvent::InternalSwap(KvmTimerUpdateIrqFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmTimerUpdateIrqFtraceEvent, vcpu_id_)
      + sizeof(KvmTimerUpdateIrqFtraceEvent::vcpu_id_)
      - PROTOBUF_FIELD_OFFSET(KvmTimerUpdateIrqFtraceEvent, irq_)>(
          reinterpret_cast<char*>(&irq_),
          reinterpret_cast<char*>(&other->irq_));
}

std::string KvmTimerUpdateIrqFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmTimerUpdateIrqFtraceEvent";
}


// ===================================================================

class KvmToggleCacheFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmToggleCacheFtraceEvent>()._has_bits_);
  static void set_has_now(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_was(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmToggleCacheFtraceEvent::KvmToggleCacheFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmToggleCacheFtraceEvent)
}
KvmToggleCacheFtraceEvent::KvmToggleCacheFtraceEvent(const KvmToggleCacheFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&vcpu_pc_, &from.vcpu_pc_,
    static_cast<size_t>(reinterpret_cast<char*>(&was_) -
    reinterpret_cast<char*>(&vcpu_pc_)) + sizeof(was_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmToggleCacheFtraceEvent)
}

inline void KvmToggleCacheFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&vcpu_pc_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&was_) -
    reinterpret_cast<char*>(&vcpu_pc_)) + sizeof(was_));
}

KvmToggleCacheFtraceEvent::~KvmToggleCacheFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmToggleCacheFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmToggleCacheFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmToggleCacheFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmToggleCacheFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmToggleCacheFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&vcpu_pc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&was_) -
        reinterpret_cast<char*>(&vcpu_pc_)) + sizeof(was_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmToggleCacheFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 now = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_now(&has_bits);
          now_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu_pc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 was = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_was(&has_bits);
          was_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmToggleCacheFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmToggleCacheFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 now = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_now(), target);
  }

  // optional uint64 vcpu_pc = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_vcpu_pc(), target);
  }

  // optional uint32 was = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_was(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmToggleCacheFtraceEvent)
  return target;
}

size_t KvmToggleCacheFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmToggleCacheFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 vcpu_pc = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_pc());
    }

    // optional uint32 now = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_now());
    }

    // optional uint32 was = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_was());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmToggleCacheFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmToggleCacheFtraceEvent*>(
      &from));
}

void KvmToggleCacheFtraceEvent::MergeFrom(const KvmToggleCacheFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmToggleCacheFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      vcpu_pc_ = from.vcpu_pc_;
    }
    if (cached_has_bits & 0x00000002u) {
      now_ = from.now_;
    }
    if (cached_has_bits & 0x00000004u) {
      was_ = from.was_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmToggleCacheFtraceEvent::CopyFrom(const KvmToggleCacheFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmToggleCacheFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmToggleCacheFtraceEvent::IsInitialized() const {
  return true;
}

void KvmToggleCacheFtraceEvent::InternalSwap(KvmToggleCacheFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmToggleCacheFtraceEvent, was_)
      + sizeof(KvmToggleCacheFtraceEvent::was_)
      - PROTOBUF_FIELD_OFFSET(KvmToggleCacheFtraceEvent, vcpu_pc_)>(
          reinterpret_cast<char*>(&vcpu_pc_),
          reinterpret_cast<char*>(&other->vcpu_pc_));
}

std::string KvmToggleCacheFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmToggleCacheFtraceEvent";
}


// ===================================================================

class KvmUnmapHvaRangeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmUnmapHvaRangeFtraceEvent>()._has_bits_);
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KvmUnmapHvaRangeFtraceEvent::KvmUnmapHvaRangeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
}
KvmUnmapHvaRangeFtraceEvent::KvmUnmapHvaRangeFtraceEvent(const KvmUnmapHvaRangeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&end_, &from.end_,
    static_cast<size_t>(reinterpret_cast<char*>(&start_) -
    reinterpret_cast<char*>(&end_)) + sizeof(start_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
}

inline void KvmUnmapHvaRangeFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&end_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&start_) -
    reinterpret_cast<char*>(&end_)) + sizeof(start_));
}

KvmUnmapHvaRangeFtraceEvent::~KvmUnmapHvaRangeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmUnmapHvaRangeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmUnmapHvaRangeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmUnmapHvaRangeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&end_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&start_) -
        reinterpret_cast<char*>(&end_)) + sizeof(start_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmUnmapHvaRangeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 end = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_end(&has_bits);
          end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_start(&has_bits);
          start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmUnmapHvaRangeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 end = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_end(), target);
  }

  // optional uint64 start = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_start(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
  return target;
}

size_t KvmUnmapHvaRangeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 end = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_end());
    }

    // optional uint64 start = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_start());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmUnmapHvaRangeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmUnmapHvaRangeFtraceEvent*>(
      &from));
}

void KvmUnmapHvaRangeFtraceEvent::MergeFrom(const KvmUnmapHvaRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      end_ = from.end_;
    }
    if (cached_has_bits & 0x00000002u) {
      start_ = from.start_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmUnmapHvaRangeFtraceEvent::CopyFrom(const KvmUnmapHvaRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmUnmapHvaRangeFtraceEvent::IsInitialized() const {
  return true;
}

void KvmUnmapHvaRangeFtraceEvent::InternalSwap(KvmUnmapHvaRangeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmUnmapHvaRangeFtraceEvent, start_)
      + sizeof(KvmUnmapHvaRangeFtraceEvent::start_)
      - PROTOBUF_FIELD_OFFSET(KvmUnmapHvaRangeFtraceEvent, end_)>(
          reinterpret_cast<char*>(&end_),
          reinterpret_cast<char*>(&other->end_));
}

std::string KvmUnmapHvaRangeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmUnmapHvaRangeFtraceEvent";
}


// ===================================================================

class KvmUserspaceExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmUserspaceExitFtraceEvent>()._has_bits_);
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmUserspaceExitFtraceEvent::KvmUserspaceExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmUserspaceExitFtraceEvent)
}
KvmUserspaceExitFtraceEvent::KvmUserspaceExitFtraceEvent(const KvmUserspaceExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  reason_ = from.reason_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmUserspaceExitFtraceEvent)
}

inline void KvmUserspaceExitFtraceEvent::SharedCtor() {
reason_ = 0u;
}

KvmUserspaceExitFtraceEvent::~KvmUserspaceExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmUserspaceExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmUserspaceExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmUserspaceExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmUserspaceExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmUserspaceExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  reason_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmUserspaceExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 reason = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_reason(&has_bits);
          reason_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmUserspaceExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmUserspaceExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 reason = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_reason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmUserspaceExitFtraceEvent)
  return target;
}

size_t KvmUserspaceExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmUserspaceExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 reason = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reason());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmUserspaceExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmUserspaceExitFtraceEvent*>(
      &from));
}

void KvmUserspaceExitFtraceEvent::MergeFrom(const KvmUserspaceExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmUserspaceExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_reason()) {
    _internal_set_reason(from._internal_reason());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmUserspaceExitFtraceEvent::CopyFrom(const KvmUserspaceExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmUserspaceExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmUserspaceExitFtraceEvent::IsInitialized() const {
  return true;
}

void KvmUserspaceExitFtraceEvent::InternalSwap(KvmUserspaceExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(reason_, other->reason_);
}

std::string KvmUserspaceExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmUserspaceExitFtraceEvent";
}


// ===================================================================

class KvmVcpuWakeupFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmVcpuWakeupFtraceEvent>()._has_bits_);
  static void set_has_ns(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_valid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_waited(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmVcpuWakeupFtraceEvent::KvmVcpuWakeupFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmVcpuWakeupFtraceEvent)
}
KvmVcpuWakeupFtraceEvent::KvmVcpuWakeupFtraceEvent(const KvmVcpuWakeupFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&ns_, &from.ns_,
    static_cast<size_t>(reinterpret_cast<char*>(&waited_) -
    reinterpret_cast<char*>(&ns_)) + sizeof(waited_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmVcpuWakeupFtraceEvent)
}

inline void KvmVcpuWakeupFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ns_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&waited_) -
    reinterpret_cast<char*>(&ns_)) + sizeof(waited_));
}

KvmVcpuWakeupFtraceEvent::~KvmVcpuWakeupFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmVcpuWakeupFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmVcpuWakeupFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmVcpuWakeupFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmVcpuWakeupFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmVcpuWakeupFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&ns_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&waited_) -
        reinterpret_cast<char*>(&ns_)) + sizeof(waited_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmVcpuWakeupFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 ns = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ns(&has_bits);
          ns_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 valid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_valid(&has_bits);
          valid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 waited = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_waited(&has_bits);
          waited_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmVcpuWakeupFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmVcpuWakeupFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 ns = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_ns(), target);
  }

  // optional uint32 valid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_valid(), target);
  }

  // optional uint32 waited = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_waited(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmVcpuWakeupFtraceEvent)
  return target;
}

size_t KvmVcpuWakeupFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmVcpuWakeupFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 ns = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ns());
    }

    // optional uint32 valid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_valid());
    }

    // optional uint32 waited = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_waited());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmVcpuWakeupFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmVcpuWakeupFtraceEvent*>(
      &from));
}

void KvmVcpuWakeupFtraceEvent::MergeFrom(const KvmVcpuWakeupFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmVcpuWakeupFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ns_ = from.ns_;
    }
    if (cached_has_bits & 0x00000002u) {
      valid_ = from.valid_;
    }
    if (cached_has_bits & 0x00000004u) {
      waited_ = from.waited_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmVcpuWakeupFtraceEvent::CopyFrom(const KvmVcpuWakeupFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmVcpuWakeupFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmVcpuWakeupFtraceEvent::IsInitialized() const {
  return true;
}

void KvmVcpuWakeupFtraceEvent::InternalSwap(KvmVcpuWakeupFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmVcpuWakeupFtraceEvent, waited_)
      + sizeof(KvmVcpuWakeupFtraceEvent::waited_)
      - PROTOBUF_FIELD_OFFSET(KvmVcpuWakeupFtraceEvent, ns_)>(
          reinterpret_cast<char*>(&ns_),
          reinterpret_cast<char*>(&other->ns_));
}

std::string KvmVcpuWakeupFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmVcpuWakeupFtraceEvent";
}


// ===================================================================

class KvmWfxArm64FtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmWfxArm64FtraceEvent>()._has_bits_);
  static void set_has_is_wfe(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmWfxArm64FtraceEvent::KvmWfxArm64FtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmWfxArm64FtraceEvent)
}
KvmWfxArm64FtraceEvent::KvmWfxArm64FtraceEvent(const KvmWfxArm64FtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&vcpu_pc_, &from.vcpu_pc_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_wfe_) -
    reinterpret_cast<char*>(&vcpu_pc_)) + sizeof(is_wfe_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmWfxArm64FtraceEvent)
}

inline void KvmWfxArm64FtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&vcpu_pc_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_wfe_) -
    reinterpret_cast<char*>(&vcpu_pc_)) + sizeof(is_wfe_));
}

KvmWfxArm64FtraceEvent::~KvmWfxArm64FtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmWfxArm64FtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmWfxArm64FtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmWfxArm64FtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvmWfxArm64FtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmWfxArm64FtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&vcpu_pc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_wfe_) -
        reinterpret_cast<char*>(&vcpu_pc_)) + sizeof(is_wfe_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmWfxArm64FtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 is_wfe = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_is_wfe(&has_bits);
          is_wfe_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu_pc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmWfxArm64FtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmWfxArm64FtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 is_wfe = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_is_wfe(), target);
  }

  // optional uint64 vcpu_pc = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmWfxArm64FtraceEvent)
  return target;
}

size_t KvmWfxArm64FtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmWfxArm64FtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 vcpu_pc = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_pc());
    }

    // optional uint32 is_wfe = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_is_wfe());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmWfxArm64FtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmWfxArm64FtraceEvent*>(
      &from));
}

void KvmWfxArm64FtraceEvent::MergeFrom(const KvmWfxArm64FtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmWfxArm64FtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      vcpu_pc_ = from.vcpu_pc_;
    }
    if (cached_has_bits & 0x00000002u) {
      is_wfe_ = from.is_wfe_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmWfxArm64FtraceEvent::CopyFrom(const KvmWfxArm64FtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmWfxArm64FtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmWfxArm64FtraceEvent::IsInitialized() const {
  return true;
}

void KvmWfxArm64FtraceEvent::InternalSwap(KvmWfxArm64FtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmWfxArm64FtraceEvent, is_wfe_)
      + sizeof(KvmWfxArm64FtraceEvent::is_wfe_)
      - PROTOBUF_FIELD_OFFSET(KvmWfxArm64FtraceEvent, vcpu_pc_)>(
          reinterpret_cast<char*>(&vcpu_pc_),
          reinterpret_cast<char*>(&other->vcpu_pc_));
}

std::string KvmWfxArm64FtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmWfxArm64FtraceEvent";
}


// ===================================================================

class TrapRegFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<TrapRegFtraceEvent>()._has_bits_);
  static void set_has_fn(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_write(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_reg(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_write_value(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

TrapRegFtraceEvent::TrapRegFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.TrapRegFtraceEvent)
}
TrapRegFtraceEvent::TrapRegFtraceEvent(const TrapRegFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  fn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    fn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fn()) {
    fn_.Set(from._internal_fn(), 
      GetArenaForAllocation());
  }
  ::memcpy(&is_write_, &from.is_write_,
    static_cast<size_t>(reinterpret_cast<char*>(&write_value_) -
    reinterpret_cast<char*>(&is_write_)) + sizeof(write_value_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.TrapRegFtraceEvent)
}

inline void TrapRegFtraceEvent::SharedCtor() {
fn_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  fn_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&is_write_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&write_value_) -
    reinterpret_cast<char*>(&is_write_)) + sizeof(write_value_));
}

TrapRegFtraceEvent::~TrapRegFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.TrapRegFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TrapRegFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  fn_.Destroy();
}

void TrapRegFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TrapRegFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.TrapRegFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    fn_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&is_write_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&write_value_) -
        reinterpret_cast<char*>(&is_write_)) + sizeof(write_value_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TrapRegFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string fn = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_fn();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 is_write = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_write(&has_bits);
          is_write_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 reg = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_reg(&has_bits);
          reg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 write_value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_write_value(&has_bits);
          write_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TrapRegFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.TrapRegFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string fn = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_fn(), target);
  }

  // optional uint32 is_write = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_is_write(), target);
  }

  // optional int32 reg = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_reg(), target);
  }

  // optional uint64 write_value = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_write_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.TrapRegFtraceEvent)
  return target;
}

size_t TrapRegFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.TrapRegFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string fn = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_fn());
    }

    // optional uint32 is_write = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_is_write());
    }

    // optional int32 reg = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_reg());
    }

    // optional uint64 write_value = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_write_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TrapRegFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TrapRegFtraceEvent*>(
      &from));
}

void TrapRegFtraceEvent::MergeFrom(const TrapRegFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.TrapRegFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_fn(from._internal_fn());
    }
    if (cached_has_bits & 0x00000002u) {
      is_write_ = from.is_write_;
    }
    if (cached_has_bits & 0x00000004u) {
      reg_ = from.reg_;
    }
    if (cached_has_bits & 0x00000008u) {
      write_value_ = from.write_value_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TrapRegFtraceEvent::CopyFrom(const TrapRegFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.TrapRegFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrapRegFtraceEvent::IsInitialized() const {
  return true;
}

void TrapRegFtraceEvent::InternalSwap(TrapRegFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &fn_, lhs_arena,
      &other->fn_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TrapRegFtraceEvent, write_value_)
      + sizeof(TrapRegFtraceEvent::write_value_)
      - PROTOBUF_FIELD_OFFSET(TrapRegFtraceEvent, is_write_)>(
          reinterpret_cast<char*>(&is_write_),
          reinterpret_cast<char*>(&other->is_write_));
}

std::string TrapRegFtraceEvent::GetTypeName() const {
  return "perfetto.protos.TrapRegFtraceEvent";
}


// ===================================================================

class VgicUpdateIrqPendingFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<VgicUpdateIrqPendingFtraceEvent>()._has_bits_);
  static void set_has_irq(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

VgicUpdateIrqPendingFtraceEvent::VgicUpdateIrqPendingFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
}
VgicUpdateIrqPendingFtraceEvent::VgicUpdateIrqPendingFtraceEvent(const VgicUpdateIrqPendingFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&irq_, &from.irq_,
    static_cast<size_t>(reinterpret_cast<char*>(&vcpu_id_) -
    reinterpret_cast<char*>(&irq_)) + sizeof(vcpu_id_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
}

inline void VgicUpdateIrqPendingFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&irq_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&vcpu_id_) -
    reinterpret_cast<char*>(&irq_)) + sizeof(vcpu_id_));
}

VgicUpdateIrqPendingFtraceEvent::~VgicUpdateIrqPendingFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VgicUpdateIrqPendingFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VgicUpdateIrqPendingFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VgicUpdateIrqPendingFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&irq_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&vcpu_id_) -
        reinterpret_cast<char*>(&irq_)) + sizeof(vcpu_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VgicUpdateIrqPendingFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 irq = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_irq(&has_bits);
          irq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_level(&has_bits);
          level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_vcpu_id(&has_bits);
          vcpu_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VgicUpdateIrqPendingFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 irq = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_irq(), target);
  }

  // optional uint32 level = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_level(), target);
  }

  // optional uint64 vcpu_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_vcpu_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
  return target;
}

size_t VgicUpdateIrqPendingFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 irq = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_irq());
    }

    // optional uint32 level = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_level());
    }

    // optional uint64 vcpu_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VgicUpdateIrqPendingFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VgicUpdateIrqPendingFtraceEvent*>(
      &from));
}

void VgicUpdateIrqPendingFtraceEvent::MergeFrom(const VgicUpdateIrqPendingFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      irq_ = from.irq_;
    }
    if (cached_has_bits & 0x00000002u) {
      level_ = from.level_;
    }
    if (cached_has_bits & 0x00000004u) {
      vcpu_id_ = from.vcpu_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VgicUpdateIrqPendingFtraceEvent::CopyFrom(const VgicUpdateIrqPendingFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VgicUpdateIrqPendingFtraceEvent::IsInitialized() const {
  return true;
}

void VgicUpdateIrqPendingFtraceEvent::InternalSwap(VgicUpdateIrqPendingFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VgicUpdateIrqPendingFtraceEvent, vcpu_id_)
      + sizeof(VgicUpdateIrqPendingFtraceEvent::vcpu_id_)
      - PROTOBUF_FIELD_OFFSET(VgicUpdateIrqPendingFtraceEvent, irq_)>(
          reinterpret_cast<char*>(&irq_),
          reinterpret_cast<char*>(&other->irq_));
}

std::string VgicUpdateIrqPendingFtraceEvent::GetTypeName() const {
  return "perfetto.protos.VgicUpdateIrqPendingFtraceEvent";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmAccessFaultFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmAccessFaultFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmAccessFaultFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmAckIrqFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmAckIrqFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmAckIrqFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmAgeHvaFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmAgeHvaFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmAgeHvaFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmAgePageFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmAgePageFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmAgePageFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmArmClearDebugFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmArmClearDebugFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmArmClearDebugFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmArmSetDreg32FtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmArmSetDreg32FtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmArmSetDreg32FtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmArmSetRegsetFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmArmSetRegsetFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmArmSetRegsetFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmArmSetupDebugFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmArmSetupDebugFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmArmSetupDebugFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmEntryFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmEntryFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmEntryFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmFpuFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmFpuFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmFpuFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmGetTimerMapFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmGetTimerMapFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmGetTimerMapFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmGuestFaultFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmGuestFaultFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmGuestFaultFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmHandleSysRegFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmHandleSysRegFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmHandleSysRegFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmHvcArm64FtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmHvcArm64FtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmHvcArm64FtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmIrqLineFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmIrqLineFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmIrqLineFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmMmioFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmMmioFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmMmioFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmMmioEmulateFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmMmioEmulateFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmMmioEmulateFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmSetGuestDebugFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmSetGuestDebugFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmSetGuestDebugFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmSetIrqFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmSetIrqFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmSetIrqFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmSetSpteHvaFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmSetSpteHvaFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmSetSpteHvaFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmSetWayFlushFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmSetWayFlushFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmSetWayFlushFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmSysAccessFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmSysAccessFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmSysAccessFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmTestAgeHvaFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmTestAgeHvaFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmTestAgeHvaFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmTimerEmulateFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmTimerEmulateFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmTimerEmulateFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmTimerHrtimerExpireFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmTimerHrtimerExpireFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmTimerHrtimerExpireFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmTimerRestoreStateFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmTimerRestoreStateFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmTimerRestoreStateFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmTimerSaveStateFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmTimerSaveStateFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmTimerSaveStateFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmTimerUpdateIrqFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmTimerUpdateIrqFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmTimerUpdateIrqFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmToggleCacheFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmToggleCacheFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmToggleCacheFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmUnmapHvaRangeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmUnmapHvaRangeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmUnmapHvaRangeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmUserspaceExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmUserspaceExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmUserspaceExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmVcpuWakeupFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmVcpuWakeupFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmVcpuWakeupFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmWfxArm64FtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmWfxArm64FtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmWfxArm64FtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::TrapRegFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::TrapRegFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::TrapRegFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::VgicUpdateIrqPendingFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::VgicUpdateIrqPendingFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::VgicUpdateIrqPendingFtraceEvent >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
