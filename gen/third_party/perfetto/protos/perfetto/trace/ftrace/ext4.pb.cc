// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/ftrace/ext4.proto

#include "protos/perfetto/trace/ftrace/ext4.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace perfetto {
namespace protos {
PROTOBUF_CONSTEXPR Ext4DaWriteBeginFtraceEvent::Ext4DaWriteBeginFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , pos_(int64_t{0})
  , len_(0u)
  , flags_(0u){}
struct Ext4DaWriteBeginFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DaWriteBeginFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DaWriteBeginFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DaWriteBeginFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DaWriteBeginFtraceEventDefaultTypeInternal _Ext4DaWriteBeginFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4DaWriteEndFtraceEvent::Ext4DaWriteEndFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , pos_(int64_t{0})
  , len_(0u)
  , copied_(0u){}
struct Ext4DaWriteEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DaWriteEndFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DaWriteEndFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DaWriteEndFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DaWriteEndFtraceEventDefaultTypeInternal _Ext4DaWriteEndFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4SyncFileEnterFtraceEvent::Ext4SyncFileEnterFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , parent_(uint64_t{0u})
  , datasync_(0){}
struct Ext4SyncFileEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4SyncFileEnterFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4SyncFileEnterFtraceEventDefaultTypeInternal() {}
  union {
    Ext4SyncFileEnterFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4SyncFileEnterFtraceEventDefaultTypeInternal _Ext4SyncFileEnterFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4SyncFileExitFtraceEvent::Ext4SyncFileExitFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , ret_(0){}
struct Ext4SyncFileExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4SyncFileExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4SyncFileExitFtraceEventDefaultTypeInternal() {}
  union {
    Ext4SyncFileExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4SyncFileExitFtraceEventDefaultTypeInternal _Ext4SyncFileExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4AllocDaBlocksFtraceEvent::Ext4AllocDaBlocksFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , data_blocks_(0u)
  , meta_blocks_(0u){}
struct Ext4AllocDaBlocksFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4AllocDaBlocksFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4AllocDaBlocksFtraceEventDefaultTypeInternal() {}
  union {
    Ext4AllocDaBlocksFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4AllocDaBlocksFtraceEventDefaultTypeInternal _Ext4AllocDaBlocksFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4AllocateBlocksFtraceEvent::Ext4AllocateBlocksFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , block_(uint64_t{0u})
  , len_(0u)
  , logical_(0u)
  , lleft_(0u)
  , lright_(0u)
  , goal_(uint64_t{0u})
  , pleft_(uint64_t{0u})
  , pright_(uint64_t{0u})
  , flags_(0u){}
struct Ext4AllocateBlocksFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4AllocateBlocksFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4AllocateBlocksFtraceEventDefaultTypeInternal() {}
  union {
    Ext4AllocateBlocksFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4AllocateBlocksFtraceEventDefaultTypeInternal _Ext4AllocateBlocksFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4AllocateInodeFtraceEvent::Ext4AllocateInodeFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , dir_(uint64_t{0u})
  , mode_(0u){}
struct Ext4AllocateInodeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4AllocateInodeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4AllocateInodeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4AllocateInodeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4AllocateInodeFtraceEventDefaultTypeInternal _Ext4AllocateInodeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4BeginOrderedTruncateFtraceEvent::Ext4BeginOrderedTruncateFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , new_size_(int64_t{0}){}
struct Ext4BeginOrderedTruncateFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4BeginOrderedTruncateFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4BeginOrderedTruncateFtraceEventDefaultTypeInternal() {}
  union {
    Ext4BeginOrderedTruncateFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4BeginOrderedTruncateFtraceEventDefaultTypeInternal _Ext4BeginOrderedTruncateFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4CollapseRangeFtraceEvent::Ext4CollapseRangeFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , offset_(int64_t{0})
  , len_(int64_t{0}){}
struct Ext4CollapseRangeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4CollapseRangeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4CollapseRangeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4CollapseRangeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4CollapseRangeFtraceEventDefaultTypeInternal _Ext4CollapseRangeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4DaReleaseSpaceFtraceEvent::Ext4DaReleaseSpaceFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , i_blocks_(uint64_t{0u})
  , freed_blocks_(0)
  , reserved_data_blocks_(0)
  , reserved_meta_blocks_(0)
  , allocated_meta_blocks_(0)
  , mode_(0u){}
struct Ext4DaReleaseSpaceFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DaReleaseSpaceFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DaReleaseSpaceFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DaReleaseSpaceFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DaReleaseSpaceFtraceEventDefaultTypeInternal _Ext4DaReleaseSpaceFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4DaReserveSpaceFtraceEvent::Ext4DaReserveSpaceFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , i_blocks_(uint64_t{0u})
  , reserved_data_blocks_(0)
  , reserved_meta_blocks_(0)
  , mode_(0u)
  , md_needed_(0){}
struct Ext4DaReserveSpaceFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DaReserveSpaceFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DaReserveSpaceFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DaReserveSpaceFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DaReserveSpaceFtraceEventDefaultTypeInternal _Ext4DaReserveSpaceFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4DaUpdateReserveSpaceFtraceEvent::Ext4DaUpdateReserveSpaceFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , i_blocks_(uint64_t{0u})
  , used_blocks_(0)
  , reserved_data_blocks_(0)
  , reserved_meta_blocks_(0)
  , allocated_meta_blocks_(0)
  , quota_claim_(0)
  , mode_(0u){}
struct Ext4DaUpdateReserveSpaceFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DaUpdateReserveSpaceFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DaUpdateReserveSpaceFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DaUpdateReserveSpaceFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DaUpdateReserveSpaceFtraceEventDefaultTypeInternal _Ext4DaUpdateReserveSpaceFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4DaWritePagesFtraceEvent::Ext4DaWritePagesFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , first_page_(uint64_t{0u})
  , nr_to_write_(int64_t{0})
  , b_blocknr_(uint64_t{0u})
  , sync_mode_(0)
  , b_size_(0u)
  , b_state_(0u)
  , io_done_(0)
  , pages_written_(0){}
struct Ext4DaWritePagesFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DaWritePagesFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DaWritePagesFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DaWritePagesFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DaWritePagesFtraceEventDefaultTypeInternal _Ext4DaWritePagesFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4DaWritePagesExtentFtraceEvent::Ext4DaWritePagesExtentFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , lblk_(uint64_t{0u})
  , len_(0u)
  , flags_(0u){}
struct Ext4DaWritePagesExtentFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DaWritePagesExtentFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DaWritePagesExtentFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DaWritePagesExtentFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DaWritePagesExtentFtraceEventDefaultTypeInternal _Ext4DaWritePagesExtentFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4DirectIOEnterFtraceEvent::Ext4DirectIOEnterFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , pos_(int64_t{0})
  , len_(uint64_t{0u})
  , rw_(0){}
struct Ext4DirectIOEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DirectIOEnterFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DirectIOEnterFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DirectIOEnterFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DirectIOEnterFtraceEventDefaultTypeInternal _Ext4DirectIOEnterFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4DirectIOExitFtraceEvent::Ext4DirectIOExitFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , pos_(int64_t{0})
  , len_(uint64_t{0u})
  , rw_(0)
  , ret_(0){}
struct Ext4DirectIOExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DirectIOExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DirectIOExitFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DirectIOExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DirectIOExitFtraceEventDefaultTypeInternal _Ext4DirectIOExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4DiscardBlocksFtraceEvent::Ext4DiscardBlocksFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , blk_(uint64_t{0u})
  , count_(uint64_t{0u}){}
struct Ext4DiscardBlocksFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DiscardBlocksFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DiscardBlocksFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DiscardBlocksFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DiscardBlocksFtraceEventDefaultTypeInternal _Ext4DiscardBlocksFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4DiscardPreallocationsFtraceEvent::Ext4DiscardPreallocationsFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , len_(0u)
  , needed_(0u){}
struct Ext4DiscardPreallocationsFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DiscardPreallocationsFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DiscardPreallocationsFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DiscardPreallocationsFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DiscardPreallocationsFtraceEventDefaultTypeInternal _Ext4DiscardPreallocationsFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4DropInodeFtraceEvent::Ext4DropInodeFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , drop_(0){}
struct Ext4DropInodeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4DropInodeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4DropInodeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4DropInodeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4DropInodeFtraceEventDefaultTypeInternal _Ext4DropInodeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4EsCacheExtentFtraceEvent::Ext4EsCacheExtentFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , lblk_(0u)
  , len_(0u)
  , pblk_(uint64_t{0u})
  , status_(0u){}
struct Ext4EsCacheExtentFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EsCacheExtentFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EsCacheExtentFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EsCacheExtentFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EsCacheExtentFtraceEventDefaultTypeInternal _Ext4EsCacheExtentFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4EsFindDelayedExtentRangeEnterFtraceEvent::Ext4EsFindDelayedExtentRangeEnterFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , lblk_(0u){}
struct Ext4EsFindDelayedExtentRangeEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EsFindDelayedExtentRangeEnterFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EsFindDelayedExtentRangeEnterFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EsFindDelayedExtentRangeEnterFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EsFindDelayedExtentRangeEnterFtraceEventDefaultTypeInternal _Ext4EsFindDelayedExtentRangeEnterFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4EsFindDelayedExtentRangeExitFtraceEvent::Ext4EsFindDelayedExtentRangeExitFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , lblk_(0u)
  , len_(0u)
  , pblk_(uint64_t{0u})
  , status_(uint64_t{0u}){}
struct Ext4EsFindDelayedExtentRangeExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EsFindDelayedExtentRangeExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EsFindDelayedExtentRangeExitFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EsFindDelayedExtentRangeExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EsFindDelayedExtentRangeExitFtraceEventDefaultTypeInternal _Ext4EsFindDelayedExtentRangeExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4EsInsertExtentFtraceEvent::Ext4EsInsertExtentFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , lblk_(0u)
  , len_(0u)
  , pblk_(uint64_t{0u})
  , status_(uint64_t{0u}){}
struct Ext4EsInsertExtentFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EsInsertExtentFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EsInsertExtentFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EsInsertExtentFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EsInsertExtentFtraceEventDefaultTypeInternal _Ext4EsInsertExtentFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4EsLookupExtentEnterFtraceEvent::Ext4EsLookupExtentEnterFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , lblk_(0u){}
struct Ext4EsLookupExtentEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EsLookupExtentEnterFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EsLookupExtentEnterFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EsLookupExtentEnterFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EsLookupExtentEnterFtraceEventDefaultTypeInternal _Ext4EsLookupExtentEnterFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4EsLookupExtentExitFtraceEvent::Ext4EsLookupExtentExitFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , lblk_(0u)
  , len_(0u)
  , pblk_(uint64_t{0u})
  , status_(uint64_t{0u})
  , found_(0){}
struct Ext4EsLookupExtentExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EsLookupExtentExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EsLookupExtentExitFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EsLookupExtentExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EsLookupExtentExitFtraceEventDefaultTypeInternal _Ext4EsLookupExtentExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4EsRemoveExtentFtraceEvent::Ext4EsRemoveExtentFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , lblk_(int64_t{0})
  , len_(int64_t{0}){}
struct Ext4EsRemoveExtentFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EsRemoveExtentFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EsRemoveExtentFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EsRemoveExtentFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EsRemoveExtentFtraceEventDefaultTypeInternal _Ext4EsRemoveExtentFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4EsShrinkFtraceEvent::Ext4EsShrinkFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , scan_time_(uint64_t{0u})
  , nr_shrunk_(0)
  , nr_skipped_(0)
  , retried_(0){}
struct Ext4EsShrinkFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EsShrinkFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EsShrinkFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EsShrinkFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EsShrinkFtraceEventDefaultTypeInternal _Ext4EsShrinkFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4EsShrinkCountFtraceEvent::Ext4EsShrinkCountFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , nr_to_scan_(0)
  , cache_cnt_(0){}
struct Ext4EsShrinkCountFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EsShrinkCountFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EsShrinkCountFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EsShrinkCountFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EsShrinkCountFtraceEventDefaultTypeInternal _Ext4EsShrinkCountFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4EsShrinkScanEnterFtraceEvent::Ext4EsShrinkScanEnterFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , nr_to_scan_(0)
  , cache_cnt_(0){}
struct Ext4EsShrinkScanEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EsShrinkScanEnterFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EsShrinkScanEnterFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EsShrinkScanEnterFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EsShrinkScanEnterFtraceEventDefaultTypeInternal _Ext4EsShrinkScanEnterFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4EsShrinkScanExitFtraceEvent::Ext4EsShrinkScanExitFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , nr_shrunk_(0)
  , cache_cnt_(0){}
struct Ext4EsShrinkScanExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EsShrinkScanExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EsShrinkScanExitFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EsShrinkScanExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EsShrinkScanExitFtraceEventDefaultTypeInternal _Ext4EsShrinkScanExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4EvictInodeFtraceEvent::Ext4EvictInodeFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , nlink_(0){}
struct Ext4EvictInodeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4EvictInodeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4EvictInodeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4EvictInodeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4EvictInodeFtraceEventDefaultTypeInternal _Ext4EvictInodeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4ExtConvertToInitializedEnterFtraceEvent::Ext4ExtConvertToInitializedEnterFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , m_lblk_(0u)
  , m_len_(0u)
  , u_lblk_(0u)
  , u_len_(0u)
  , u_pblk_(uint64_t{0u}){}
struct Ext4ExtConvertToInitializedEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtConvertToInitializedEnterFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtConvertToInitializedEnterFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtConvertToInitializedEnterFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtConvertToInitializedEnterFtraceEventDefaultTypeInternal _Ext4ExtConvertToInitializedEnterFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4ExtConvertToInitializedFastpathFtraceEvent::Ext4ExtConvertToInitializedFastpathFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , m_lblk_(0u)
  , m_len_(0u)
  , u_lblk_(0u)
  , u_len_(0u)
  , u_pblk_(uint64_t{0u})
  , i_lblk_(0u)
  , i_len_(0u)
  , i_pblk_(uint64_t{0u}){}
struct Ext4ExtConvertToInitializedFastpathFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtConvertToInitializedFastpathFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtConvertToInitializedFastpathFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtConvertToInitializedFastpathFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtConvertToInitializedFastpathFtraceEventDefaultTypeInternal _Ext4ExtConvertToInitializedFastpathFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4ExtHandleUnwrittenExtentsFtraceEvent::Ext4ExtHandleUnwrittenExtentsFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , flags_(0)
  , lblk_(0u)
  , pblk_(uint64_t{0u})
  , len_(0u)
  , allocated_(0u)
  , newblk_(uint64_t{0u}){}
struct Ext4ExtHandleUnwrittenExtentsFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtHandleUnwrittenExtentsFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtHandleUnwrittenExtentsFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtHandleUnwrittenExtentsFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtHandleUnwrittenExtentsFtraceEventDefaultTypeInternal _Ext4ExtHandleUnwrittenExtentsFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4ExtInCacheFtraceEvent::Ext4ExtInCacheFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , lblk_(0u)
  , ret_(0){}
struct Ext4ExtInCacheFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtInCacheFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtInCacheFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtInCacheFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtInCacheFtraceEventDefaultTypeInternal _Ext4ExtInCacheFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4ExtLoadExtentFtraceEvent::Ext4ExtLoadExtentFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , pblk_(uint64_t{0u})
  , lblk_(0u){}
struct Ext4ExtLoadExtentFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtLoadExtentFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtLoadExtentFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtLoadExtentFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtLoadExtentFtraceEventDefaultTypeInternal _Ext4ExtLoadExtentFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4ExtMapBlocksEnterFtraceEvent::Ext4ExtMapBlocksEnterFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , lblk_(0u)
  , len_(0u)
  , flags_(0u){}
struct Ext4ExtMapBlocksEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtMapBlocksEnterFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtMapBlocksEnterFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtMapBlocksEnterFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtMapBlocksEnterFtraceEventDefaultTypeInternal _Ext4ExtMapBlocksEnterFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4ExtMapBlocksExitFtraceEvent::Ext4ExtMapBlocksExitFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , pblk_(uint64_t{0u})
  , flags_(0u)
  , lblk_(0u)
  , len_(0u)
  , mflags_(0u)
  , ret_(0){}
struct Ext4ExtMapBlocksExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtMapBlocksExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtMapBlocksExitFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtMapBlocksExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtMapBlocksExitFtraceEventDefaultTypeInternal _Ext4ExtMapBlocksExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4ExtPutInCacheFtraceEvent::Ext4ExtPutInCacheFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , lblk_(0u)
  , len_(0u)
  , start_(uint64_t{0u}){}
struct Ext4ExtPutInCacheFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtPutInCacheFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtPutInCacheFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtPutInCacheFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtPutInCacheFtraceEventDefaultTypeInternal _Ext4ExtPutInCacheFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4ExtRemoveSpaceFtraceEvent::Ext4ExtRemoveSpaceFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , start_(0u)
  , end_(0u)
  , depth_(0){}
struct Ext4ExtRemoveSpaceFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtRemoveSpaceFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtRemoveSpaceFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtRemoveSpaceFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtRemoveSpaceFtraceEventDefaultTypeInternal _Ext4ExtRemoveSpaceFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4ExtRemoveSpaceDoneFtraceEvent::Ext4ExtRemoveSpaceDoneFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , start_(0u)
  , end_(0u)
  , partial_(int64_t{0})
  , depth_(0)
  , eh_entries_(0u)
  , pc_pclu_(uint64_t{0u})
  , pc_lblk_(0u)
  , pc_state_(0){}
struct Ext4ExtRemoveSpaceDoneFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtRemoveSpaceDoneFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtRemoveSpaceDoneFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtRemoveSpaceDoneFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtRemoveSpaceDoneFtraceEventDefaultTypeInternal _Ext4ExtRemoveSpaceDoneFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4ExtRmIdxFtraceEvent::Ext4ExtRmIdxFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , pblk_(uint64_t{0u}){}
struct Ext4ExtRmIdxFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtRmIdxFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtRmIdxFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtRmIdxFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtRmIdxFtraceEventDefaultTypeInternal _Ext4ExtRmIdxFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4ExtRmLeafFtraceEvent::Ext4ExtRmLeafFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , partial_(int64_t{0})
  , start_(0u)
  , ee_lblk_(0u)
  , ee_pblk_(uint64_t{0u})
  , ee_len_(0)
  , pc_lblk_(0u)
  , pc_pclu_(uint64_t{0u})
  , pc_state_(0){}
struct Ext4ExtRmLeafFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtRmLeafFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtRmLeafFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtRmLeafFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtRmLeafFtraceEventDefaultTypeInternal _Ext4ExtRmLeafFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4ExtShowExtentFtraceEvent::Ext4ExtShowExtentFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , pblk_(uint64_t{0u})
  , lblk_(0u)
  , len_(0u){}
struct Ext4ExtShowExtentFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ExtShowExtentFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ExtShowExtentFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ExtShowExtentFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ExtShowExtentFtraceEventDefaultTypeInternal _Ext4ExtShowExtentFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4FallocateEnterFtraceEvent::Ext4FallocateEnterFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , offset_(int64_t{0})
  , len_(int64_t{0})
  , pos_(int64_t{0})
  , mode_(0){}
struct Ext4FallocateEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4FallocateEnterFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4FallocateEnterFtraceEventDefaultTypeInternal() {}
  union {
    Ext4FallocateEnterFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4FallocateEnterFtraceEventDefaultTypeInternal _Ext4FallocateEnterFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4FallocateExitFtraceEvent::Ext4FallocateExitFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , pos_(int64_t{0})
  , blocks_(0u)
  , ret_(0){}
struct Ext4FallocateExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4FallocateExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4FallocateExitFtraceEventDefaultTypeInternal() {}
  union {
    Ext4FallocateExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4FallocateExitFtraceEventDefaultTypeInternal _Ext4FallocateExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4FindDelallocRangeFtraceEvent::Ext4FindDelallocRangeFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , from_(0u)
  , to_(0u)
  , reverse_(0)
  , found_(0)
  , found_blk_(0u){}
struct Ext4FindDelallocRangeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4FindDelallocRangeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4FindDelallocRangeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4FindDelallocRangeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4FindDelallocRangeFtraceEventDefaultTypeInternal _Ext4FindDelallocRangeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4ForgetFtraceEvent::Ext4ForgetFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , block_(uint64_t{0u})
  , is_metadata_(0)
  , mode_(0u){}
struct Ext4ForgetFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ForgetFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ForgetFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ForgetFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ForgetFtraceEventDefaultTypeInternal _Ext4ForgetFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4FreeBlocksFtraceEvent::Ext4FreeBlocksFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , block_(uint64_t{0u})
  , count_(uint64_t{0u})
  , flags_(0)
  , mode_(0u){}
struct Ext4FreeBlocksFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4FreeBlocksFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4FreeBlocksFtraceEventDefaultTypeInternal() {}
  union {
    Ext4FreeBlocksFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4FreeBlocksFtraceEventDefaultTypeInternal _Ext4FreeBlocksFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4FreeInodeFtraceEvent::Ext4FreeInodeFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , uid_(0u)
  , gid_(0u)
  , blocks_(uint64_t{0u})
  , mode_(0u){}
struct Ext4FreeInodeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4FreeInodeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4FreeInodeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4FreeInodeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4FreeInodeFtraceEventDefaultTypeInternal _Ext4FreeInodeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4GetImpliedClusterAllocExitFtraceEvent::Ext4GetImpliedClusterAllocExitFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , flags_(0u)
  , lblk_(0u)
  , pblk_(uint64_t{0u})
  , len_(0u)
  , ret_(0){}
struct Ext4GetImpliedClusterAllocExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4GetImpliedClusterAllocExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4GetImpliedClusterAllocExitFtraceEventDefaultTypeInternal() {}
  union {
    Ext4GetImpliedClusterAllocExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4GetImpliedClusterAllocExitFtraceEventDefaultTypeInternal _Ext4GetImpliedClusterAllocExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4GetReservedClusterAllocFtraceEvent::Ext4GetReservedClusterAllocFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , lblk_(0u)
  , len_(0u){}
struct Ext4GetReservedClusterAllocFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4GetReservedClusterAllocFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4GetReservedClusterAllocFtraceEventDefaultTypeInternal() {}
  union {
    Ext4GetReservedClusterAllocFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4GetReservedClusterAllocFtraceEventDefaultTypeInternal _Ext4GetReservedClusterAllocFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4IndMapBlocksEnterFtraceEvent::Ext4IndMapBlocksEnterFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , lblk_(0u)
  , len_(0u)
  , flags_(0u){}
struct Ext4IndMapBlocksEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4IndMapBlocksEnterFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4IndMapBlocksEnterFtraceEventDefaultTypeInternal() {}
  union {
    Ext4IndMapBlocksEnterFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4IndMapBlocksEnterFtraceEventDefaultTypeInternal _Ext4IndMapBlocksEnterFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4IndMapBlocksExitFtraceEvent::Ext4IndMapBlocksExitFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , pblk_(uint64_t{0u})
  , flags_(0u)
  , lblk_(0u)
  , len_(0u)
  , mflags_(0u)
  , ret_(0){}
struct Ext4IndMapBlocksExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4IndMapBlocksExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4IndMapBlocksExitFtraceEventDefaultTypeInternal() {}
  union {
    Ext4IndMapBlocksExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4IndMapBlocksExitFtraceEventDefaultTypeInternal _Ext4IndMapBlocksExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4InsertRangeFtraceEvent::Ext4InsertRangeFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , offset_(int64_t{0})
  , len_(int64_t{0}){}
struct Ext4InsertRangeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4InsertRangeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4InsertRangeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4InsertRangeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4InsertRangeFtraceEventDefaultTypeInternal _Ext4InsertRangeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4InvalidatepageFtraceEvent::Ext4InvalidatepageFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , index_(uint64_t{0u})
  , offset_(uint64_t{0u})
  , length_(0u){}
struct Ext4InvalidatepageFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4InvalidatepageFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4InvalidatepageFtraceEventDefaultTypeInternal() {}
  union {
    Ext4InvalidatepageFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4InvalidatepageFtraceEventDefaultTypeInternal _Ext4InvalidatepageFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4JournalStartFtraceEvent::Ext4JournalStartFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ip_(uint64_t{0u})
  , blocks_(0)
  , rsv_blocks_(0)
  , nblocks_(0)
  , revoke_creds_(0){}
struct Ext4JournalStartFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4JournalStartFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4JournalStartFtraceEventDefaultTypeInternal() {}
  union {
    Ext4JournalStartFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4JournalStartFtraceEventDefaultTypeInternal _Ext4JournalStartFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4JournalStartReservedFtraceEvent::Ext4JournalStartReservedFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ip_(uint64_t{0u})
  , blocks_(0){}
struct Ext4JournalStartReservedFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4JournalStartReservedFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4JournalStartReservedFtraceEventDefaultTypeInternal() {}
  union {
    Ext4JournalStartReservedFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4JournalStartReservedFtraceEventDefaultTypeInternal _Ext4JournalStartReservedFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4JournalledInvalidatepageFtraceEvent::Ext4JournalledInvalidatepageFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , index_(uint64_t{0u})
  , offset_(uint64_t{0u})
  , length_(0u){}
struct Ext4JournalledInvalidatepageFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4JournalledInvalidatepageFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4JournalledInvalidatepageFtraceEventDefaultTypeInternal() {}
  union {
    Ext4JournalledInvalidatepageFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4JournalledInvalidatepageFtraceEventDefaultTypeInternal _Ext4JournalledInvalidatepageFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4JournalledWriteEndFtraceEvent::Ext4JournalledWriteEndFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , pos_(int64_t{0})
  , len_(0u)
  , copied_(0u){}
struct Ext4JournalledWriteEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4JournalledWriteEndFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4JournalledWriteEndFtraceEventDefaultTypeInternal() {}
  union {
    Ext4JournalledWriteEndFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4JournalledWriteEndFtraceEventDefaultTypeInternal _Ext4JournalledWriteEndFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4LoadInodeFtraceEvent::Ext4LoadInodeFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u}){}
struct Ext4LoadInodeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4LoadInodeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4LoadInodeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4LoadInodeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4LoadInodeFtraceEventDefaultTypeInternal _Ext4LoadInodeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4LoadInodeBitmapFtraceEvent::Ext4LoadInodeBitmapFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , group_(0u){}
struct Ext4LoadInodeBitmapFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4LoadInodeBitmapFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4LoadInodeBitmapFtraceEventDefaultTypeInternal() {}
  union {
    Ext4LoadInodeBitmapFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4LoadInodeBitmapFtraceEventDefaultTypeInternal _Ext4LoadInodeBitmapFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4MarkInodeDirtyFtraceEvent::Ext4MarkInodeDirtyFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , ip_(uint64_t{0u}){}
struct Ext4MarkInodeDirtyFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MarkInodeDirtyFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MarkInodeDirtyFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MarkInodeDirtyFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MarkInodeDirtyFtraceEventDefaultTypeInternal _Ext4MarkInodeDirtyFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4MbBitmapLoadFtraceEvent::Ext4MbBitmapLoadFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , group_(0u){}
struct Ext4MbBitmapLoadFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MbBitmapLoadFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MbBitmapLoadFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MbBitmapLoadFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MbBitmapLoadFtraceEventDefaultTypeInternal _Ext4MbBitmapLoadFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4MbBuddyBitmapLoadFtraceEvent::Ext4MbBuddyBitmapLoadFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , group_(0u){}
struct Ext4MbBuddyBitmapLoadFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MbBuddyBitmapLoadFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MbBuddyBitmapLoadFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MbBuddyBitmapLoadFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MbBuddyBitmapLoadFtraceEventDefaultTypeInternal _Ext4MbBuddyBitmapLoadFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4MbDiscardPreallocationsFtraceEvent::Ext4MbDiscardPreallocationsFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , needed_(0){}
struct Ext4MbDiscardPreallocationsFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MbDiscardPreallocationsFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MbDiscardPreallocationsFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MbDiscardPreallocationsFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MbDiscardPreallocationsFtraceEventDefaultTypeInternal _Ext4MbDiscardPreallocationsFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4MbNewGroupPaFtraceEvent::Ext4MbNewGroupPaFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , pa_pstart_(uint64_t{0u})
  , pa_lstart_(uint64_t{0u})
  , pa_len_(0u){}
struct Ext4MbNewGroupPaFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MbNewGroupPaFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MbNewGroupPaFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MbNewGroupPaFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MbNewGroupPaFtraceEventDefaultTypeInternal _Ext4MbNewGroupPaFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4MbNewInodePaFtraceEvent::Ext4MbNewInodePaFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , pa_pstart_(uint64_t{0u})
  , pa_lstart_(uint64_t{0u})
  , pa_len_(0u){}
struct Ext4MbNewInodePaFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MbNewInodePaFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MbNewInodePaFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MbNewInodePaFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MbNewInodePaFtraceEventDefaultTypeInternal _Ext4MbNewInodePaFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4MbReleaseGroupPaFtraceEvent::Ext4MbReleaseGroupPaFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , pa_pstart_(uint64_t{0u})
  , pa_len_(0u){}
struct Ext4MbReleaseGroupPaFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MbReleaseGroupPaFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MbReleaseGroupPaFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MbReleaseGroupPaFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MbReleaseGroupPaFtraceEventDefaultTypeInternal _Ext4MbReleaseGroupPaFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4MbReleaseInodePaFtraceEvent::Ext4MbReleaseInodePaFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , block_(uint64_t{0u})
  , count_(0u){}
struct Ext4MbReleaseInodePaFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MbReleaseInodePaFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MbReleaseInodePaFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MbReleaseInodePaFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MbReleaseInodePaFtraceEventDefaultTypeInternal _Ext4MbReleaseInodePaFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4MballocAllocFtraceEvent::Ext4MballocAllocFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , orig_logical_(0u)
  , orig_start_(0)
  , orig_group_(0u)
  , orig_len_(0)
  , goal_logical_(0u)
  , goal_start_(0)
  , goal_group_(0u)
  , goal_len_(0)
  , result_logical_(0u)
  , result_start_(0)
  , result_group_(0u)
  , result_len_(0)
  , found_(0u)
  , groups_(0u)
  , buddy_(0u)
  , flags_(0u)
  , tail_(0u)
  , cr_(0u){}
struct Ext4MballocAllocFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MballocAllocFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MballocAllocFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MballocAllocFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MballocAllocFtraceEventDefaultTypeInternal _Ext4MballocAllocFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4MballocDiscardFtraceEvent::Ext4MballocDiscardFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , result_start_(0)
  , result_group_(0u)
  , result_len_(0){}
struct Ext4MballocDiscardFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MballocDiscardFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MballocDiscardFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MballocDiscardFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MballocDiscardFtraceEventDefaultTypeInternal _Ext4MballocDiscardFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4MballocFreeFtraceEvent::Ext4MballocFreeFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , result_start_(0)
  , result_group_(0u)
  , result_len_(0){}
struct Ext4MballocFreeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MballocFreeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MballocFreeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MballocFreeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MballocFreeFtraceEventDefaultTypeInternal _Ext4MballocFreeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4MballocPreallocFtraceEvent::Ext4MballocPreallocFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , orig_logical_(0u)
  , orig_start_(0)
  , orig_group_(0u)
  , orig_len_(0)
  , result_logical_(0u)
  , result_start_(0)
  , result_group_(0u)
  , result_len_(0){}
struct Ext4MballocPreallocFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4MballocPreallocFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4MballocPreallocFtraceEventDefaultTypeInternal() {}
  union {
    Ext4MballocPreallocFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4MballocPreallocFtraceEventDefaultTypeInternal _Ext4MballocPreallocFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4OtherInodeUpdateTimeFtraceEvent::Ext4OtherInodeUpdateTimeFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , orig_ino_(uint64_t{0u})
  , uid_(0u)
  , gid_(0u)
  , mode_(0u){}
struct Ext4OtherInodeUpdateTimeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4OtherInodeUpdateTimeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4OtherInodeUpdateTimeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4OtherInodeUpdateTimeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4OtherInodeUpdateTimeFtraceEventDefaultTypeInternal _Ext4OtherInodeUpdateTimeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4PunchHoleFtraceEvent::Ext4PunchHoleFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , offset_(int64_t{0})
  , len_(int64_t{0})
  , mode_(0){}
struct Ext4PunchHoleFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4PunchHoleFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4PunchHoleFtraceEventDefaultTypeInternal() {}
  union {
    Ext4PunchHoleFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4PunchHoleFtraceEventDefaultTypeInternal _Ext4PunchHoleFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4ReadBlockBitmapLoadFtraceEvent::Ext4ReadBlockBitmapLoadFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , group_(0u)
  , prefetch_(0u){}
struct Ext4ReadBlockBitmapLoadFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ReadBlockBitmapLoadFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ReadBlockBitmapLoadFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ReadBlockBitmapLoadFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ReadBlockBitmapLoadFtraceEventDefaultTypeInternal _Ext4ReadBlockBitmapLoadFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4ReadpageFtraceEvent::Ext4ReadpageFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , index_(uint64_t{0u}){}
struct Ext4ReadpageFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ReadpageFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ReadpageFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ReadpageFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ReadpageFtraceEventDefaultTypeInternal _Ext4ReadpageFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4ReleasepageFtraceEvent::Ext4ReleasepageFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , index_(uint64_t{0u}){}
struct Ext4ReleasepageFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ReleasepageFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ReleasepageFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ReleasepageFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ReleasepageFtraceEventDefaultTypeInternal _Ext4ReleasepageFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4RemoveBlocksFtraceEvent::Ext4RemoveBlocksFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , from_(0u)
  , to_(0u)
  , partial_(int64_t{0})
  , ee_pblk_(uint64_t{0u})
  , ee_lblk_(0u)
  , ee_len_(0u)
  , pc_pclu_(uint64_t{0u})
  , pc_lblk_(0u)
  , pc_state_(0){}
struct Ext4RemoveBlocksFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4RemoveBlocksFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4RemoveBlocksFtraceEventDefaultTypeInternal() {}
  union {
    Ext4RemoveBlocksFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4RemoveBlocksFtraceEventDefaultTypeInternal _Ext4RemoveBlocksFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4RequestBlocksFtraceEvent::Ext4RequestBlocksFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , len_(0u)
  , logical_(0u)
  , lleft_(0u)
  , lright_(0u)
  , goal_(uint64_t{0u})
  , pleft_(uint64_t{0u})
  , pright_(uint64_t{0u})
  , flags_(0u){}
struct Ext4RequestBlocksFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4RequestBlocksFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4RequestBlocksFtraceEventDefaultTypeInternal() {}
  union {
    Ext4RequestBlocksFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4RequestBlocksFtraceEventDefaultTypeInternal _Ext4RequestBlocksFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4RequestInodeFtraceEvent::Ext4RequestInodeFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , dir_(uint64_t{0u})
  , mode_(0u){}
struct Ext4RequestInodeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4RequestInodeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4RequestInodeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4RequestInodeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4RequestInodeFtraceEventDefaultTypeInternal _Ext4RequestInodeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4SyncFsFtraceEvent::Ext4SyncFsFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , wait_(0){}
struct Ext4SyncFsFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4SyncFsFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4SyncFsFtraceEventDefaultTypeInternal() {}
  union {
    Ext4SyncFsFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4SyncFsFtraceEventDefaultTypeInternal _Ext4SyncFsFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4TrimAllFreeFtraceEvent::Ext4TrimAllFreeFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_major_(0)
  , dev_minor_(0)
  , group_(0u)
  , start_(0)
  , len_(0){}
struct Ext4TrimAllFreeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4TrimAllFreeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4TrimAllFreeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4TrimAllFreeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4TrimAllFreeFtraceEventDefaultTypeInternal _Ext4TrimAllFreeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4TrimExtentFtraceEvent::Ext4TrimExtentFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_major_(0)
  , dev_minor_(0)
  , group_(0u)
  , start_(0)
  , len_(0){}
struct Ext4TrimExtentFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4TrimExtentFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4TrimExtentFtraceEventDefaultTypeInternal() {}
  union {
    Ext4TrimExtentFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4TrimExtentFtraceEventDefaultTypeInternal _Ext4TrimExtentFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4TruncateEnterFtraceEvent::Ext4TruncateEnterFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , blocks_(uint64_t{0u}){}
struct Ext4TruncateEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4TruncateEnterFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4TruncateEnterFtraceEventDefaultTypeInternal() {}
  union {
    Ext4TruncateEnterFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4TruncateEnterFtraceEventDefaultTypeInternal _Ext4TruncateEnterFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4TruncateExitFtraceEvent::Ext4TruncateExitFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , blocks_(uint64_t{0u}){}
struct Ext4TruncateExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4TruncateExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4TruncateExitFtraceEventDefaultTypeInternal() {}
  union {
    Ext4TruncateExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4TruncateExitFtraceEventDefaultTypeInternal _Ext4TruncateExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4UnlinkEnterFtraceEvent::Ext4UnlinkEnterFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , parent_(uint64_t{0u})
  , size_(int64_t{0}){}
struct Ext4UnlinkEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4UnlinkEnterFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4UnlinkEnterFtraceEventDefaultTypeInternal() {}
  union {
    Ext4UnlinkEnterFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4UnlinkEnterFtraceEventDefaultTypeInternal _Ext4UnlinkEnterFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4UnlinkExitFtraceEvent::Ext4UnlinkExitFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , ret_(0){}
struct Ext4UnlinkExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4UnlinkExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4UnlinkExitFtraceEventDefaultTypeInternal() {}
  union {
    Ext4UnlinkExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4UnlinkExitFtraceEventDefaultTypeInternal _Ext4UnlinkExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4WriteBeginFtraceEvent::Ext4WriteBeginFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , pos_(int64_t{0})
  , len_(0u)
  , flags_(0u){}
struct Ext4WriteBeginFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4WriteBeginFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4WriteBeginFtraceEventDefaultTypeInternal() {}
  union {
    Ext4WriteBeginFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4WriteBeginFtraceEventDefaultTypeInternal _Ext4WriteBeginFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4WriteEndFtraceEvent::Ext4WriteEndFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , pos_(int64_t{0})
  , len_(0u)
  , copied_(0u){}
struct Ext4WriteEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4WriteEndFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4WriteEndFtraceEventDefaultTypeInternal() {}
  union {
    Ext4WriteEndFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4WriteEndFtraceEventDefaultTypeInternal _Ext4WriteEndFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4WritepageFtraceEvent::Ext4WritepageFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , index_(uint64_t{0u}){}
struct Ext4WritepageFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4WritepageFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4WritepageFtraceEventDefaultTypeInternal() {}
  union {
    Ext4WritepageFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4WritepageFtraceEventDefaultTypeInternal _Ext4WritepageFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4WritepagesFtraceEvent::Ext4WritepagesFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , nr_to_write_(int64_t{0})
  , pages_skipped_(int64_t{0})
  , range_start_(int64_t{0})
  , range_end_(int64_t{0})
  , writeback_index_(uint64_t{0u})
  , sync_mode_(0)
  , for_kupdate_(0u)
  , range_cyclic_(0u){}
struct Ext4WritepagesFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4WritepagesFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4WritepagesFtraceEventDefaultTypeInternal() {}
  union {
    Ext4WritepagesFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4WritepagesFtraceEventDefaultTypeInternal _Ext4WritepagesFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4WritepagesResultFtraceEvent::Ext4WritepagesResultFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , ret_(0)
  , pages_written_(0)
  , pages_skipped_(int64_t{0})
  , writeback_index_(uint64_t{0u})
  , sync_mode_(0){}
struct Ext4WritepagesResultFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4WritepagesResultFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4WritepagesResultFtraceEventDefaultTypeInternal() {}
  union {
    Ext4WritepagesResultFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4WritepagesResultFtraceEventDefaultTypeInternal _Ext4WritepagesResultFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR Ext4ZeroRangeFtraceEvent::Ext4ZeroRangeFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , offset_(int64_t{0})
  , len_(int64_t{0})
  , mode_(0){}
struct Ext4ZeroRangeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Ext4ZeroRangeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Ext4ZeroRangeFtraceEventDefaultTypeInternal() {}
  union {
    Ext4ZeroRangeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Ext4ZeroRangeFtraceEventDefaultTypeInternal _Ext4ZeroRangeFtraceEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
namespace perfetto {
namespace protos {

// ===================================================================

class Ext4DaWriteBeginFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DaWriteBeginFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4DaWriteBeginFtraceEvent::Ext4DaWriteBeginFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
}
Ext4DaWriteBeginFtraceEvent::Ext4DaWriteBeginFtraceEvent(const Ext4DaWriteBeginFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
}

inline void Ext4DaWriteBeginFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
}

Ext4DaWriteBeginFtraceEvent::~Ext4DaWriteBeginFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DaWriteBeginFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DaWriteBeginFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4DaWriteBeginFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flags_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4DaWriteBeginFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4DaWriteBeginFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_pos(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_len(), target);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
  return target;
}

size_t Ext4DaWriteBeginFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_pos());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DaWriteBeginFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4DaWriteBeginFtraceEvent*>(
      &from));
}

void Ext4DaWriteBeginFtraceEvent::MergeFrom(const Ext4DaWriteBeginFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pos_ = from.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      flags_ = from.flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4DaWriteBeginFtraceEvent::CopyFrom(const Ext4DaWriteBeginFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DaWriteBeginFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DaWriteBeginFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DaWriteBeginFtraceEvent::InternalSwap(Ext4DaWriteBeginFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DaWriteBeginFtraceEvent, flags_)
      + sizeof(Ext4DaWriteBeginFtraceEvent::flags_)
      - PROTOBUF_FIELD_OFFSET(Ext4DaWriteBeginFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4DaWriteBeginFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DaWriteBeginFtraceEvent";
}


// ===================================================================

class Ext4DaWriteEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DaWriteEndFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_copied(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4DaWriteEndFtraceEvent::Ext4DaWriteEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DaWriteEndFtraceEvent)
}
Ext4DaWriteEndFtraceEvent::Ext4DaWriteEndFtraceEvent(const Ext4DaWriteEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&copied_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(copied_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DaWriteEndFtraceEvent)
}

inline void Ext4DaWriteEndFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&copied_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(copied_));
}

Ext4DaWriteEndFtraceEvent::~Ext4DaWriteEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DaWriteEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DaWriteEndFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DaWriteEndFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4DaWriteEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DaWriteEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&copied_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(copied_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4DaWriteEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 copied = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_copied(&has_bits);
          copied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4DaWriteEndFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DaWriteEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_pos(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_len(), target);
  }

  // optional uint32 copied = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_copied(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DaWriteEndFtraceEvent)
  return target;
}

size_t Ext4DaWriteEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DaWriteEndFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_pos());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint32 copied = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_copied());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DaWriteEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4DaWriteEndFtraceEvent*>(
      &from));
}

void Ext4DaWriteEndFtraceEvent::MergeFrom(const Ext4DaWriteEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DaWriteEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pos_ = from.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      copied_ = from.copied_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4DaWriteEndFtraceEvent::CopyFrom(const Ext4DaWriteEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DaWriteEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DaWriteEndFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DaWriteEndFtraceEvent::InternalSwap(Ext4DaWriteEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DaWriteEndFtraceEvent, copied_)
      + sizeof(Ext4DaWriteEndFtraceEvent::copied_)
      - PROTOBUF_FIELD_OFFSET(Ext4DaWriteEndFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4DaWriteEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DaWriteEndFtraceEvent";
}


// ===================================================================

class Ext4SyncFileEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4SyncFileEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_datasync(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4SyncFileEnterFtraceEvent::Ext4SyncFileEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
}
Ext4SyncFileEnterFtraceEvent::Ext4SyncFileEnterFtraceEvent(const Ext4SyncFileEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&datasync_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(datasync_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
}

inline void Ext4SyncFileEnterFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&datasync_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(datasync_));
}

Ext4SyncFileEnterFtraceEvent::~Ext4SyncFileEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4SyncFileEnterFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4SyncFileEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4SyncFileEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&datasync_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(datasync_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4SyncFileEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 parent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_parent(&has_bits);
          parent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 datasync = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_datasync(&has_bits);
          datasync_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4SyncFileEnterFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 parent = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_parent(), target);
  }

  // optional int32 datasync = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_datasync(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
  return target;
}

size_t Ext4SyncFileEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 parent = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_parent());
    }

    // optional int32 datasync = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_datasync());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4SyncFileEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4SyncFileEnterFtraceEvent*>(
      &from));
}

void Ext4SyncFileEnterFtraceEvent::MergeFrom(const Ext4SyncFileEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      parent_ = from.parent_;
    }
    if (cached_has_bits & 0x00000008u) {
      datasync_ = from.datasync_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4SyncFileEnterFtraceEvent::CopyFrom(const Ext4SyncFileEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4SyncFileEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4SyncFileEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4SyncFileEnterFtraceEvent::InternalSwap(Ext4SyncFileEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4SyncFileEnterFtraceEvent, datasync_)
      + sizeof(Ext4SyncFileEnterFtraceEvent::datasync_)
      - PROTOBUF_FIELD_OFFSET(Ext4SyncFileEnterFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4SyncFileEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4SyncFileEnterFtraceEvent";
}


// ===================================================================

class Ext4SyncFileExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4SyncFileExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4SyncFileExitFtraceEvent::Ext4SyncFileExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4SyncFileExitFtraceEvent)
}
Ext4SyncFileExitFtraceEvent::Ext4SyncFileExitFtraceEvent(const Ext4SyncFileExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4SyncFileExitFtraceEvent)
}

inline void Ext4SyncFileExitFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
}

Ext4SyncFileExitFtraceEvent::~Ext4SyncFileExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4SyncFileExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4SyncFileExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4SyncFileExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4SyncFileExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4SyncFileExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ret_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4SyncFileExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4SyncFileExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4SyncFileExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 ret = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4SyncFileExitFtraceEvent)
  return target;
}

size_t Ext4SyncFileExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4SyncFileExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 ret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4SyncFileExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4SyncFileExitFtraceEvent*>(
      &from));
}

void Ext4SyncFileExitFtraceEvent::MergeFrom(const Ext4SyncFileExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4SyncFileExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      ret_ = from.ret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4SyncFileExitFtraceEvent::CopyFrom(const Ext4SyncFileExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4SyncFileExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4SyncFileExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4SyncFileExitFtraceEvent::InternalSwap(Ext4SyncFileExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4SyncFileExitFtraceEvent, ret_)
      + sizeof(Ext4SyncFileExitFtraceEvent::ret_)
      - PROTOBUF_FIELD_OFFSET(Ext4SyncFileExitFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4SyncFileExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4SyncFileExitFtraceEvent";
}


// ===================================================================

class Ext4AllocDaBlocksFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4AllocDaBlocksFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_data_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_meta_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4AllocDaBlocksFtraceEvent::Ext4AllocDaBlocksFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
}
Ext4AllocDaBlocksFtraceEvent::Ext4AllocDaBlocksFtraceEvent(const Ext4AllocDaBlocksFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&meta_blocks_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(meta_blocks_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
}

inline void Ext4AllocDaBlocksFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&meta_blocks_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(meta_blocks_));
}

Ext4AllocDaBlocksFtraceEvent::~Ext4AllocDaBlocksFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4AllocDaBlocksFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4AllocDaBlocksFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4AllocDaBlocksFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&meta_blocks_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(meta_blocks_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4AllocDaBlocksFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 data_blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_data_blocks(&has_bits);
          data_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 meta_blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_meta_blocks(&has_bits);
          meta_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4AllocDaBlocksFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 data_blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_data_blocks(), target);
  }

  // optional uint32 meta_blocks = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_meta_blocks(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
  return target;
}

size_t Ext4AllocDaBlocksFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 data_blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_data_blocks());
    }

    // optional uint32 meta_blocks = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_meta_blocks());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4AllocDaBlocksFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4AllocDaBlocksFtraceEvent*>(
      &from));
}

void Ext4AllocDaBlocksFtraceEvent::MergeFrom(const Ext4AllocDaBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      data_blocks_ = from.data_blocks_;
    }
    if (cached_has_bits & 0x00000008u) {
      meta_blocks_ = from.meta_blocks_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4AllocDaBlocksFtraceEvent::CopyFrom(const Ext4AllocDaBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4AllocDaBlocksFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4AllocDaBlocksFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4AllocDaBlocksFtraceEvent::InternalSwap(Ext4AllocDaBlocksFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4AllocDaBlocksFtraceEvent, meta_blocks_)
      + sizeof(Ext4AllocDaBlocksFtraceEvent::meta_blocks_)
      - PROTOBUF_FIELD_OFFSET(Ext4AllocDaBlocksFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4AllocDaBlocksFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4AllocDaBlocksFtraceEvent";
}


// ===================================================================

class Ext4AllocateBlocksFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4AllocateBlocksFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_block(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_logical(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_lleft(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_lright(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_goal(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_pleft(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_pright(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

Ext4AllocateBlocksFtraceEvent::Ext4AllocateBlocksFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
}
Ext4AllocateBlocksFtraceEvent::Ext4AllocateBlocksFtraceEvent(const Ext4AllocateBlocksFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
}

inline void Ext4AllocateBlocksFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
}

Ext4AllocateBlocksFtraceEvent::~Ext4AllocateBlocksFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4AllocateBlocksFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4AllocateBlocksFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4AllocateBlocksFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&goal_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(goal_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&pleft_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flags_) -
        reinterpret_cast<char*>(&pleft_)) + sizeof(flags_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4AllocateBlocksFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 block = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_block(&has_bits);
          block_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 logical = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_logical(&has_bits);
          logical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lleft = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_lleft(&has_bits);
          lleft_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lright = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_lright(&has_bits);
          lright_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 goal = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_goal(&has_bits);
          goal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pleft = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_pleft(&has_bits);
          pleft_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pright = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_pright(&has_bits);
          pright_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4AllocateBlocksFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 block = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_block(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_len(), target);
  }

  // optional uint32 logical = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_logical(), target);
  }

  // optional uint32 lleft = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_lleft(), target);
  }

  // optional uint32 lright = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_lright(), target);
  }

  // optional uint64 goal = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_goal(), target);
  }

  // optional uint64 pleft = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_pleft(), target);
  }

  // optional uint64 pright = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(10, this->_internal_pright(), target);
  }

  // optional uint32 flags = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
  return target;
}

size_t Ext4AllocateBlocksFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 block = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_block());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint32 logical = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_logical());
    }

    // optional uint32 lleft = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lleft());
    }

    // optional uint32 lright = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lright());
    }

    // optional uint64 goal = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_goal());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional uint64 pleft = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pleft());
    }

    // optional uint64 pright = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pright());
    }

    // optional uint32 flags = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4AllocateBlocksFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4AllocateBlocksFtraceEvent*>(
      &from));
}

void Ext4AllocateBlocksFtraceEvent::MergeFrom(const Ext4AllocateBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      block_ = from.block_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      logical_ = from.logical_;
    }
    if (cached_has_bits & 0x00000020u) {
      lleft_ = from.lleft_;
    }
    if (cached_has_bits & 0x00000040u) {
      lright_ = from.lright_;
    }
    if (cached_has_bits & 0x00000080u) {
      goal_ = from.goal_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      pleft_ = from.pleft_;
    }
    if (cached_has_bits & 0x00000200u) {
      pright_ = from.pright_;
    }
    if (cached_has_bits & 0x00000400u) {
      flags_ = from.flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4AllocateBlocksFtraceEvent::CopyFrom(const Ext4AllocateBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4AllocateBlocksFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4AllocateBlocksFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4AllocateBlocksFtraceEvent::InternalSwap(Ext4AllocateBlocksFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4AllocateBlocksFtraceEvent, flags_)
      + sizeof(Ext4AllocateBlocksFtraceEvent::flags_)
      - PROTOBUF_FIELD_OFFSET(Ext4AllocateBlocksFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4AllocateBlocksFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4AllocateBlocksFtraceEvent";
}


// ===================================================================

class Ext4AllocateInodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4AllocateInodeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4AllocateInodeFtraceEvent::Ext4AllocateInodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4AllocateInodeFtraceEvent)
}
Ext4AllocateInodeFtraceEvent::Ext4AllocateInodeFtraceEvent(const Ext4AllocateInodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4AllocateInodeFtraceEvent)
}

inline void Ext4AllocateInodeFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
}

Ext4AllocateInodeFtraceEvent::~Ext4AllocateInodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4AllocateInodeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4AllocateInodeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4AllocateInodeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4AllocateInodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4AllocateInodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4AllocateInodeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 dir = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_dir(&has_bits);
          dir_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4AllocateInodeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4AllocateInodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 dir = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_dir(), target);
  }

  // optional uint32 mode = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4AllocateInodeFtraceEvent)
  return target;
}

size_t Ext4AllocateInodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4AllocateInodeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 dir = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dir());
    }

    // optional uint32 mode = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4AllocateInodeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4AllocateInodeFtraceEvent*>(
      &from));
}

void Ext4AllocateInodeFtraceEvent::MergeFrom(const Ext4AllocateInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4AllocateInodeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      dir_ = from.dir_;
    }
    if (cached_has_bits & 0x00000008u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4AllocateInodeFtraceEvent::CopyFrom(const Ext4AllocateInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4AllocateInodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4AllocateInodeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4AllocateInodeFtraceEvent::InternalSwap(Ext4AllocateInodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4AllocateInodeFtraceEvent, mode_)
      + sizeof(Ext4AllocateInodeFtraceEvent::mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4AllocateInodeFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4AllocateInodeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4AllocateInodeFtraceEvent";
}


// ===================================================================

class Ext4BeginOrderedTruncateFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4BeginOrderedTruncateFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_new_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4BeginOrderedTruncateFtraceEvent::Ext4BeginOrderedTruncateFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
}
Ext4BeginOrderedTruncateFtraceEvent::Ext4BeginOrderedTruncateFtraceEvent(const Ext4BeginOrderedTruncateFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&new_size_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(new_size_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
}

inline void Ext4BeginOrderedTruncateFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&new_size_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(new_size_));
}

Ext4BeginOrderedTruncateFtraceEvent::~Ext4BeginOrderedTruncateFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4BeginOrderedTruncateFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4BeginOrderedTruncateFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4BeginOrderedTruncateFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&new_size_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(new_size_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4BeginOrderedTruncateFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 new_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_new_size(&has_bits);
          new_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4BeginOrderedTruncateFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 new_size = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_new_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
  return target;
}

size_t Ext4BeginOrderedTruncateFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 new_size = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_new_size());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4BeginOrderedTruncateFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4BeginOrderedTruncateFtraceEvent*>(
      &from));
}

void Ext4BeginOrderedTruncateFtraceEvent::MergeFrom(const Ext4BeginOrderedTruncateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      new_size_ = from.new_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4BeginOrderedTruncateFtraceEvent::CopyFrom(const Ext4BeginOrderedTruncateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4BeginOrderedTruncateFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4BeginOrderedTruncateFtraceEvent::InternalSwap(Ext4BeginOrderedTruncateFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4BeginOrderedTruncateFtraceEvent, new_size_)
      + sizeof(Ext4BeginOrderedTruncateFtraceEvent::new_size_)
      - PROTOBUF_FIELD_OFFSET(Ext4BeginOrderedTruncateFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4BeginOrderedTruncateFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4BeginOrderedTruncateFtraceEvent";
}


// ===================================================================

class Ext4CollapseRangeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4CollapseRangeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4CollapseRangeFtraceEvent::Ext4CollapseRangeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4CollapseRangeFtraceEvent)
}
Ext4CollapseRangeFtraceEvent::Ext4CollapseRangeFtraceEvent(const Ext4CollapseRangeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4CollapseRangeFtraceEvent)
}

inline void Ext4CollapseRangeFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(len_));
}

Ext4CollapseRangeFtraceEvent::~Ext4CollapseRangeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4CollapseRangeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4CollapseRangeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4CollapseRangeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4CollapseRangeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4CollapseRangeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4CollapseRangeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4CollapseRangeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4CollapseRangeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 offset = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_offset(), target);
  }

  // optional int64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4CollapseRangeFtraceEvent)
  return target;
}

size_t Ext4CollapseRangeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4CollapseRangeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 offset = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_offset());
    }

    // optional int64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4CollapseRangeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4CollapseRangeFtraceEvent*>(
      &from));
}

void Ext4CollapseRangeFtraceEvent::MergeFrom(const Ext4CollapseRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4CollapseRangeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4CollapseRangeFtraceEvent::CopyFrom(const Ext4CollapseRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4CollapseRangeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4CollapseRangeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4CollapseRangeFtraceEvent::InternalSwap(Ext4CollapseRangeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4CollapseRangeFtraceEvent, len_)
      + sizeof(Ext4CollapseRangeFtraceEvent::len_)
      - PROTOBUF_FIELD_OFFSET(Ext4CollapseRangeFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4CollapseRangeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4CollapseRangeFtraceEvent";
}


// ===================================================================

class Ext4DaReleaseSpaceFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DaReleaseSpaceFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_i_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_freed_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_reserved_data_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_reserved_meta_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_allocated_meta_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

Ext4DaReleaseSpaceFtraceEvent::Ext4DaReleaseSpaceFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
}
Ext4DaReleaseSpaceFtraceEvent::Ext4DaReleaseSpaceFtraceEvent(const Ext4DaReleaseSpaceFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
}

inline void Ext4DaReleaseSpaceFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
}

Ext4DaReleaseSpaceFtraceEvent::~Ext4DaReleaseSpaceFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DaReleaseSpaceFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DaReleaseSpaceFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4DaReleaseSpaceFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4DaReleaseSpaceFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 i_blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_i_blocks(&has_bits);
          i_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 freed_blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_freed_blocks(&has_bits);
          freed_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 reserved_data_blocks = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_reserved_data_blocks(&has_bits);
          reserved_data_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 reserved_meta_blocks = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_reserved_meta_blocks(&has_bits);
          reserved_meta_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 allocated_meta_blocks = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_allocated_meta_blocks(&has_bits);
          allocated_meta_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4DaReleaseSpaceFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 i_blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_i_blocks(), target);
  }

  // optional int32 freed_blocks = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_freed_blocks(), target);
  }

  // optional int32 reserved_data_blocks = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_reserved_data_blocks(), target);
  }

  // optional int32 reserved_meta_blocks = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_reserved_meta_blocks(), target);
  }

  // optional int32 allocated_meta_blocks = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_allocated_meta_blocks(), target);
  }

  // optional uint32 mode = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
  return target;
}

size_t Ext4DaReleaseSpaceFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 i_blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_i_blocks());
    }

    // optional int32 freed_blocks = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_freed_blocks());
    }

    // optional int32 reserved_data_blocks = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_reserved_data_blocks());
    }

    // optional int32 reserved_meta_blocks = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_reserved_meta_blocks());
    }

    // optional int32 allocated_meta_blocks = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_allocated_meta_blocks());
    }

    // optional uint32 mode = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DaReleaseSpaceFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4DaReleaseSpaceFtraceEvent*>(
      &from));
}

void Ext4DaReleaseSpaceFtraceEvent::MergeFrom(const Ext4DaReleaseSpaceFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      i_blocks_ = from.i_blocks_;
    }
    if (cached_has_bits & 0x00000008u) {
      freed_blocks_ = from.freed_blocks_;
    }
    if (cached_has_bits & 0x00000010u) {
      reserved_data_blocks_ = from.reserved_data_blocks_;
    }
    if (cached_has_bits & 0x00000020u) {
      reserved_meta_blocks_ = from.reserved_meta_blocks_;
    }
    if (cached_has_bits & 0x00000040u) {
      allocated_meta_blocks_ = from.allocated_meta_blocks_;
    }
    if (cached_has_bits & 0x00000080u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4DaReleaseSpaceFtraceEvent::CopyFrom(const Ext4DaReleaseSpaceFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DaReleaseSpaceFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DaReleaseSpaceFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DaReleaseSpaceFtraceEvent::InternalSwap(Ext4DaReleaseSpaceFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DaReleaseSpaceFtraceEvent, mode_)
      + sizeof(Ext4DaReleaseSpaceFtraceEvent::mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4DaReleaseSpaceFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4DaReleaseSpaceFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DaReleaseSpaceFtraceEvent";
}


// ===================================================================

class Ext4DaReserveSpaceFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DaReserveSpaceFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_i_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_reserved_data_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_reserved_meta_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_md_needed(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

Ext4DaReserveSpaceFtraceEvent::Ext4DaReserveSpaceFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
}
Ext4DaReserveSpaceFtraceEvent::Ext4DaReserveSpaceFtraceEvent(const Ext4DaReserveSpaceFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&md_needed_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(md_needed_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
}

inline void Ext4DaReserveSpaceFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&md_needed_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(md_needed_));
}

Ext4DaReserveSpaceFtraceEvent::~Ext4DaReserveSpaceFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DaReserveSpaceFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DaReserveSpaceFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4DaReserveSpaceFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&md_needed_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(md_needed_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4DaReserveSpaceFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 i_blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_i_blocks(&has_bits);
          i_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 reserved_data_blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_reserved_data_blocks(&has_bits);
          reserved_data_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 reserved_meta_blocks = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_reserved_meta_blocks(&has_bits);
          reserved_meta_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mode = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 md_needed = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_md_needed(&has_bits);
          md_needed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4DaReserveSpaceFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 i_blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_i_blocks(), target);
  }

  // optional int32 reserved_data_blocks = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_reserved_data_blocks(), target);
  }

  // optional int32 reserved_meta_blocks = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_reserved_meta_blocks(), target);
  }

  // optional uint32 mode = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_mode(), target);
  }

  // optional int32 md_needed = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_md_needed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
  return target;
}

size_t Ext4DaReserveSpaceFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 i_blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_i_blocks());
    }

    // optional int32 reserved_data_blocks = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_reserved_data_blocks());
    }

    // optional int32 reserved_meta_blocks = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_reserved_meta_blocks());
    }

    // optional uint32 mode = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
    }

    // optional int32 md_needed = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_md_needed());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DaReserveSpaceFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4DaReserveSpaceFtraceEvent*>(
      &from));
}

void Ext4DaReserveSpaceFtraceEvent::MergeFrom(const Ext4DaReserveSpaceFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      i_blocks_ = from.i_blocks_;
    }
    if (cached_has_bits & 0x00000008u) {
      reserved_data_blocks_ = from.reserved_data_blocks_;
    }
    if (cached_has_bits & 0x00000010u) {
      reserved_meta_blocks_ = from.reserved_meta_blocks_;
    }
    if (cached_has_bits & 0x00000020u) {
      mode_ = from.mode_;
    }
    if (cached_has_bits & 0x00000040u) {
      md_needed_ = from.md_needed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4DaReserveSpaceFtraceEvent::CopyFrom(const Ext4DaReserveSpaceFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DaReserveSpaceFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DaReserveSpaceFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DaReserveSpaceFtraceEvent::InternalSwap(Ext4DaReserveSpaceFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DaReserveSpaceFtraceEvent, md_needed_)
      + sizeof(Ext4DaReserveSpaceFtraceEvent::md_needed_)
      - PROTOBUF_FIELD_OFFSET(Ext4DaReserveSpaceFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4DaReserveSpaceFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DaReserveSpaceFtraceEvent";
}


// ===================================================================

class Ext4DaUpdateReserveSpaceFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DaUpdateReserveSpaceFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_i_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_used_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_reserved_data_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_reserved_meta_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_allocated_meta_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_quota_claim(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

Ext4DaUpdateReserveSpaceFtraceEvent::Ext4DaUpdateReserveSpaceFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
}
Ext4DaUpdateReserveSpaceFtraceEvent::Ext4DaUpdateReserveSpaceFtraceEvent(const Ext4DaUpdateReserveSpaceFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
}

inline void Ext4DaUpdateReserveSpaceFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
}

Ext4DaUpdateReserveSpaceFtraceEvent::~Ext4DaUpdateReserveSpaceFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DaUpdateReserveSpaceFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DaUpdateReserveSpaceFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4DaUpdateReserveSpaceFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&quota_claim_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(quota_claim_));
  }
  mode_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4DaUpdateReserveSpaceFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 i_blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_i_blocks(&has_bits);
          i_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 used_blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_used_blocks(&has_bits);
          used_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 reserved_data_blocks = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_reserved_data_blocks(&has_bits);
          reserved_data_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 reserved_meta_blocks = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_reserved_meta_blocks(&has_bits);
          reserved_meta_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 allocated_meta_blocks = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_allocated_meta_blocks(&has_bits);
          allocated_meta_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 quota_claim = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_quota_claim(&has_bits);
          quota_claim_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mode = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4DaUpdateReserveSpaceFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 i_blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_i_blocks(), target);
  }

  // optional int32 used_blocks = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_used_blocks(), target);
  }

  // optional int32 reserved_data_blocks = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_reserved_data_blocks(), target);
  }

  // optional int32 reserved_meta_blocks = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_reserved_meta_blocks(), target);
  }

  // optional int32 allocated_meta_blocks = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_allocated_meta_blocks(), target);
  }

  // optional int32 quota_claim = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_quota_claim(), target);
  }

  // optional uint32 mode = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
  return target;
}

size_t Ext4DaUpdateReserveSpaceFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 i_blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_i_blocks());
    }

    // optional int32 used_blocks = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_used_blocks());
    }

    // optional int32 reserved_data_blocks = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_reserved_data_blocks());
    }

    // optional int32 reserved_meta_blocks = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_reserved_meta_blocks());
    }

    // optional int32 allocated_meta_blocks = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_allocated_meta_blocks());
    }

    // optional int32 quota_claim = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_quota_claim());
    }

  }
  // optional uint32 mode = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DaUpdateReserveSpaceFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4DaUpdateReserveSpaceFtraceEvent*>(
      &from));
}

void Ext4DaUpdateReserveSpaceFtraceEvent::MergeFrom(const Ext4DaUpdateReserveSpaceFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      i_blocks_ = from.i_blocks_;
    }
    if (cached_has_bits & 0x00000008u) {
      used_blocks_ = from.used_blocks_;
    }
    if (cached_has_bits & 0x00000010u) {
      reserved_data_blocks_ = from.reserved_data_blocks_;
    }
    if (cached_has_bits & 0x00000020u) {
      reserved_meta_blocks_ = from.reserved_meta_blocks_;
    }
    if (cached_has_bits & 0x00000040u) {
      allocated_meta_blocks_ = from.allocated_meta_blocks_;
    }
    if (cached_has_bits & 0x00000080u) {
      quota_claim_ = from.quota_claim_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_mode(from._internal_mode());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4DaUpdateReserveSpaceFtraceEvent::CopyFrom(const Ext4DaUpdateReserveSpaceFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DaUpdateReserveSpaceFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DaUpdateReserveSpaceFtraceEvent::InternalSwap(Ext4DaUpdateReserveSpaceFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DaUpdateReserveSpaceFtraceEvent, mode_)
      + sizeof(Ext4DaUpdateReserveSpaceFtraceEvent::mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4DaUpdateReserveSpaceFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4DaUpdateReserveSpaceFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DaUpdateReserveSpaceFtraceEvent";
}


// ===================================================================

class Ext4DaWritePagesFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DaWritePagesFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_first_page(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_nr_to_write(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sync_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_b_blocknr(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_b_size(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_b_state(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_io_done(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_pages_written(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

Ext4DaWritePagesFtraceEvent::Ext4DaWritePagesFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DaWritePagesFtraceEvent)
}
Ext4DaWritePagesFtraceEvent::Ext4DaWritePagesFtraceEvent(const Ext4DaWritePagesFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&pages_written_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(pages_written_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DaWritePagesFtraceEvent)
}

inline void Ext4DaWritePagesFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&pages_written_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(pages_written_));
}

Ext4DaWritePagesFtraceEvent::~Ext4DaWritePagesFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DaWritePagesFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DaWritePagesFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DaWritePagesFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4DaWritePagesFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DaWritePagesFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&b_state_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(b_state_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&io_done_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pages_written_) -
        reinterpret_cast<char*>(&io_done_)) + sizeof(pages_written_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4DaWritePagesFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 first_page = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_first_page(&has_bits);
          first_page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 nr_to_write = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_nr_to_write(&has_bits);
          nr_to_write_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 sync_mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_sync_mode(&has_bits);
          sync_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 b_blocknr = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_b_blocknr(&has_bits);
          b_blocknr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 b_size = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_b_size(&has_bits);
          b_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 b_state = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_b_state(&has_bits);
          b_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 io_done = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_io_done(&has_bits);
          io_done_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pages_written = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_pages_written(&has_bits);
          pages_written_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4DaWritePagesFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DaWritePagesFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 first_page = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_first_page(), target);
  }

  // optional int64 nr_to_write = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_nr_to_write(), target);
  }

  // optional int32 sync_mode = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_sync_mode(), target);
  }

  // optional uint64 b_blocknr = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_b_blocknr(), target);
  }

  // optional uint32 b_size = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_b_size(), target);
  }

  // optional uint32 b_state = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_b_state(), target);
  }

  // optional int32 io_done = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_io_done(), target);
  }

  // optional int32 pages_written = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_pages_written(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DaWritePagesFtraceEvent)
  return target;
}

size_t Ext4DaWritePagesFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DaWritePagesFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 first_page = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_first_page());
    }

    // optional int64 nr_to_write = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_nr_to_write());
    }

    // optional uint64 b_blocknr = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_b_blocknr());
    }

    // optional int32 sync_mode = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sync_mode());
    }

    // optional uint32 b_size = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_b_size());
    }

    // optional uint32 b_state = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_b_state());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional int32 io_done = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_io_done());
    }

    // optional int32 pages_written = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pages_written());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DaWritePagesFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4DaWritePagesFtraceEvent*>(
      &from));
}

void Ext4DaWritePagesFtraceEvent::MergeFrom(const Ext4DaWritePagesFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DaWritePagesFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      first_page_ = from.first_page_;
    }
    if (cached_has_bits & 0x00000008u) {
      nr_to_write_ = from.nr_to_write_;
    }
    if (cached_has_bits & 0x00000010u) {
      b_blocknr_ = from.b_blocknr_;
    }
    if (cached_has_bits & 0x00000020u) {
      sync_mode_ = from.sync_mode_;
    }
    if (cached_has_bits & 0x00000040u) {
      b_size_ = from.b_size_;
    }
    if (cached_has_bits & 0x00000080u) {
      b_state_ = from.b_state_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      io_done_ = from.io_done_;
    }
    if (cached_has_bits & 0x00000200u) {
      pages_written_ = from.pages_written_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4DaWritePagesFtraceEvent::CopyFrom(const Ext4DaWritePagesFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DaWritePagesFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DaWritePagesFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DaWritePagesFtraceEvent::InternalSwap(Ext4DaWritePagesFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DaWritePagesFtraceEvent, pages_written_)
      + sizeof(Ext4DaWritePagesFtraceEvent::pages_written_)
      - PROTOBUF_FIELD_OFFSET(Ext4DaWritePagesFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4DaWritePagesFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DaWritePagesFtraceEvent";
}


// ===================================================================

class Ext4DaWritePagesExtentFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DaWritePagesExtentFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4DaWritePagesExtentFtraceEvent::Ext4DaWritePagesExtentFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
}
Ext4DaWritePagesExtentFtraceEvent::Ext4DaWritePagesExtentFtraceEvent(const Ext4DaWritePagesExtentFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
}

inline void Ext4DaWritePagesExtentFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
}

Ext4DaWritePagesExtentFtraceEvent::~Ext4DaWritePagesExtentFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DaWritePagesExtentFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DaWritePagesExtentFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4DaWritePagesExtentFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flags_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4DaWritePagesExtentFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4DaWritePagesExtentFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_lblk(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_len(), target);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
  return target;
}

size_t Ext4DaWritePagesExtentFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DaWritePagesExtentFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4DaWritePagesExtentFtraceEvent*>(
      &from));
}

void Ext4DaWritePagesExtentFtraceEvent::MergeFrom(const Ext4DaWritePagesExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      flags_ = from.flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4DaWritePagesExtentFtraceEvent::CopyFrom(const Ext4DaWritePagesExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DaWritePagesExtentFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DaWritePagesExtentFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DaWritePagesExtentFtraceEvent::InternalSwap(Ext4DaWritePagesExtentFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DaWritePagesExtentFtraceEvent, flags_)
      + sizeof(Ext4DaWritePagesExtentFtraceEvent::flags_)
      - PROTOBUF_FIELD_OFFSET(Ext4DaWritePagesExtentFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4DaWritePagesExtentFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DaWritePagesExtentFtraceEvent";
}


// ===================================================================

class Ext4DirectIOEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DirectIOEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rw(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4DirectIOEnterFtraceEvent::Ext4DirectIOEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
}
Ext4DirectIOEnterFtraceEvent::Ext4DirectIOEnterFtraceEvent(const Ext4DirectIOEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&rw_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(rw_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
}

inline void Ext4DirectIOEnterFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rw_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(rw_));
}

Ext4DirectIOEnterFtraceEvent::~Ext4DirectIOEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DirectIOEnterFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DirectIOEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4DirectIOEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rw_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(rw_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4DirectIOEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 rw = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_rw(&has_bits);
          rw_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4DirectIOEnterFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_pos(), target);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_len(), target);
  }

  // optional int32 rw = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_rw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
  return target;
}

size_t Ext4DirectIOEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_pos());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_len());
    }

    // optional int32 rw = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rw());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DirectIOEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4DirectIOEnterFtraceEvent*>(
      &from));
}

void Ext4DirectIOEnterFtraceEvent::MergeFrom(const Ext4DirectIOEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pos_ = from.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      rw_ = from.rw_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4DirectIOEnterFtraceEvent::CopyFrom(const Ext4DirectIOEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DirectIOEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DirectIOEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DirectIOEnterFtraceEvent::InternalSwap(Ext4DirectIOEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DirectIOEnterFtraceEvent, rw_)
      + sizeof(Ext4DirectIOEnterFtraceEvent::rw_)
      - PROTOBUF_FIELD_OFFSET(Ext4DirectIOEnterFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4DirectIOEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DirectIOEnterFtraceEvent";
}


// ===================================================================

class Ext4DirectIOExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DirectIOExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rw(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4DirectIOExitFtraceEvent::Ext4DirectIOExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DirectIOExitFtraceEvent)
}
Ext4DirectIOExitFtraceEvent::Ext4DirectIOExitFtraceEvent(const Ext4DirectIOExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DirectIOExitFtraceEvent)
}

inline void Ext4DirectIOExitFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
}

Ext4DirectIOExitFtraceEvent::~Ext4DirectIOExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DirectIOExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DirectIOExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DirectIOExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4DirectIOExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DirectIOExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ret_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4DirectIOExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 rw = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_rw(&has_bits);
          rw_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4DirectIOExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DirectIOExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_pos(), target);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_len(), target);
  }

  // optional int32 rw = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_rw(), target);
  }

  // optional int32 ret = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DirectIOExitFtraceEvent)
  return target;
}

size_t Ext4DirectIOExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DirectIOExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_pos());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_len());
    }

    // optional int32 rw = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rw());
    }

    // optional int32 ret = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DirectIOExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4DirectIOExitFtraceEvent*>(
      &from));
}

void Ext4DirectIOExitFtraceEvent::MergeFrom(const Ext4DirectIOExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DirectIOExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pos_ = from.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      rw_ = from.rw_;
    }
    if (cached_has_bits & 0x00000020u) {
      ret_ = from.ret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4DirectIOExitFtraceEvent::CopyFrom(const Ext4DirectIOExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DirectIOExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DirectIOExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DirectIOExitFtraceEvent::InternalSwap(Ext4DirectIOExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DirectIOExitFtraceEvent, ret_)
      + sizeof(Ext4DirectIOExitFtraceEvent::ret_)
      - PROTOBUF_FIELD_OFFSET(Ext4DirectIOExitFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4DirectIOExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DirectIOExitFtraceEvent";
}


// ===================================================================

class Ext4DiscardBlocksFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DiscardBlocksFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_blk(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4DiscardBlocksFtraceEvent::Ext4DiscardBlocksFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
}
Ext4DiscardBlocksFtraceEvent::Ext4DiscardBlocksFtraceEvent(const Ext4DiscardBlocksFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(count_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
}

inline void Ext4DiscardBlocksFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(count_));
}

Ext4DiscardBlocksFtraceEvent::~Ext4DiscardBlocksFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DiscardBlocksFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DiscardBlocksFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4DiscardBlocksFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&count_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4DiscardBlocksFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blk = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_blk(&has_bits);
          blk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4DiscardBlocksFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 blk = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_blk(), target);
  }

  // optional uint64 count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
  return target;
}

size_t Ext4DiscardBlocksFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 blk = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_blk());
    }

    // optional uint64 count = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_count());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DiscardBlocksFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4DiscardBlocksFtraceEvent*>(
      &from));
}

void Ext4DiscardBlocksFtraceEvent::MergeFrom(const Ext4DiscardBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      blk_ = from.blk_;
    }
    if (cached_has_bits & 0x00000004u) {
      count_ = from.count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4DiscardBlocksFtraceEvent::CopyFrom(const Ext4DiscardBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DiscardBlocksFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DiscardBlocksFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DiscardBlocksFtraceEvent::InternalSwap(Ext4DiscardBlocksFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DiscardBlocksFtraceEvent, count_)
      + sizeof(Ext4DiscardBlocksFtraceEvent::count_)
      - PROTOBUF_FIELD_OFFSET(Ext4DiscardBlocksFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4DiscardBlocksFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DiscardBlocksFtraceEvent";
}


// ===================================================================

class Ext4DiscardPreallocationsFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DiscardPreallocationsFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_needed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4DiscardPreallocationsFtraceEvent::Ext4DiscardPreallocationsFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
}
Ext4DiscardPreallocationsFtraceEvent::Ext4DiscardPreallocationsFtraceEvent(const Ext4DiscardPreallocationsFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&needed_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(needed_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
}

inline void Ext4DiscardPreallocationsFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&needed_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(needed_));
}

Ext4DiscardPreallocationsFtraceEvent::~Ext4DiscardPreallocationsFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DiscardPreallocationsFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DiscardPreallocationsFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4DiscardPreallocationsFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&needed_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(needed_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4DiscardPreallocationsFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 needed = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_needed(&has_bits);
          needed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4DiscardPreallocationsFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 len = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_len(), target);
  }

  // optional uint32 needed = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_needed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
  return target;
}

size_t Ext4DiscardPreallocationsFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 len = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint32 needed = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_needed());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DiscardPreallocationsFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4DiscardPreallocationsFtraceEvent*>(
      &from));
}

void Ext4DiscardPreallocationsFtraceEvent::MergeFrom(const Ext4DiscardPreallocationsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000008u) {
      needed_ = from.needed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4DiscardPreallocationsFtraceEvent::CopyFrom(const Ext4DiscardPreallocationsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DiscardPreallocationsFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DiscardPreallocationsFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DiscardPreallocationsFtraceEvent::InternalSwap(Ext4DiscardPreallocationsFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DiscardPreallocationsFtraceEvent, needed_)
      + sizeof(Ext4DiscardPreallocationsFtraceEvent::needed_)
      - PROTOBUF_FIELD_OFFSET(Ext4DiscardPreallocationsFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4DiscardPreallocationsFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DiscardPreallocationsFtraceEvent";
}


// ===================================================================

class Ext4DropInodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4DropInodeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_drop(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4DropInodeFtraceEvent::Ext4DropInodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4DropInodeFtraceEvent)
}
Ext4DropInodeFtraceEvent::Ext4DropInodeFtraceEvent(const Ext4DropInodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&drop_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(drop_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4DropInodeFtraceEvent)
}

inline void Ext4DropInodeFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&drop_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(drop_));
}

Ext4DropInodeFtraceEvent::~Ext4DropInodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4DropInodeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4DropInodeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4DropInodeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4DropInodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4DropInodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&drop_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(drop_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4DropInodeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 drop = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_drop(&has_bits);
          drop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4DropInodeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4DropInodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 drop = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_drop(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4DropInodeFtraceEvent)
  return target;
}

size_t Ext4DropInodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4DropInodeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 drop = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_drop());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4DropInodeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4DropInodeFtraceEvent*>(
      &from));
}

void Ext4DropInodeFtraceEvent::MergeFrom(const Ext4DropInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4DropInodeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      drop_ = from.drop_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4DropInodeFtraceEvent::CopyFrom(const Ext4DropInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4DropInodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4DropInodeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4DropInodeFtraceEvent::InternalSwap(Ext4DropInodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4DropInodeFtraceEvent, drop_)
      + sizeof(Ext4DropInodeFtraceEvent::drop_)
      - PROTOBUF_FIELD_OFFSET(Ext4DropInodeFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4DropInodeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4DropInodeFtraceEvent";
}


// ===================================================================

class Ext4EsCacheExtentFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsCacheExtentFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4EsCacheExtentFtraceEvent::Ext4EsCacheExtentFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
}
Ext4EsCacheExtentFtraceEvent::Ext4EsCacheExtentFtraceEvent(const Ext4EsCacheExtentFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
}

inline void Ext4EsCacheExtentFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(status_));
}

Ext4EsCacheExtentFtraceEvent::~Ext4EsCacheExtentFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EsCacheExtentFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EsCacheExtentFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4EsCacheExtentFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&status_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4EsCacheExtentFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_pblk(&has_bits);
          pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 status = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4EsCacheExtentFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_lblk(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_len(), target);
  }

  // optional uint64 pblk = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_pblk(), target);
  }

  // optional uint32 status = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
  return target;
}

size_t Ext4EsCacheExtentFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint64 pblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pblk());
    }

    // optional uint32 status = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_status());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EsCacheExtentFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4EsCacheExtentFtraceEvent*>(
      &from));
}

void Ext4EsCacheExtentFtraceEvent::MergeFrom(const Ext4EsCacheExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      pblk_ = from.pblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4EsCacheExtentFtraceEvent::CopyFrom(const Ext4EsCacheExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsCacheExtentFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsCacheExtentFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsCacheExtentFtraceEvent::InternalSwap(Ext4EsCacheExtentFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EsCacheExtentFtraceEvent, status_)
      + sizeof(Ext4EsCacheExtentFtraceEvent::status_)
      - PROTOBUF_FIELD_OFFSET(Ext4EsCacheExtentFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4EsCacheExtentFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EsCacheExtentFtraceEvent";
}


// ===================================================================

class Ext4EsFindDelayedExtentRangeEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsFindDelayedExtentRangeEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4EsFindDelayedExtentRangeEnterFtraceEvent::Ext4EsFindDelayedExtentRangeEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
}
Ext4EsFindDelayedExtentRangeEnterFtraceEvent::Ext4EsFindDelayedExtentRangeEnterFtraceEvent(const Ext4EsFindDelayedExtentRangeEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&lblk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(lblk_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
}

inline void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&lblk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(lblk_));
}

Ext4EsFindDelayedExtentRangeEnterFtraceEvent::~Ext4EsFindDelayedExtentRangeEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lblk_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(lblk_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4EsFindDelayedExtentRangeEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4EsFindDelayedExtentRangeEnterFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_lblk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
  return target;
}

size_t Ext4EsFindDelayedExtentRangeEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lblk());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4EsFindDelayedExtentRangeEnterFtraceEvent*>(
      &from));
}

void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::MergeFrom(const Ext4EsFindDelayedExtentRangeEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::CopyFrom(const Ext4EsFindDelayedExtentRangeEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsFindDelayedExtentRangeEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsFindDelayedExtentRangeEnterFtraceEvent::InternalSwap(Ext4EsFindDelayedExtentRangeEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EsFindDelayedExtentRangeEnterFtraceEvent, lblk_)
      + sizeof(Ext4EsFindDelayedExtentRangeEnterFtraceEvent::lblk_)
      - PROTOBUF_FIELD_OFFSET(Ext4EsFindDelayedExtentRangeEnterFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4EsFindDelayedExtentRangeEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EsFindDelayedExtentRangeEnterFtraceEvent";
}


// ===================================================================

class Ext4EsFindDelayedExtentRangeExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsFindDelayedExtentRangeExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4EsFindDelayedExtentRangeExitFtraceEvent::Ext4EsFindDelayedExtentRangeExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
}
Ext4EsFindDelayedExtentRangeExitFtraceEvent::Ext4EsFindDelayedExtentRangeExitFtraceEvent(const Ext4EsFindDelayedExtentRangeExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
}

inline void Ext4EsFindDelayedExtentRangeExitFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(status_));
}

Ext4EsFindDelayedExtentRangeExitFtraceEvent::~Ext4EsFindDelayedExtentRangeExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EsFindDelayedExtentRangeExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EsFindDelayedExtentRangeExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4EsFindDelayedExtentRangeExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&status_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4EsFindDelayedExtentRangeExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_pblk(&has_bits);
          pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 status = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4EsFindDelayedExtentRangeExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_lblk(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_len(), target);
  }

  // optional uint64 pblk = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_pblk(), target);
  }

  // optional uint64 status = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
  return target;
}

size_t Ext4EsFindDelayedExtentRangeExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint64 pblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pblk());
    }

    // optional uint64 status = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_status());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EsFindDelayedExtentRangeExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4EsFindDelayedExtentRangeExitFtraceEvent*>(
      &from));
}

void Ext4EsFindDelayedExtentRangeExitFtraceEvent::MergeFrom(const Ext4EsFindDelayedExtentRangeExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      pblk_ = from.pblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4EsFindDelayedExtentRangeExitFtraceEvent::CopyFrom(const Ext4EsFindDelayedExtentRangeExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsFindDelayedExtentRangeExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsFindDelayedExtentRangeExitFtraceEvent::InternalSwap(Ext4EsFindDelayedExtentRangeExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EsFindDelayedExtentRangeExitFtraceEvent, status_)
      + sizeof(Ext4EsFindDelayedExtentRangeExitFtraceEvent::status_)
      - PROTOBUF_FIELD_OFFSET(Ext4EsFindDelayedExtentRangeExitFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4EsFindDelayedExtentRangeExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EsFindDelayedExtentRangeExitFtraceEvent";
}


// ===================================================================

class Ext4EsInsertExtentFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsInsertExtentFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4EsInsertExtentFtraceEvent::Ext4EsInsertExtentFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
}
Ext4EsInsertExtentFtraceEvent::Ext4EsInsertExtentFtraceEvent(const Ext4EsInsertExtentFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
}

inline void Ext4EsInsertExtentFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(status_));
}

Ext4EsInsertExtentFtraceEvent::~Ext4EsInsertExtentFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EsInsertExtentFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EsInsertExtentFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4EsInsertExtentFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&status_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4EsInsertExtentFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_pblk(&has_bits);
          pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 status = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4EsInsertExtentFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_lblk(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_len(), target);
  }

  // optional uint64 pblk = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_pblk(), target);
  }

  // optional uint64 status = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
  return target;
}

size_t Ext4EsInsertExtentFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint64 pblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pblk());
    }

    // optional uint64 status = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_status());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EsInsertExtentFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4EsInsertExtentFtraceEvent*>(
      &from));
}

void Ext4EsInsertExtentFtraceEvent::MergeFrom(const Ext4EsInsertExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      pblk_ = from.pblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4EsInsertExtentFtraceEvent::CopyFrom(const Ext4EsInsertExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsInsertExtentFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsInsertExtentFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsInsertExtentFtraceEvent::InternalSwap(Ext4EsInsertExtentFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EsInsertExtentFtraceEvent, status_)
      + sizeof(Ext4EsInsertExtentFtraceEvent::status_)
      - PROTOBUF_FIELD_OFFSET(Ext4EsInsertExtentFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4EsInsertExtentFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EsInsertExtentFtraceEvent";
}


// ===================================================================

class Ext4EsLookupExtentEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsLookupExtentEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4EsLookupExtentEnterFtraceEvent::Ext4EsLookupExtentEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
}
Ext4EsLookupExtentEnterFtraceEvent::Ext4EsLookupExtentEnterFtraceEvent(const Ext4EsLookupExtentEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&lblk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(lblk_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
}

inline void Ext4EsLookupExtentEnterFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&lblk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(lblk_));
}

Ext4EsLookupExtentEnterFtraceEvent::~Ext4EsLookupExtentEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EsLookupExtentEnterFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EsLookupExtentEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4EsLookupExtentEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lblk_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(lblk_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4EsLookupExtentEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4EsLookupExtentEnterFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_lblk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
  return target;
}

size_t Ext4EsLookupExtentEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lblk());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EsLookupExtentEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4EsLookupExtentEnterFtraceEvent*>(
      &from));
}

void Ext4EsLookupExtentEnterFtraceEvent::MergeFrom(const Ext4EsLookupExtentEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4EsLookupExtentEnterFtraceEvent::CopyFrom(const Ext4EsLookupExtentEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsLookupExtentEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsLookupExtentEnterFtraceEvent::InternalSwap(Ext4EsLookupExtentEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EsLookupExtentEnterFtraceEvent, lblk_)
      + sizeof(Ext4EsLookupExtentEnterFtraceEvent::lblk_)
      - PROTOBUF_FIELD_OFFSET(Ext4EsLookupExtentEnterFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4EsLookupExtentEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EsLookupExtentEnterFtraceEvent";
}


// ===================================================================

class Ext4EsLookupExtentExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsLookupExtentExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_found(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

Ext4EsLookupExtentExitFtraceEvent::Ext4EsLookupExtentExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
}
Ext4EsLookupExtentExitFtraceEvent::Ext4EsLookupExtentExitFtraceEvent(const Ext4EsLookupExtentExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&found_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(found_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
}

inline void Ext4EsLookupExtentExitFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&found_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(found_));
}

Ext4EsLookupExtentExitFtraceEvent::~Ext4EsLookupExtentExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EsLookupExtentExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EsLookupExtentExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4EsLookupExtentExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&found_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(found_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4EsLookupExtentExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_pblk(&has_bits);
          pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 status = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 found = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_found(&has_bits);
          found_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4EsLookupExtentExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_lblk(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_len(), target);
  }

  // optional uint64 pblk = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_pblk(), target);
  }

  // optional uint64 status = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_status(), target);
  }

  // optional int32 found = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_found(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
  return target;
}

size_t Ext4EsLookupExtentExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint64 pblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pblk());
    }

    // optional uint64 status = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_status());
    }

    // optional int32 found = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_found());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EsLookupExtentExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4EsLookupExtentExitFtraceEvent*>(
      &from));
}

void Ext4EsLookupExtentExitFtraceEvent::MergeFrom(const Ext4EsLookupExtentExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      pblk_ = from.pblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00000040u) {
      found_ = from.found_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4EsLookupExtentExitFtraceEvent::CopyFrom(const Ext4EsLookupExtentExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsLookupExtentExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsLookupExtentExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsLookupExtentExitFtraceEvent::InternalSwap(Ext4EsLookupExtentExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EsLookupExtentExitFtraceEvent, found_)
      + sizeof(Ext4EsLookupExtentExitFtraceEvent::found_)
      - PROTOBUF_FIELD_OFFSET(Ext4EsLookupExtentExitFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4EsLookupExtentExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EsLookupExtentExitFtraceEvent";
}


// ===================================================================

class Ext4EsRemoveExtentFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsRemoveExtentFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4EsRemoveExtentFtraceEvent::Ext4EsRemoveExtentFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
}
Ext4EsRemoveExtentFtraceEvent::Ext4EsRemoveExtentFtraceEvent(const Ext4EsRemoveExtentFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
}

inline void Ext4EsRemoveExtentFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(len_));
}

Ext4EsRemoveExtentFtraceEvent::~Ext4EsRemoveExtentFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EsRemoveExtentFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EsRemoveExtentFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4EsRemoveExtentFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4EsRemoveExtentFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4EsRemoveExtentFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_lblk(), target);
  }

  // optional int64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
  return target;
}

size_t Ext4EsRemoveExtentFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_lblk());
    }

    // optional int64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EsRemoveExtentFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4EsRemoveExtentFtraceEvent*>(
      &from));
}

void Ext4EsRemoveExtentFtraceEvent::MergeFrom(const Ext4EsRemoveExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4EsRemoveExtentFtraceEvent::CopyFrom(const Ext4EsRemoveExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsRemoveExtentFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsRemoveExtentFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsRemoveExtentFtraceEvent::InternalSwap(Ext4EsRemoveExtentFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EsRemoveExtentFtraceEvent, len_)
      + sizeof(Ext4EsRemoveExtentFtraceEvent::len_)
      - PROTOBUF_FIELD_OFFSET(Ext4EsRemoveExtentFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4EsRemoveExtentFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EsRemoveExtentFtraceEvent";
}


// ===================================================================

class Ext4EsShrinkFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsShrinkFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nr_shrunk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_scan_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nr_skipped(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_retried(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4EsShrinkFtraceEvent::Ext4EsShrinkFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EsShrinkFtraceEvent)
}
Ext4EsShrinkFtraceEvent::Ext4EsShrinkFtraceEvent(const Ext4EsShrinkFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&retried_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(retried_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsShrinkFtraceEvent)
}

inline void Ext4EsShrinkFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&retried_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(retried_));
}

Ext4EsShrinkFtraceEvent::~Ext4EsShrinkFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsShrinkFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EsShrinkFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EsShrinkFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4EsShrinkFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsShrinkFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&retried_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(retried_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4EsShrinkFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 nr_shrunk = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_nr_shrunk(&has_bits);
          nr_shrunk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 scan_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_scan_time(&has_bits);
          scan_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 nr_skipped = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_nr_skipped(&has_bits);
          nr_skipped_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 retried = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_retried(&has_bits);
          retried_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4EsShrinkFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EsShrinkFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional int32 nr_shrunk = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_nr_shrunk(), target);
  }

  // optional uint64 scan_time = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_scan_time(), target);
  }

  // optional int32 nr_skipped = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_nr_skipped(), target);
  }

  // optional int32 retried = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_retried(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EsShrinkFtraceEvent)
  return target;
}

size_t Ext4EsShrinkFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsShrinkFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 scan_time = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_scan_time());
    }

    // optional int32 nr_shrunk = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nr_shrunk());
    }

    // optional int32 nr_skipped = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nr_skipped());
    }

    // optional int32 retried = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_retried());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EsShrinkFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4EsShrinkFtraceEvent*>(
      &from));
}

void Ext4EsShrinkFtraceEvent::MergeFrom(const Ext4EsShrinkFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsShrinkFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      scan_time_ = from.scan_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      nr_shrunk_ = from.nr_shrunk_;
    }
    if (cached_has_bits & 0x00000008u) {
      nr_skipped_ = from.nr_skipped_;
    }
    if (cached_has_bits & 0x00000010u) {
      retried_ = from.retried_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4EsShrinkFtraceEvent::CopyFrom(const Ext4EsShrinkFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsShrinkFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsShrinkFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsShrinkFtraceEvent::InternalSwap(Ext4EsShrinkFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EsShrinkFtraceEvent, retried_)
      + sizeof(Ext4EsShrinkFtraceEvent::retried_)
      - PROTOBUF_FIELD_OFFSET(Ext4EsShrinkFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4EsShrinkFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EsShrinkFtraceEvent";
}


// ===================================================================

class Ext4EsShrinkCountFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsShrinkCountFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nr_to_scan(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cache_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4EsShrinkCountFtraceEvent::Ext4EsShrinkCountFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
}
Ext4EsShrinkCountFtraceEvent::Ext4EsShrinkCountFtraceEvent(const Ext4EsShrinkCountFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&cache_cnt_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(cache_cnt_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
}

inline void Ext4EsShrinkCountFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&cache_cnt_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(cache_cnt_));
}

Ext4EsShrinkCountFtraceEvent::~Ext4EsShrinkCountFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EsShrinkCountFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EsShrinkCountFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4EsShrinkCountFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cache_cnt_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(cache_cnt_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4EsShrinkCountFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 nr_to_scan = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_nr_to_scan(&has_bits);
          nr_to_scan_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 cache_cnt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_cache_cnt(&has_bits);
          cache_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4EsShrinkCountFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional int32 nr_to_scan = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_nr_to_scan(), target);
  }

  // optional int32 cache_cnt = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_cache_cnt(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
  return target;
}

size_t Ext4EsShrinkCountFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional int32 nr_to_scan = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nr_to_scan());
    }

    // optional int32 cache_cnt = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cache_cnt());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EsShrinkCountFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4EsShrinkCountFtraceEvent*>(
      &from));
}

void Ext4EsShrinkCountFtraceEvent::MergeFrom(const Ext4EsShrinkCountFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      nr_to_scan_ = from.nr_to_scan_;
    }
    if (cached_has_bits & 0x00000004u) {
      cache_cnt_ = from.cache_cnt_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4EsShrinkCountFtraceEvent::CopyFrom(const Ext4EsShrinkCountFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsShrinkCountFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsShrinkCountFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsShrinkCountFtraceEvent::InternalSwap(Ext4EsShrinkCountFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EsShrinkCountFtraceEvent, cache_cnt_)
      + sizeof(Ext4EsShrinkCountFtraceEvent::cache_cnt_)
      - PROTOBUF_FIELD_OFFSET(Ext4EsShrinkCountFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4EsShrinkCountFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EsShrinkCountFtraceEvent";
}


// ===================================================================

class Ext4EsShrinkScanEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsShrinkScanEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nr_to_scan(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cache_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4EsShrinkScanEnterFtraceEvent::Ext4EsShrinkScanEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
}
Ext4EsShrinkScanEnterFtraceEvent::Ext4EsShrinkScanEnterFtraceEvent(const Ext4EsShrinkScanEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&cache_cnt_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(cache_cnt_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
}

inline void Ext4EsShrinkScanEnterFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&cache_cnt_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(cache_cnt_));
}

Ext4EsShrinkScanEnterFtraceEvent::~Ext4EsShrinkScanEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EsShrinkScanEnterFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EsShrinkScanEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4EsShrinkScanEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cache_cnt_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(cache_cnt_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4EsShrinkScanEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 nr_to_scan = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_nr_to_scan(&has_bits);
          nr_to_scan_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 cache_cnt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_cache_cnt(&has_bits);
          cache_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4EsShrinkScanEnterFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional int32 nr_to_scan = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_nr_to_scan(), target);
  }

  // optional int32 cache_cnt = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_cache_cnt(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
  return target;
}

size_t Ext4EsShrinkScanEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional int32 nr_to_scan = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nr_to_scan());
    }

    // optional int32 cache_cnt = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cache_cnt());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EsShrinkScanEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4EsShrinkScanEnterFtraceEvent*>(
      &from));
}

void Ext4EsShrinkScanEnterFtraceEvent::MergeFrom(const Ext4EsShrinkScanEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      nr_to_scan_ = from.nr_to_scan_;
    }
    if (cached_has_bits & 0x00000004u) {
      cache_cnt_ = from.cache_cnt_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4EsShrinkScanEnterFtraceEvent::CopyFrom(const Ext4EsShrinkScanEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsShrinkScanEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsShrinkScanEnterFtraceEvent::InternalSwap(Ext4EsShrinkScanEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EsShrinkScanEnterFtraceEvent, cache_cnt_)
      + sizeof(Ext4EsShrinkScanEnterFtraceEvent::cache_cnt_)
      - PROTOBUF_FIELD_OFFSET(Ext4EsShrinkScanEnterFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4EsShrinkScanEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EsShrinkScanEnterFtraceEvent";
}


// ===================================================================

class Ext4EsShrinkScanExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EsShrinkScanExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nr_shrunk(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cache_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4EsShrinkScanExitFtraceEvent::Ext4EsShrinkScanExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
}
Ext4EsShrinkScanExitFtraceEvent::Ext4EsShrinkScanExitFtraceEvent(const Ext4EsShrinkScanExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&cache_cnt_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(cache_cnt_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
}

inline void Ext4EsShrinkScanExitFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&cache_cnt_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(cache_cnt_));
}

Ext4EsShrinkScanExitFtraceEvent::~Ext4EsShrinkScanExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EsShrinkScanExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EsShrinkScanExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4EsShrinkScanExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cache_cnt_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(cache_cnt_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4EsShrinkScanExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 nr_shrunk = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_nr_shrunk(&has_bits);
          nr_shrunk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 cache_cnt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_cache_cnt(&has_bits);
          cache_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4EsShrinkScanExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional int32 nr_shrunk = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_nr_shrunk(), target);
  }

  // optional int32 cache_cnt = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_cache_cnt(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
  return target;
}

size_t Ext4EsShrinkScanExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional int32 nr_shrunk = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nr_shrunk());
    }

    // optional int32 cache_cnt = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cache_cnt());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EsShrinkScanExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4EsShrinkScanExitFtraceEvent*>(
      &from));
}

void Ext4EsShrinkScanExitFtraceEvent::MergeFrom(const Ext4EsShrinkScanExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      nr_shrunk_ = from.nr_shrunk_;
    }
    if (cached_has_bits & 0x00000004u) {
      cache_cnt_ = from.cache_cnt_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4EsShrinkScanExitFtraceEvent::CopyFrom(const Ext4EsShrinkScanExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EsShrinkScanExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EsShrinkScanExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EsShrinkScanExitFtraceEvent::InternalSwap(Ext4EsShrinkScanExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EsShrinkScanExitFtraceEvent, cache_cnt_)
      + sizeof(Ext4EsShrinkScanExitFtraceEvent::cache_cnt_)
      - PROTOBUF_FIELD_OFFSET(Ext4EsShrinkScanExitFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4EsShrinkScanExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EsShrinkScanExitFtraceEvent";
}


// ===================================================================

class Ext4EvictInodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4EvictInodeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nlink(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4EvictInodeFtraceEvent::Ext4EvictInodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4EvictInodeFtraceEvent)
}
Ext4EvictInodeFtraceEvent::Ext4EvictInodeFtraceEvent(const Ext4EvictInodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&nlink_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(nlink_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4EvictInodeFtraceEvent)
}

inline void Ext4EvictInodeFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&nlink_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(nlink_));
}

Ext4EvictInodeFtraceEvent::~Ext4EvictInodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4EvictInodeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4EvictInodeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4EvictInodeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4EvictInodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4EvictInodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nlink_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(nlink_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4EvictInodeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 nlink = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_nlink(&has_bits);
          nlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4EvictInodeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4EvictInodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 nlink = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_nlink(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4EvictInodeFtraceEvent)
  return target;
}

size_t Ext4EvictInodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4EvictInodeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 nlink = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nlink());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4EvictInodeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4EvictInodeFtraceEvent*>(
      &from));
}

void Ext4EvictInodeFtraceEvent::MergeFrom(const Ext4EvictInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4EvictInodeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      nlink_ = from.nlink_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4EvictInodeFtraceEvent::CopyFrom(const Ext4EvictInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4EvictInodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4EvictInodeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4EvictInodeFtraceEvent::InternalSwap(Ext4EvictInodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4EvictInodeFtraceEvent, nlink_)
      + sizeof(Ext4EvictInodeFtraceEvent::nlink_)
      - PROTOBUF_FIELD_OFFSET(Ext4EvictInodeFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4EvictInodeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4EvictInodeFtraceEvent";
}


// ===================================================================

class Ext4ExtConvertToInitializedEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtConvertToInitializedEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_u_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_u_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_u_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

Ext4ExtConvertToInitializedEnterFtraceEvent::Ext4ExtConvertToInitializedEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
}
Ext4ExtConvertToInitializedEnterFtraceEvent::Ext4ExtConvertToInitializedEnterFtraceEvent(const Ext4ExtConvertToInitializedEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&u_pblk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(u_pblk_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
}

inline void Ext4ExtConvertToInitializedEnterFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&u_pblk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(u_pblk_));
}

Ext4ExtConvertToInitializedEnterFtraceEvent::~Ext4ExtConvertToInitializedEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtConvertToInitializedEnterFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtConvertToInitializedEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4ExtConvertToInitializedEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&u_pblk_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(u_pblk_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4ExtConvertToInitializedEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 m_lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_m_lblk(&has_bits);
          m_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 m_len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_m_len(&has_bits);
          m_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 u_lblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_u_lblk(&has_bits);
          u_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 u_len = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_u_len(&has_bits);
          u_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 u_pblk = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_u_pblk(&has_bits);
          u_pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4ExtConvertToInitializedEnterFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 m_lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_m_lblk(), target);
  }

  // optional uint32 m_len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_m_len(), target);
  }

  // optional uint32 u_lblk = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_u_lblk(), target);
  }

  // optional uint32 u_len = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_u_len(), target);
  }

  // optional uint64 u_pblk = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_u_pblk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
  return target;
}

size_t Ext4ExtConvertToInitializedEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 m_lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_m_lblk());
    }

    // optional uint32 m_len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_m_len());
    }

    // optional uint32 u_lblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_u_lblk());
    }

    // optional uint32 u_len = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_u_len());
    }

    // optional uint64 u_pblk = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_u_pblk());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtConvertToInitializedEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4ExtConvertToInitializedEnterFtraceEvent*>(
      &from));
}

void Ext4ExtConvertToInitializedEnterFtraceEvent::MergeFrom(const Ext4ExtConvertToInitializedEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      m_lblk_ = from.m_lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      m_len_ = from.m_len_;
    }
    if (cached_has_bits & 0x00000010u) {
      u_lblk_ = from.u_lblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      u_len_ = from.u_len_;
    }
    if (cached_has_bits & 0x00000040u) {
      u_pblk_ = from.u_pblk_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4ExtConvertToInitializedEnterFtraceEvent::CopyFrom(const Ext4ExtConvertToInitializedEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtConvertToInitializedEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtConvertToInitializedEnterFtraceEvent::InternalSwap(Ext4ExtConvertToInitializedEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtConvertToInitializedEnterFtraceEvent, u_pblk_)
      + sizeof(Ext4ExtConvertToInitializedEnterFtraceEvent::u_pblk_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtConvertToInitializedEnterFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4ExtConvertToInitializedEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtConvertToInitializedEnterFtraceEvent";
}


// ===================================================================

class Ext4ExtConvertToInitializedFastpathFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtConvertToInitializedFastpathFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_u_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_u_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_u_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_i_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_i_len(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_i_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

Ext4ExtConvertToInitializedFastpathFtraceEvent::Ext4ExtConvertToInitializedFastpathFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
}
Ext4ExtConvertToInitializedFastpathFtraceEvent::Ext4ExtConvertToInitializedFastpathFtraceEvent(const Ext4ExtConvertToInitializedFastpathFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&i_pblk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(i_pblk_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
}

inline void Ext4ExtConvertToInitializedFastpathFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&i_pblk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(i_pblk_));
}

Ext4ExtConvertToInitializedFastpathFtraceEvent::~Ext4ExtConvertToInitializedFastpathFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtConvertToInitializedFastpathFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtConvertToInitializedFastpathFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4ExtConvertToInitializedFastpathFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&i_lblk_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(i_lblk_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&i_len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&i_pblk_) -
        reinterpret_cast<char*>(&i_len_)) + sizeof(i_pblk_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4ExtConvertToInitializedFastpathFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 m_lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_m_lblk(&has_bits);
          m_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 m_len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_m_len(&has_bits);
          m_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 u_lblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_u_lblk(&has_bits);
          u_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 u_len = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_u_len(&has_bits);
          u_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 u_pblk = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_u_pblk(&has_bits);
          u_pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 i_lblk = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_i_lblk(&has_bits);
          i_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 i_len = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_i_len(&has_bits);
          i_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 i_pblk = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_i_pblk(&has_bits);
          i_pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4ExtConvertToInitializedFastpathFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 m_lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_m_lblk(), target);
  }

  // optional uint32 m_len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_m_len(), target);
  }

  // optional uint32 u_lblk = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_u_lblk(), target);
  }

  // optional uint32 u_len = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_u_len(), target);
  }

  // optional uint64 u_pblk = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_u_pblk(), target);
  }

  // optional uint32 i_lblk = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_i_lblk(), target);
  }

  // optional uint32 i_len = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_i_len(), target);
  }

  // optional uint64 i_pblk = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(10, this->_internal_i_pblk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
  return target;
}

size_t Ext4ExtConvertToInitializedFastpathFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 m_lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_m_lblk());
    }

    // optional uint32 m_len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_m_len());
    }

    // optional uint32 u_lblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_u_lblk());
    }

    // optional uint32 u_len = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_u_len());
    }

    // optional uint64 u_pblk = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_u_pblk());
    }

    // optional uint32 i_lblk = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i_lblk());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 i_len = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_i_len());
    }

    // optional uint64 i_pblk = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_i_pblk());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtConvertToInitializedFastpathFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4ExtConvertToInitializedFastpathFtraceEvent*>(
      &from));
}

void Ext4ExtConvertToInitializedFastpathFtraceEvent::MergeFrom(const Ext4ExtConvertToInitializedFastpathFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      m_lblk_ = from.m_lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      m_len_ = from.m_len_;
    }
    if (cached_has_bits & 0x00000010u) {
      u_lblk_ = from.u_lblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      u_len_ = from.u_len_;
    }
    if (cached_has_bits & 0x00000040u) {
      u_pblk_ = from.u_pblk_;
    }
    if (cached_has_bits & 0x00000080u) {
      i_lblk_ = from.i_lblk_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      i_len_ = from.i_len_;
    }
    if (cached_has_bits & 0x00000200u) {
      i_pblk_ = from.i_pblk_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4ExtConvertToInitializedFastpathFtraceEvent::CopyFrom(const Ext4ExtConvertToInitializedFastpathFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtConvertToInitializedFastpathFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtConvertToInitializedFastpathFtraceEvent::InternalSwap(Ext4ExtConvertToInitializedFastpathFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtConvertToInitializedFastpathFtraceEvent, i_pblk_)
      + sizeof(Ext4ExtConvertToInitializedFastpathFtraceEvent::i_pblk_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtConvertToInitializedFastpathFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4ExtConvertToInitializedFastpathFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtConvertToInitializedFastpathFtraceEvent";
}


// ===================================================================

class Ext4ExtHandleUnwrittenExtentsFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtHandleUnwrittenExtentsFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_allocated(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_newblk(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

Ext4ExtHandleUnwrittenExtentsFtraceEvent::Ext4ExtHandleUnwrittenExtentsFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
}
Ext4ExtHandleUnwrittenExtentsFtraceEvent::Ext4ExtHandleUnwrittenExtentsFtraceEvent(const Ext4ExtHandleUnwrittenExtentsFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&newblk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(newblk_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
}

inline void Ext4ExtHandleUnwrittenExtentsFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&newblk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(newblk_));
}

Ext4ExtHandleUnwrittenExtentsFtraceEvent::~Ext4ExtHandleUnwrittenExtentsFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtHandleUnwrittenExtentsFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtHandleUnwrittenExtentsFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4ExtHandleUnwrittenExtentsFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&newblk_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(newblk_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4ExtHandleUnwrittenExtentsFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lblk = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_pblk(&has_bits);
          pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 allocated = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_allocated(&has_bits);
          allocated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 newblk = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_newblk(&has_bits);
          newblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4ExtHandleUnwrittenExtentsFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 flags = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_flags(), target);
  }

  // optional uint32 lblk = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_lblk(), target);
  }

  // optional uint64 pblk = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_pblk(), target);
  }

  // optional uint32 len = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_len(), target);
  }

  // optional uint32 allocated = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_allocated(), target);
  }

  // optional uint64 newblk = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_newblk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
  return target;
}

size_t Ext4ExtHandleUnwrittenExtentsFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 flags = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 lblk = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lblk());
    }

    // optional uint64 pblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pblk());
    }

    // optional uint32 len = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint32 allocated = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_allocated());
    }

    // optional uint64 newblk = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_newblk());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtHandleUnwrittenExtentsFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4ExtHandleUnwrittenExtentsFtraceEvent*>(
      &from));
}

void Ext4ExtHandleUnwrittenExtentsFtraceEvent::MergeFrom(const Ext4ExtHandleUnwrittenExtentsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000010u) {
      pblk_ = from.pblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000040u) {
      allocated_ = from.allocated_;
    }
    if (cached_has_bits & 0x00000080u) {
      newblk_ = from.newblk_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4ExtHandleUnwrittenExtentsFtraceEvent::CopyFrom(const Ext4ExtHandleUnwrittenExtentsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtHandleUnwrittenExtentsFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtHandleUnwrittenExtentsFtraceEvent::InternalSwap(Ext4ExtHandleUnwrittenExtentsFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtHandleUnwrittenExtentsFtraceEvent, newblk_)
      + sizeof(Ext4ExtHandleUnwrittenExtentsFtraceEvent::newblk_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtHandleUnwrittenExtentsFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4ExtHandleUnwrittenExtentsFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtHandleUnwrittenExtentsFtraceEvent";
}


// ===================================================================

class Ext4ExtInCacheFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtInCacheFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4ExtInCacheFtraceEvent::Ext4ExtInCacheFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtInCacheFtraceEvent)
}
Ext4ExtInCacheFtraceEvent::Ext4ExtInCacheFtraceEvent(const Ext4ExtInCacheFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtInCacheFtraceEvent)
}

inline void Ext4ExtInCacheFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
}

Ext4ExtInCacheFtraceEvent::~Ext4ExtInCacheFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtInCacheFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtInCacheFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtInCacheFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4ExtInCacheFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtInCacheFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ret_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4ExtInCacheFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4ExtInCacheFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtInCacheFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_lblk(), target);
  }

  // optional int32 ret = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtInCacheFtraceEvent)
  return target;
}

size_t Ext4ExtInCacheFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtInCacheFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lblk());
    }

    // optional int32 ret = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtInCacheFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4ExtInCacheFtraceEvent*>(
      &from));
}

void Ext4ExtInCacheFtraceEvent::MergeFrom(const Ext4ExtInCacheFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtInCacheFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      ret_ = from.ret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4ExtInCacheFtraceEvent::CopyFrom(const Ext4ExtInCacheFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtInCacheFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtInCacheFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtInCacheFtraceEvent::InternalSwap(Ext4ExtInCacheFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtInCacheFtraceEvent, ret_)
      + sizeof(Ext4ExtInCacheFtraceEvent::ret_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtInCacheFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4ExtInCacheFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtInCacheFtraceEvent";
}


// ===================================================================

class Ext4ExtLoadExtentFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtLoadExtentFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4ExtLoadExtentFtraceEvent::Ext4ExtLoadExtentFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
}
Ext4ExtLoadExtentFtraceEvent::Ext4ExtLoadExtentFtraceEvent(const Ext4ExtLoadExtentFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&lblk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(lblk_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
}

inline void Ext4ExtLoadExtentFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&lblk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(lblk_));
}

Ext4ExtLoadExtentFtraceEvent::~Ext4ExtLoadExtentFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtLoadExtentFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtLoadExtentFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4ExtLoadExtentFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lblk_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(lblk_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4ExtLoadExtentFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pblk(&has_bits);
          pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lblk = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4ExtLoadExtentFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 pblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_pblk(), target);
  }

  // optional uint32 lblk = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_lblk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
  return target;
}

size_t Ext4ExtLoadExtentFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 pblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pblk());
    }

    // optional uint32 lblk = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lblk());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtLoadExtentFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4ExtLoadExtentFtraceEvent*>(
      &from));
}

void Ext4ExtLoadExtentFtraceEvent::MergeFrom(const Ext4ExtLoadExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pblk_ = from.pblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      lblk_ = from.lblk_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4ExtLoadExtentFtraceEvent::CopyFrom(const Ext4ExtLoadExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtLoadExtentFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtLoadExtentFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtLoadExtentFtraceEvent::InternalSwap(Ext4ExtLoadExtentFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtLoadExtentFtraceEvent, lblk_)
      + sizeof(Ext4ExtLoadExtentFtraceEvent::lblk_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtLoadExtentFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4ExtLoadExtentFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtLoadExtentFtraceEvent";
}


// ===================================================================

class Ext4ExtMapBlocksEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtMapBlocksEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4ExtMapBlocksEnterFtraceEvent::Ext4ExtMapBlocksEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
}
Ext4ExtMapBlocksEnterFtraceEvent::Ext4ExtMapBlocksEnterFtraceEvent(const Ext4ExtMapBlocksEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
}

inline void Ext4ExtMapBlocksEnterFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
}

Ext4ExtMapBlocksEnterFtraceEvent::~Ext4ExtMapBlocksEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtMapBlocksEnterFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtMapBlocksEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4ExtMapBlocksEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flags_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4ExtMapBlocksEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4ExtMapBlocksEnterFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_lblk(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_len(), target);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
  return target;
}

size_t Ext4ExtMapBlocksEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtMapBlocksEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4ExtMapBlocksEnterFtraceEvent*>(
      &from));
}

void Ext4ExtMapBlocksEnterFtraceEvent::MergeFrom(const Ext4ExtMapBlocksEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      flags_ = from.flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4ExtMapBlocksEnterFtraceEvent::CopyFrom(const Ext4ExtMapBlocksEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtMapBlocksEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtMapBlocksEnterFtraceEvent::InternalSwap(Ext4ExtMapBlocksEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtMapBlocksEnterFtraceEvent, flags_)
      + sizeof(Ext4ExtMapBlocksEnterFtraceEvent::flags_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtMapBlocksEnterFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4ExtMapBlocksEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtMapBlocksEnterFtraceEvent";
}


// ===================================================================

class Ext4ExtMapBlocksExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtMapBlocksExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_mflags(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

Ext4ExtMapBlocksExitFtraceEvent::Ext4ExtMapBlocksExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
}
Ext4ExtMapBlocksExitFtraceEvent::Ext4ExtMapBlocksExitFtraceEvent(const Ext4ExtMapBlocksExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
}

inline void Ext4ExtMapBlocksExitFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
}

Ext4ExtMapBlocksExitFtraceEvent::~Ext4ExtMapBlocksExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtMapBlocksExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtMapBlocksExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4ExtMapBlocksExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ret_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4ExtMapBlocksExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pblk = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_pblk(&has_bits);
          pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mflags = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_mflags(&has_bits);
          mflags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4ExtMapBlocksExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 flags = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_flags(), target);
  }

  // optional uint64 pblk = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_pblk(), target);
  }

  // optional uint32 lblk = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_lblk(), target);
  }

  // optional uint32 len = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_len(), target);
  }

  // optional uint32 mflags = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_mflags(), target);
  }

  // optional int32 ret = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
  return target;
}

size_t Ext4ExtMapBlocksExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 pblk = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pblk());
    }

    // optional uint32 flags = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 lblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lblk());
    }

    // optional uint32 len = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint32 mflags = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mflags());
    }

    // optional int32 ret = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtMapBlocksExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4ExtMapBlocksExitFtraceEvent*>(
      &from));
}

void Ext4ExtMapBlocksExitFtraceEvent::MergeFrom(const Ext4ExtMapBlocksExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pblk_ = from.pblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000010u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000040u) {
      mflags_ = from.mflags_;
    }
    if (cached_has_bits & 0x00000080u) {
      ret_ = from.ret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4ExtMapBlocksExitFtraceEvent::CopyFrom(const Ext4ExtMapBlocksExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtMapBlocksExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtMapBlocksExitFtraceEvent::InternalSwap(Ext4ExtMapBlocksExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtMapBlocksExitFtraceEvent, ret_)
      + sizeof(Ext4ExtMapBlocksExitFtraceEvent::ret_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtMapBlocksExitFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4ExtMapBlocksExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtMapBlocksExitFtraceEvent";
}


// ===================================================================

class Ext4ExtPutInCacheFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtPutInCacheFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4ExtPutInCacheFtraceEvent::Ext4ExtPutInCacheFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
}
Ext4ExtPutInCacheFtraceEvent::Ext4ExtPutInCacheFtraceEvent(const Ext4ExtPutInCacheFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&start_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(start_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
}

inline void Ext4ExtPutInCacheFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&start_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(start_));
}

Ext4ExtPutInCacheFtraceEvent::~Ext4ExtPutInCacheFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtPutInCacheFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtPutInCacheFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4ExtPutInCacheFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&start_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(start_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4ExtPutInCacheFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 start = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_start(&has_bits);
          start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4ExtPutInCacheFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_lblk(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_len(), target);
  }

  // optional uint64 start = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_start(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
  return target;
}

size_t Ext4ExtPutInCacheFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint64 start = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_start());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtPutInCacheFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4ExtPutInCacheFtraceEvent*>(
      &from));
}

void Ext4ExtPutInCacheFtraceEvent::MergeFrom(const Ext4ExtPutInCacheFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      start_ = from.start_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4ExtPutInCacheFtraceEvent::CopyFrom(const Ext4ExtPutInCacheFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtPutInCacheFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtPutInCacheFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtPutInCacheFtraceEvent::InternalSwap(Ext4ExtPutInCacheFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtPutInCacheFtraceEvent, start_)
      + sizeof(Ext4ExtPutInCacheFtraceEvent::start_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtPutInCacheFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4ExtPutInCacheFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtPutInCacheFtraceEvent";
}


// ===================================================================

class Ext4ExtRemoveSpaceFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtRemoveSpaceFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_depth(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4ExtRemoveSpaceFtraceEvent::Ext4ExtRemoveSpaceFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
}
Ext4ExtRemoveSpaceFtraceEvent::Ext4ExtRemoveSpaceFtraceEvent(const Ext4ExtRemoveSpaceFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&depth_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(depth_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
}

inline void Ext4ExtRemoveSpaceFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&depth_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(depth_));
}

Ext4ExtRemoveSpaceFtraceEvent::~Ext4ExtRemoveSpaceFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtRemoveSpaceFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtRemoveSpaceFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4ExtRemoveSpaceFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&depth_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(depth_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4ExtRemoveSpaceFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 start = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_start(&has_bits);
          start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 end = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_end(&has_bits);
          end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 depth = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_depth(&has_bits);
          depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4ExtRemoveSpaceFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 start = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_start(), target);
  }

  // optional uint32 end = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_end(), target);
  }

  // optional int32 depth = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_depth(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
  return target;
}

size_t Ext4ExtRemoveSpaceFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 start = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_start());
    }

    // optional uint32 end = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_end());
    }

    // optional int32 depth = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_depth());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtRemoveSpaceFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4ExtRemoveSpaceFtraceEvent*>(
      &from));
}

void Ext4ExtRemoveSpaceFtraceEvent::MergeFrom(const Ext4ExtRemoveSpaceFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      start_ = from.start_;
    }
    if (cached_has_bits & 0x00000008u) {
      end_ = from.end_;
    }
    if (cached_has_bits & 0x00000010u) {
      depth_ = from.depth_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4ExtRemoveSpaceFtraceEvent::CopyFrom(const Ext4ExtRemoveSpaceFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtRemoveSpaceFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtRemoveSpaceFtraceEvent::InternalSwap(Ext4ExtRemoveSpaceFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtRemoveSpaceFtraceEvent, depth_)
      + sizeof(Ext4ExtRemoveSpaceFtraceEvent::depth_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtRemoveSpaceFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4ExtRemoveSpaceFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtRemoveSpaceFtraceEvent";
}


// ===================================================================

class Ext4ExtRemoveSpaceDoneFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtRemoveSpaceDoneFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_depth(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_partial(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_eh_entries(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_pc_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_pc_pclu(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_pc_state(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

Ext4ExtRemoveSpaceDoneFtraceEvent::Ext4ExtRemoveSpaceDoneFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
}
Ext4ExtRemoveSpaceDoneFtraceEvent::Ext4ExtRemoveSpaceDoneFtraceEvent(const Ext4ExtRemoveSpaceDoneFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&pc_state_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(pc_state_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
}

inline void Ext4ExtRemoveSpaceDoneFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&pc_state_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(pc_state_));
}

Ext4ExtRemoveSpaceDoneFtraceEvent::~Ext4ExtRemoveSpaceDoneFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtRemoveSpaceDoneFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtRemoveSpaceDoneFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4ExtRemoveSpaceDoneFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pc_pclu_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(pc_pclu_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&pc_lblk_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pc_state_) -
        reinterpret_cast<char*>(&pc_lblk_)) + sizeof(pc_state_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4ExtRemoveSpaceDoneFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 start = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_start(&has_bits);
          start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 end = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_end(&has_bits);
          end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 depth = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_depth(&has_bits);
          depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 partial = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_partial(&has_bits);
          partial_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 eh_entries = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_eh_entries(&has_bits);
          eh_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pc_lblk = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_pc_lblk(&has_bits);
          pc_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pc_pclu = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_pc_pclu(&has_bits);
          pc_pclu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pc_state = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_pc_state(&has_bits);
          pc_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4ExtRemoveSpaceDoneFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 start = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_start(), target);
  }

  // optional uint32 end = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_end(), target);
  }

  // optional int32 depth = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_depth(), target);
  }

  // optional int64 partial = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_partial(), target);
  }

  // optional uint32 eh_entries = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_eh_entries(), target);
  }

  // optional uint32 pc_lblk = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_pc_lblk(), target);
  }

  // optional uint64 pc_pclu = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_pc_pclu(), target);
  }

  // optional int32 pc_state = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_pc_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
  return target;
}

size_t Ext4ExtRemoveSpaceDoneFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 start = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_start());
    }

    // optional uint32 end = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_end());
    }

    // optional int64 partial = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_partial());
    }

    // optional int32 depth = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_depth());
    }

    // optional uint32 eh_entries = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_eh_entries());
    }

    // optional uint64 pc_pclu = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pc_pclu());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 pc_lblk = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pc_lblk());
    }

    // optional int32 pc_state = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pc_state());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtRemoveSpaceDoneFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4ExtRemoveSpaceDoneFtraceEvent*>(
      &from));
}

void Ext4ExtRemoveSpaceDoneFtraceEvent::MergeFrom(const Ext4ExtRemoveSpaceDoneFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      start_ = from.start_;
    }
    if (cached_has_bits & 0x00000008u) {
      end_ = from.end_;
    }
    if (cached_has_bits & 0x00000010u) {
      partial_ = from.partial_;
    }
    if (cached_has_bits & 0x00000020u) {
      depth_ = from.depth_;
    }
    if (cached_has_bits & 0x00000040u) {
      eh_entries_ = from.eh_entries_;
    }
    if (cached_has_bits & 0x00000080u) {
      pc_pclu_ = from.pc_pclu_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      pc_lblk_ = from.pc_lblk_;
    }
    if (cached_has_bits & 0x00000200u) {
      pc_state_ = from.pc_state_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4ExtRemoveSpaceDoneFtraceEvent::CopyFrom(const Ext4ExtRemoveSpaceDoneFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtRemoveSpaceDoneFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtRemoveSpaceDoneFtraceEvent::InternalSwap(Ext4ExtRemoveSpaceDoneFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtRemoveSpaceDoneFtraceEvent, pc_state_)
      + sizeof(Ext4ExtRemoveSpaceDoneFtraceEvent::pc_state_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtRemoveSpaceDoneFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4ExtRemoveSpaceDoneFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtRemoveSpaceDoneFtraceEvent";
}


// ===================================================================

class Ext4ExtRmIdxFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtRmIdxFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4ExtRmIdxFtraceEvent::Ext4ExtRmIdxFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
}
Ext4ExtRmIdxFtraceEvent::Ext4ExtRmIdxFtraceEvent(const Ext4ExtRmIdxFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&pblk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(pblk_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
}

inline void Ext4ExtRmIdxFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&pblk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(pblk_));
}

Ext4ExtRmIdxFtraceEvent::~Ext4ExtRmIdxFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtRmIdxFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtRmIdxFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4ExtRmIdxFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pblk_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(pblk_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4ExtRmIdxFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pblk(&has_bits);
          pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4ExtRmIdxFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 pblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_pblk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
  return target;
}

size_t Ext4ExtRmIdxFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 pblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pblk());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtRmIdxFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4ExtRmIdxFtraceEvent*>(
      &from));
}

void Ext4ExtRmIdxFtraceEvent::MergeFrom(const Ext4ExtRmIdxFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pblk_ = from.pblk_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4ExtRmIdxFtraceEvent::CopyFrom(const Ext4ExtRmIdxFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtRmIdxFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtRmIdxFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtRmIdxFtraceEvent::InternalSwap(Ext4ExtRmIdxFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtRmIdxFtraceEvent, pblk_)
      + sizeof(Ext4ExtRmIdxFtraceEvent::pblk_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtRmIdxFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4ExtRmIdxFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtRmIdxFtraceEvent";
}


// ===================================================================

class Ext4ExtRmLeafFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtRmLeafFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_partial(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ee_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ee_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_ee_len(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_pc_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_pc_pclu(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_pc_state(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

Ext4ExtRmLeafFtraceEvent::Ext4ExtRmLeafFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
}
Ext4ExtRmLeafFtraceEvent::Ext4ExtRmLeafFtraceEvent(const Ext4ExtRmLeafFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&pc_state_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(pc_state_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
}

inline void Ext4ExtRmLeafFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&pc_state_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(pc_state_));
}

Ext4ExtRmLeafFtraceEvent::~Ext4ExtRmLeafFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtRmLeafFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtRmLeafFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4ExtRmLeafFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pc_lblk_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(pc_lblk_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&pc_pclu_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pc_state_) -
        reinterpret_cast<char*>(&pc_pclu_)) + sizeof(pc_state_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4ExtRmLeafFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 partial = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_partial(&has_bits);
          partial_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_start(&has_bits);
          start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ee_lblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_ee_lblk(&has_bits);
          ee_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ee_pblk = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_ee_pblk(&has_bits);
          ee_pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ee_len = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_ee_len(&has_bits);
          ee_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pc_lblk = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_pc_lblk(&has_bits);
          pc_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pc_pclu = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_pc_pclu(&has_bits);
          pc_pclu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pc_state = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_pc_state(&has_bits);
          pc_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4ExtRmLeafFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 partial = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_partial(), target);
  }

  // optional uint32 start = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_start(), target);
  }

  // optional uint32 ee_lblk = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_ee_lblk(), target);
  }

  // optional uint64 ee_pblk = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_ee_pblk(), target);
  }

  // optional int32 ee_len = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_ee_len(), target);
  }

  // optional uint32 pc_lblk = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_pc_lblk(), target);
  }

  // optional uint64 pc_pclu = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_pc_pclu(), target);
  }

  // optional int32 pc_state = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_pc_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
  return target;
}

size_t Ext4ExtRmLeafFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 partial = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_partial());
    }

    // optional uint32 start = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_start());
    }

    // optional uint32 ee_lblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ee_lblk());
    }

    // optional uint64 ee_pblk = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ee_pblk());
    }

    // optional int32 ee_len = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ee_len());
    }

    // optional uint32 pc_lblk = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pc_lblk());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint64 pc_pclu = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pc_pclu());
    }

    // optional int32 pc_state = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pc_state());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtRmLeafFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4ExtRmLeafFtraceEvent*>(
      &from));
}

void Ext4ExtRmLeafFtraceEvent::MergeFrom(const Ext4ExtRmLeafFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      partial_ = from.partial_;
    }
    if (cached_has_bits & 0x00000008u) {
      start_ = from.start_;
    }
    if (cached_has_bits & 0x00000010u) {
      ee_lblk_ = from.ee_lblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      ee_pblk_ = from.ee_pblk_;
    }
    if (cached_has_bits & 0x00000040u) {
      ee_len_ = from.ee_len_;
    }
    if (cached_has_bits & 0x00000080u) {
      pc_lblk_ = from.pc_lblk_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      pc_pclu_ = from.pc_pclu_;
    }
    if (cached_has_bits & 0x00000200u) {
      pc_state_ = from.pc_state_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4ExtRmLeafFtraceEvent::CopyFrom(const Ext4ExtRmLeafFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtRmLeafFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtRmLeafFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtRmLeafFtraceEvent::InternalSwap(Ext4ExtRmLeafFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtRmLeafFtraceEvent, pc_state_)
      + sizeof(Ext4ExtRmLeafFtraceEvent::pc_state_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtRmLeafFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4ExtRmLeafFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtRmLeafFtraceEvent";
}


// ===================================================================

class Ext4ExtShowExtentFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ExtShowExtentFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4ExtShowExtentFtraceEvent::Ext4ExtShowExtentFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
}
Ext4ExtShowExtentFtraceEvent::Ext4ExtShowExtentFtraceEvent(const Ext4ExtShowExtentFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
}

inline void Ext4ExtShowExtentFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(len_));
}

Ext4ExtShowExtentFtraceEvent::~Ext4ExtShowExtentFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ExtShowExtentFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ExtShowExtentFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4ExtShowExtentFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4ExtShowExtentFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pblk(&has_bits);
          pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lblk = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4ExtShowExtentFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 pblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_pblk(), target);
  }

  // optional uint32 lblk = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_lblk(), target);
  }

  // optional uint32 len = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
  return target;
}

size_t Ext4ExtShowExtentFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 pblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pblk());
    }

    // optional uint32 lblk = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lblk());
    }

    // optional uint32 len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ExtShowExtentFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4ExtShowExtentFtraceEvent*>(
      &from));
}

void Ext4ExtShowExtentFtraceEvent::MergeFrom(const Ext4ExtShowExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pblk_ = from.pblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000010u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4ExtShowExtentFtraceEvent::CopyFrom(const Ext4ExtShowExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ExtShowExtentFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ExtShowExtentFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ExtShowExtentFtraceEvent::InternalSwap(Ext4ExtShowExtentFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ExtShowExtentFtraceEvent, len_)
      + sizeof(Ext4ExtShowExtentFtraceEvent::len_)
      - PROTOBUF_FIELD_OFFSET(Ext4ExtShowExtentFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4ExtShowExtentFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ExtShowExtentFtraceEvent";
}


// ===================================================================

class Ext4FallocateEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4FallocateEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4FallocateEnterFtraceEvent::Ext4FallocateEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4FallocateEnterFtraceEvent)
}
Ext4FallocateEnterFtraceEvent::Ext4FallocateEnterFtraceEvent(const Ext4FallocateEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4FallocateEnterFtraceEvent)
}

inline void Ext4FallocateEnterFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
}

Ext4FallocateEnterFtraceEvent::~Ext4FallocateEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4FallocateEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4FallocateEnterFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4FallocateEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4FallocateEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4FallocateEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4FallocateEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 pos = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_pos(&has_bits);
          pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4FallocateEnterFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4FallocateEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 offset = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_offset(), target);
  }

  // optional int64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_len(), target);
  }

  // optional int32 mode = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_mode(), target);
  }

  // optional int64 pos = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_pos(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4FallocateEnterFtraceEvent)
  return target;
}

size_t Ext4FallocateEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4FallocateEnterFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 offset = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_offset());
    }

    // optional int64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_len());
    }

    // optional int64 pos = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_pos());
    }

    // optional int32 mode = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mode());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4FallocateEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4FallocateEnterFtraceEvent*>(
      &from));
}

void Ext4FallocateEnterFtraceEvent::MergeFrom(const Ext4FallocateEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4FallocateEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      pos_ = from.pos_;
    }
    if (cached_has_bits & 0x00000020u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4FallocateEnterFtraceEvent::CopyFrom(const Ext4FallocateEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4FallocateEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4FallocateEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4FallocateEnterFtraceEvent::InternalSwap(Ext4FallocateEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4FallocateEnterFtraceEvent, mode_)
      + sizeof(Ext4FallocateEnterFtraceEvent::mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4FallocateEnterFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4FallocateEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4FallocateEnterFtraceEvent";
}


// ===================================================================

class Ext4FallocateExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4FallocateExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4FallocateExitFtraceEvent::Ext4FallocateExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4FallocateExitFtraceEvent)
}
Ext4FallocateExitFtraceEvent::Ext4FallocateExitFtraceEvent(const Ext4FallocateExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4FallocateExitFtraceEvent)
}

inline void Ext4FallocateExitFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
}

Ext4FallocateExitFtraceEvent::~Ext4FallocateExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4FallocateExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4FallocateExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4FallocateExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4FallocateExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4FallocateExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ret_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4FallocateExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_blocks(&has_bits);
          blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4FallocateExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4FallocateExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_pos(), target);
  }

  // optional uint32 blocks = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_blocks(), target);
  }

  // optional int32 ret = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4FallocateExitFtraceEvent)
  return target;
}

size_t Ext4FallocateExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4FallocateExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_pos());
    }

    // optional uint32 blocks = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_blocks());
    }

    // optional int32 ret = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4FallocateExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4FallocateExitFtraceEvent*>(
      &from));
}

void Ext4FallocateExitFtraceEvent::MergeFrom(const Ext4FallocateExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4FallocateExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pos_ = from.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      blocks_ = from.blocks_;
    }
    if (cached_has_bits & 0x00000010u) {
      ret_ = from.ret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4FallocateExitFtraceEvent::CopyFrom(const Ext4FallocateExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4FallocateExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4FallocateExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4FallocateExitFtraceEvent::InternalSwap(Ext4FallocateExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4FallocateExitFtraceEvent, ret_)
      + sizeof(Ext4FallocateExitFtraceEvent::ret_)
      - PROTOBUF_FIELD_OFFSET(Ext4FallocateExitFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4FallocateExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4FallocateExitFtraceEvent";
}


// ===================================================================

class Ext4FindDelallocRangeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4FindDelallocRangeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_from(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_to(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_reverse(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_found(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_found_blk(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

Ext4FindDelallocRangeFtraceEvent::Ext4FindDelallocRangeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
}
Ext4FindDelallocRangeFtraceEvent::Ext4FindDelallocRangeFtraceEvent(const Ext4FindDelallocRangeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&found_blk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(found_blk_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
}

inline void Ext4FindDelallocRangeFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&found_blk_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(found_blk_));
}

Ext4FindDelallocRangeFtraceEvent::~Ext4FindDelallocRangeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4FindDelallocRangeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4FindDelallocRangeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4FindDelallocRangeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&found_blk_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(found_blk_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4FindDelallocRangeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 from = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_from(&has_bits);
          from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 to = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_to(&has_bits);
          to_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 reverse = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_reverse(&has_bits);
          reverse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 found = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_found(&has_bits);
          found_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 found_blk = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_found_blk(&has_bits);
          found_blk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4FindDelallocRangeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 from = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_from(), target);
  }

  // optional uint32 to = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_to(), target);
  }

  // optional int32 reverse = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_reverse(), target);
  }

  // optional int32 found = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_found(), target);
  }

  // optional uint32 found_blk = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_found_blk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
  return target;
}

size_t Ext4FindDelallocRangeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 from = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_from());
    }

    // optional uint32 to = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_to());
    }

    // optional int32 reverse = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_reverse());
    }

    // optional int32 found = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_found());
    }

    // optional uint32 found_blk = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_found_blk());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4FindDelallocRangeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4FindDelallocRangeFtraceEvent*>(
      &from));
}

void Ext4FindDelallocRangeFtraceEvent::MergeFrom(const Ext4FindDelallocRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      from_ = from.from_;
    }
    if (cached_has_bits & 0x00000008u) {
      to_ = from.to_;
    }
    if (cached_has_bits & 0x00000010u) {
      reverse_ = from.reverse_;
    }
    if (cached_has_bits & 0x00000020u) {
      found_ = from.found_;
    }
    if (cached_has_bits & 0x00000040u) {
      found_blk_ = from.found_blk_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4FindDelallocRangeFtraceEvent::CopyFrom(const Ext4FindDelallocRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4FindDelallocRangeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4FindDelallocRangeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4FindDelallocRangeFtraceEvent::InternalSwap(Ext4FindDelallocRangeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4FindDelallocRangeFtraceEvent, found_blk_)
      + sizeof(Ext4FindDelallocRangeFtraceEvent::found_blk_)
      - PROTOBUF_FIELD_OFFSET(Ext4FindDelallocRangeFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4FindDelallocRangeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4FindDelallocRangeFtraceEvent";
}


// ===================================================================

class Ext4ForgetFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ForgetFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_block(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4ForgetFtraceEvent::Ext4ForgetFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ForgetFtraceEvent)
}
Ext4ForgetFtraceEvent::Ext4ForgetFtraceEvent(const Ext4ForgetFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ForgetFtraceEvent)
}

inline void Ext4ForgetFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
}

Ext4ForgetFtraceEvent::~Ext4ForgetFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ForgetFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ForgetFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ForgetFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4ForgetFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ForgetFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4ForgetFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 block = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_block(&has_bits);
          block_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 is_metadata = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_metadata(&has_bits);
          is_metadata_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4ForgetFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ForgetFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 block = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_block(), target);
  }

  // optional int32 is_metadata = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_is_metadata(), target);
  }

  // optional uint32 mode = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ForgetFtraceEvent)
  return target;
}

size_t Ext4ForgetFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ForgetFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 block = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_block());
    }

    // optional int32 is_metadata = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_is_metadata());
    }

    // optional uint32 mode = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ForgetFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4ForgetFtraceEvent*>(
      &from));
}

void Ext4ForgetFtraceEvent::MergeFrom(const Ext4ForgetFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ForgetFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      block_ = from.block_;
    }
    if (cached_has_bits & 0x00000008u) {
      is_metadata_ = from.is_metadata_;
    }
    if (cached_has_bits & 0x00000010u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4ForgetFtraceEvent::CopyFrom(const Ext4ForgetFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ForgetFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ForgetFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ForgetFtraceEvent::InternalSwap(Ext4ForgetFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ForgetFtraceEvent, mode_)
      + sizeof(Ext4ForgetFtraceEvent::mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4ForgetFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4ForgetFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ForgetFtraceEvent";
}


// ===================================================================

class Ext4FreeBlocksFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4FreeBlocksFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_block(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4FreeBlocksFtraceEvent::Ext4FreeBlocksFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4FreeBlocksFtraceEvent)
}
Ext4FreeBlocksFtraceEvent::Ext4FreeBlocksFtraceEvent(const Ext4FreeBlocksFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4FreeBlocksFtraceEvent)
}

inline void Ext4FreeBlocksFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
}

Ext4FreeBlocksFtraceEvent::~Ext4FreeBlocksFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4FreeBlocksFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4FreeBlocksFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4FreeBlocksFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4FreeBlocksFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4FreeBlocksFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4FreeBlocksFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 block = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_block(&has_bits);
          block_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mode = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4FreeBlocksFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4FreeBlocksFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 block = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_block(), target);
  }

  // optional uint64 count = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_count(), target);
  }

  // optional int32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_flags(), target);
  }

  // optional uint32 mode = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4FreeBlocksFtraceEvent)
  return target;
}

size_t Ext4FreeBlocksFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4FreeBlocksFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 block = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_block());
    }

    // optional uint64 count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_count());
    }

    // optional int32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 mode = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4FreeBlocksFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4FreeBlocksFtraceEvent*>(
      &from));
}

void Ext4FreeBlocksFtraceEvent::MergeFrom(const Ext4FreeBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4FreeBlocksFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      block_ = from.block_;
    }
    if (cached_has_bits & 0x00000008u) {
      count_ = from.count_;
    }
    if (cached_has_bits & 0x00000010u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000020u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4FreeBlocksFtraceEvent::CopyFrom(const Ext4FreeBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4FreeBlocksFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4FreeBlocksFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4FreeBlocksFtraceEvent::InternalSwap(Ext4FreeBlocksFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4FreeBlocksFtraceEvent, mode_)
      + sizeof(Ext4FreeBlocksFtraceEvent::mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4FreeBlocksFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4FreeBlocksFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4FreeBlocksFtraceEvent";
}


// ===================================================================

class Ext4FreeInodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4FreeInodeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4FreeInodeFtraceEvent::Ext4FreeInodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4FreeInodeFtraceEvent)
}
Ext4FreeInodeFtraceEvent::Ext4FreeInodeFtraceEvent(const Ext4FreeInodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4FreeInodeFtraceEvent)
}

inline void Ext4FreeInodeFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
}

Ext4FreeInodeFtraceEvent::~Ext4FreeInodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4FreeInodeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4FreeInodeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4FreeInodeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4FreeInodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4FreeInodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4FreeInodeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 uid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_uid(&has_bits);
          uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_gid(&has_bits);
          gid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blocks = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_blocks(&has_bits);
          blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mode = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4FreeInodeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4FreeInodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 uid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_uid(), target);
  }

  // optional uint32 gid = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_gid(), target);
  }

  // optional uint64 blocks = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_blocks(), target);
  }

  // optional uint32 mode = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4FreeInodeFtraceEvent)
  return target;
}

size_t Ext4FreeInodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4FreeInodeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 uid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_uid());
    }

    // optional uint32 gid = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gid());
    }

    // optional uint64 blocks = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_blocks());
    }

    // optional uint32 mode = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4FreeInodeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4FreeInodeFtraceEvent*>(
      &from));
}

void Ext4FreeInodeFtraceEvent::MergeFrom(const Ext4FreeInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4FreeInodeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      uid_ = from.uid_;
    }
    if (cached_has_bits & 0x00000008u) {
      gid_ = from.gid_;
    }
    if (cached_has_bits & 0x00000010u) {
      blocks_ = from.blocks_;
    }
    if (cached_has_bits & 0x00000020u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4FreeInodeFtraceEvent::CopyFrom(const Ext4FreeInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4FreeInodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4FreeInodeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4FreeInodeFtraceEvent::InternalSwap(Ext4FreeInodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4FreeInodeFtraceEvent, mode_)
      + sizeof(Ext4FreeInodeFtraceEvent::mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4FreeInodeFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4FreeInodeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4FreeInodeFtraceEvent";
}


// ===================================================================

class Ext4GetImpliedClusterAllocExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4GetImpliedClusterAllocExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4GetImpliedClusterAllocExitFtraceEvent::Ext4GetImpliedClusterAllocExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
}
Ext4GetImpliedClusterAllocExitFtraceEvent::Ext4GetImpliedClusterAllocExitFtraceEvent(const Ext4GetImpliedClusterAllocExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
}

inline void Ext4GetImpliedClusterAllocExitFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
}

Ext4GetImpliedClusterAllocExitFtraceEvent::~Ext4GetImpliedClusterAllocExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4GetImpliedClusterAllocExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4GetImpliedClusterAllocExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4GetImpliedClusterAllocExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ret_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4GetImpliedClusterAllocExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pblk = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_pblk(&has_bits);
          pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4GetImpliedClusterAllocExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint32 flags = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_flags(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_lblk(), target);
  }

  // optional uint64 pblk = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_pblk(), target);
  }

  // optional uint32 len = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_len(), target);
  }

  // optional int32 ret = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
  return target;
}

size_t Ext4GetImpliedClusterAllocExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint32 flags = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lblk());
    }

    // optional uint64 pblk = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pblk());
    }

    // optional uint32 len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional int32 ret = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4GetImpliedClusterAllocExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4GetImpliedClusterAllocExitFtraceEvent*>(
      &from));
}

void Ext4GetImpliedClusterAllocExitFtraceEvent::MergeFrom(const Ext4GetImpliedClusterAllocExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      pblk_ = from.pblk_;
    }
    if (cached_has_bits & 0x00000010u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000020u) {
      ret_ = from.ret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4GetImpliedClusterAllocExitFtraceEvent::CopyFrom(const Ext4GetImpliedClusterAllocExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4GetImpliedClusterAllocExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4GetImpliedClusterAllocExitFtraceEvent::InternalSwap(Ext4GetImpliedClusterAllocExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4GetImpliedClusterAllocExitFtraceEvent, ret_)
      + sizeof(Ext4GetImpliedClusterAllocExitFtraceEvent::ret_)
      - PROTOBUF_FIELD_OFFSET(Ext4GetImpliedClusterAllocExitFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4GetImpliedClusterAllocExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4GetImpliedClusterAllocExitFtraceEvent";
}


// ===================================================================

class Ext4GetReservedClusterAllocFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4GetReservedClusterAllocFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4GetReservedClusterAllocFtraceEvent::Ext4GetReservedClusterAllocFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
}
Ext4GetReservedClusterAllocFtraceEvent::Ext4GetReservedClusterAllocFtraceEvent(const Ext4GetReservedClusterAllocFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
}

inline void Ext4GetReservedClusterAllocFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(len_));
}

Ext4GetReservedClusterAllocFtraceEvent::~Ext4GetReservedClusterAllocFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4GetReservedClusterAllocFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4GetReservedClusterAllocFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4GetReservedClusterAllocFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4GetReservedClusterAllocFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4GetReservedClusterAllocFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_lblk(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
  return target;
}

size_t Ext4GetReservedClusterAllocFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4GetReservedClusterAllocFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4GetReservedClusterAllocFtraceEvent*>(
      &from));
}

void Ext4GetReservedClusterAllocFtraceEvent::MergeFrom(const Ext4GetReservedClusterAllocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4GetReservedClusterAllocFtraceEvent::CopyFrom(const Ext4GetReservedClusterAllocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4GetReservedClusterAllocFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4GetReservedClusterAllocFtraceEvent::InternalSwap(Ext4GetReservedClusterAllocFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4GetReservedClusterAllocFtraceEvent, len_)
      + sizeof(Ext4GetReservedClusterAllocFtraceEvent::len_)
      - PROTOBUF_FIELD_OFFSET(Ext4GetReservedClusterAllocFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4GetReservedClusterAllocFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4GetReservedClusterAllocFtraceEvent";
}


// ===================================================================

class Ext4IndMapBlocksEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4IndMapBlocksEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4IndMapBlocksEnterFtraceEvent::Ext4IndMapBlocksEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
}
Ext4IndMapBlocksEnterFtraceEvent::Ext4IndMapBlocksEnterFtraceEvent(const Ext4IndMapBlocksEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
}

inline void Ext4IndMapBlocksEnterFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
}

Ext4IndMapBlocksEnterFtraceEvent::~Ext4IndMapBlocksEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4IndMapBlocksEnterFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4IndMapBlocksEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4IndMapBlocksEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flags_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4IndMapBlocksEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lblk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4IndMapBlocksEnterFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 lblk = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_lblk(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_len(), target);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
  return target;
}

size_t Ext4IndMapBlocksEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 lblk = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lblk());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4IndMapBlocksEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4IndMapBlocksEnterFtraceEvent*>(
      &from));
}

void Ext4IndMapBlocksEnterFtraceEvent::MergeFrom(const Ext4IndMapBlocksEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      flags_ = from.flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4IndMapBlocksEnterFtraceEvent::CopyFrom(const Ext4IndMapBlocksEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4IndMapBlocksEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4IndMapBlocksEnterFtraceEvent::InternalSwap(Ext4IndMapBlocksEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4IndMapBlocksEnterFtraceEvent, flags_)
      + sizeof(Ext4IndMapBlocksEnterFtraceEvent::flags_)
      - PROTOBUF_FIELD_OFFSET(Ext4IndMapBlocksEnterFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4IndMapBlocksEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4IndMapBlocksEnterFtraceEvent";
}


// ===================================================================

class Ext4IndMapBlocksExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4IndMapBlocksExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_mflags(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

Ext4IndMapBlocksExitFtraceEvent::Ext4IndMapBlocksExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
}
Ext4IndMapBlocksExitFtraceEvent::Ext4IndMapBlocksExitFtraceEvent(const Ext4IndMapBlocksExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
}

inline void Ext4IndMapBlocksExitFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
}

Ext4IndMapBlocksExitFtraceEvent::~Ext4IndMapBlocksExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4IndMapBlocksExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4IndMapBlocksExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4IndMapBlocksExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ret_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4IndMapBlocksExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pblk = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_pblk(&has_bits);
          pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lblk = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_lblk(&has_bits);
          lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mflags = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_mflags(&has_bits);
          mflags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4IndMapBlocksExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 flags = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_flags(), target);
  }

  // optional uint64 pblk = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_pblk(), target);
  }

  // optional uint32 lblk = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_lblk(), target);
  }

  // optional uint32 len = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_len(), target);
  }

  // optional uint32 mflags = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_mflags(), target);
  }

  // optional int32 ret = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
  return target;
}

size_t Ext4IndMapBlocksExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 pblk = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pblk());
    }

    // optional uint32 flags = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 lblk = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lblk());
    }

    // optional uint32 len = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint32 mflags = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mflags());
    }

    // optional int32 ret = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4IndMapBlocksExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4IndMapBlocksExitFtraceEvent*>(
      &from));
}

void Ext4IndMapBlocksExitFtraceEvent::MergeFrom(const Ext4IndMapBlocksExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pblk_ = from.pblk_;
    }
    if (cached_has_bits & 0x00000008u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000010u) {
      lblk_ = from.lblk_;
    }
    if (cached_has_bits & 0x00000020u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000040u) {
      mflags_ = from.mflags_;
    }
    if (cached_has_bits & 0x00000080u) {
      ret_ = from.ret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4IndMapBlocksExitFtraceEvent::CopyFrom(const Ext4IndMapBlocksExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4IndMapBlocksExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4IndMapBlocksExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4IndMapBlocksExitFtraceEvent::InternalSwap(Ext4IndMapBlocksExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4IndMapBlocksExitFtraceEvent, ret_)
      + sizeof(Ext4IndMapBlocksExitFtraceEvent::ret_)
      - PROTOBUF_FIELD_OFFSET(Ext4IndMapBlocksExitFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4IndMapBlocksExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4IndMapBlocksExitFtraceEvent";
}


// ===================================================================

class Ext4InsertRangeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4InsertRangeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4InsertRangeFtraceEvent::Ext4InsertRangeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4InsertRangeFtraceEvent)
}
Ext4InsertRangeFtraceEvent::Ext4InsertRangeFtraceEvent(const Ext4InsertRangeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4InsertRangeFtraceEvent)
}

inline void Ext4InsertRangeFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(len_));
}

Ext4InsertRangeFtraceEvent::~Ext4InsertRangeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4InsertRangeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4InsertRangeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4InsertRangeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4InsertRangeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4InsertRangeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4InsertRangeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4InsertRangeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4InsertRangeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 offset = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_offset(), target);
  }

  // optional int64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4InsertRangeFtraceEvent)
  return target;
}

size_t Ext4InsertRangeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4InsertRangeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 offset = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_offset());
    }

    // optional int64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4InsertRangeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4InsertRangeFtraceEvent*>(
      &from));
}

void Ext4InsertRangeFtraceEvent::MergeFrom(const Ext4InsertRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4InsertRangeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4InsertRangeFtraceEvent::CopyFrom(const Ext4InsertRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4InsertRangeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4InsertRangeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4InsertRangeFtraceEvent::InternalSwap(Ext4InsertRangeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4InsertRangeFtraceEvent, len_)
      + sizeof(Ext4InsertRangeFtraceEvent::len_)
      - PROTOBUF_FIELD_OFFSET(Ext4InsertRangeFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4InsertRangeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4InsertRangeFtraceEvent";
}


// ===================================================================

class Ext4InvalidatepageFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4InvalidatepageFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4InvalidatepageFtraceEvent::Ext4InvalidatepageFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4InvalidatepageFtraceEvent)
}
Ext4InvalidatepageFtraceEvent::Ext4InvalidatepageFtraceEvent(const Ext4InvalidatepageFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&length_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(length_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4InvalidatepageFtraceEvent)
}

inline void Ext4InvalidatepageFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&length_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(length_));
}

Ext4InvalidatepageFtraceEvent::~Ext4InvalidatepageFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4InvalidatepageFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4InvalidatepageFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4InvalidatepageFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4InvalidatepageFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4InvalidatepageFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&length_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(length_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4InvalidatepageFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 offset = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 length = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_length(&has_bits);
          length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4InvalidatepageFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4InvalidatepageFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_index(), target);
  }

  // optional uint64 offset = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_offset(), target);
  }

  // optional uint32 length = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_length(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4InvalidatepageFtraceEvent)
  return target;
}

size_t Ext4InvalidatepageFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4InvalidatepageFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_index());
    }

    // optional uint64 offset = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_offset());
    }

    // optional uint32 length = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_length());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4InvalidatepageFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4InvalidatepageFtraceEvent*>(
      &from));
}

void Ext4InvalidatepageFtraceEvent::MergeFrom(const Ext4InvalidatepageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4InvalidatepageFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      index_ = from.index_;
    }
    if (cached_has_bits & 0x00000008u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000010u) {
      length_ = from.length_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4InvalidatepageFtraceEvent::CopyFrom(const Ext4InvalidatepageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4InvalidatepageFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4InvalidatepageFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4InvalidatepageFtraceEvent::InternalSwap(Ext4InvalidatepageFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4InvalidatepageFtraceEvent, length_)
      + sizeof(Ext4InvalidatepageFtraceEvent::length_)
      - PROTOBUF_FIELD_OFFSET(Ext4InvalidatepageFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4InvalidatepageFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4InvalidatepageFtraceEvent";
}


// ===================================================================

class Ext4JournalStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4JournalStartFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rsv_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nblocks(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_revoke_creds(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4JournalStartFtraceEvent::Ext4JournalStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4JournalStartFtraceEvent)
}
Ext4JournalStartFtraceEvent::Ext4JournalStartFtraceEvent(const Ext4JournalStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&revoke_creds_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(revoke_creds_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4JournalStartFtraceEvent)
}

inline void Ext4JournalStartFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&revoke_creds_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(revoke_creds_));
}

Ext4JournalStartFtraceEvent::~Ext4JournalStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4JournalStartFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4JournalStartFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4JournalStartFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4JournalStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4JournalStartFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&revoke_creds_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(revoke_creds_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4JournalStartFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ip(&has_bits);
          ip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_blocks(&has_bits);
          blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 rsv_blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_rsv_blocks(&has_bits);
          rsv_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 nblocks = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_nblocks(&has_bits);
          nblocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 revoke_creds = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_revoke_creds(&has_bits);
          revoke_creds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4JournalStartFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4JournalStartFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ip = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ip(), target);
  }

  // optional int32 blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_blocks(), target);
  }

  // optional int32 rsv_blocks = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_rsv_blocks(), target);
  }

  // optional int32 nblocks = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_nblocks(), target);
  }

  // optional int32 revoke_creds = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_revoke_creds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4JournalStartFtraceEvent)
  return target;
}

size_t Ext4JournalStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4JournalStartFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ip = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ip());
    }

    // optional int32 blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_blocks());
    }

    // optional int32 rsv_blocks = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rsv_blocks());
    }

    // optional int32 nblocks = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nblocks());
    }

    // optional int32 revoke_creds = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_revoke_creds());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4JournalStartFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4JournalStartFtraceEvent*>(
      &from));
}

void Ext4JournalStartFtraceEvent::MergeFrom(const Ext4JournalStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4JournalStartFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ip_ = from.ip_;
    }
    if (cached_has_bits & 0x00000004u) {
      blocks_ = from.blocks_;
    }
    if (cached_has_bits & 0x00000008u) {
      rsv_blocks_ = from.rsv_blocks_;
    }
    if (cached_has_bits & 0x00000010u) {
      nblocks_ = from.nblocks_;
    }
    if (cached_has_bits & 0x00000020u) {
      revoke_creds_ = from.revoke_creds_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4JournalStartFtraceEvent::CopyFrom(const Ext4JournalStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4JournalStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4JournalStartFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4JournalStartFtraceEvent::InternalSwap(Ext4JournalStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4JournalStartFtraceEvent, revoke_creds_)
      + sizeof(Ext4JournalStartFtraceEvent::revoke_creds_)
      - PROTOBUF_FIELD_OFFSET(Ext4JournalStartFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4JournalStartFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4JournalStartFtraceEvent";
}


// ===================================================================

class Ext4JournalStartReservedFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4JournalStartReservedFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4JournalStartReservedFtraceEvent::Ext4JournalStartReservedFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
}
Ext4JournalStartReservedFtraceEvent::Ext4JournalStartReservedFtraceEvent(const Ext4JournalStartReservedFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&blocks_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
}

inline void Ext4JournalStartReservedFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&blocks_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
}

Ext4JournalStartReservedFtraceEvent::~Ext4JournalStartReservedFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4JournalStartReservedFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4JournalStartReservedFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4JournalStartReservedFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&blocks_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4JournalStartReservedFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ip(&has_bits);
          ip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_blocks(&has_bits);
          blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4JournalStartReservedFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ip = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ip(), target);
  }

  // optional int32 blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_blocks(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
  return target;
}

size_t Ext4JournalStartReservedFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ip = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ip());
    }

    // optional int32 blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_blocks());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4JournalStartReservedFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4JournalStartReservedFtraceEvent*>(
      &from));
}

void Ext4JournalStartReservedFtraceEvent::MergeFrom(const Ext4JournalStartReservedFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ip_ = from.ip_;
    }
    if (cached_has_bits & 0x00000004u) {
      blocks_ = from.blocks_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4JournalStartReservedFtraceEvent::CopyFrom(const Ext4JournalStartReservedFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4JournalStartReservedFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4JournalStartReservedFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4JournalStartReservedFtraceEvent::InternalSwap(Ext4JournalStartReservedFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4JournalStartReservedFtraceEvent, blocks_)
      + sizeof(Ext4JournalStartReservedFtraceEvent::blocks_)
      - PROTOBUF_FIELD_OFFSET(Ext4JournalStartReservedFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4JournalStartReservedFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4JournalStartReservedFtraceEvent";
}


// ===================================================================

class Ext4JournalledInvalidatepageFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4JournalledInvalidatepageFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4JournalledInvalidatepageFtraceEvent::Ext4JournalledInvalidatepageFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
}
Ext4JournalledInvalidatepageFtraceEvent::Ext4JournalledInvalidatepageFtraceEvent(const Ext4JournalledInvalidatepageFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&length_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(length_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
}

inline void Ext4JournalledInvalidatepageFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&length_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(length_));
}

Ext4JournalledInvalidatepageFtraceEvent::~Ext4JournalledInvalidatepageFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4JournalledInvalidatepageFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4JournalledInvalidatepageFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4JournalledInvalidatepageFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&length_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(length_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4JournalledInvalidatepageFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 offset = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 length = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_length(&has_bits);
          length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4JournalledInvalidatepageFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_index(), target);
  }

  // optional uint64 offset = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_offset(), target);
  }

  // optional uint32 length = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_length(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
  return target;
}

size_t Ext4JournalledInvalidatepageFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_index());
    }

    // optional uint64 offset = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_offset());
    }

    // optional uint32 length = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_length());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4JournalledInvalidatepageFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4JournalledInvalidatepageFtraceEvent*>(
      &from));
}

void Ext4JournalledInvalidatepageFtraceEvent::MergeFrom(const Ext4JournalledInvalidatepageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      index_ = from.index_;
    }
    if (cached_has_bits & 0x00000008u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000010u) {
      length_ = from.length_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4JournalledInvalidatepageFtraceEvent::CopyFrom(const Ext4JournalledInvalidatepageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4JournalledInvalidatepageFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4JournalledInvalidatepageFtraceEvent::InternalSwap(Ext4JournalledInvalidatepageFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4JournalledInvalidatepageFtraceEvent, length_)
      + sizeof(Ext4JournalledInvalidatepageFtraceEvent::length_)
      - PROTOBUF_FIELD_OFFSET(Ext4JournalledInvalidatepageFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4JournalledInvalidatepageFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4JournalledInvalidatepageFtraceEvent";
}


// ===================================================================

class Ext4JournalledWriteEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4JournalledWriteEndFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_copied(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4JournalledWriteEndFtraceEvent::Ext4JournalledWriteEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
}
Ext4JournalledWriteEndFtraceEvent::Ext4JournalledWriteEndFtraceEvent(const Ext4JournalledWriteEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&copied_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(copied_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
}

inline void Ext4JournalledWriteEndFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&copied_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(copied_));
}

Ext4JournalledWriteEndFtraceEvent::~Ext4JournalledWriteEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4JournalledWriteEndFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4JournalledWriteEndFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4JournalledWriteEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&copied_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(copied_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4JournalledWriteEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 copied = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_copied(&has_bits);
          copied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4JournalledWriteEndFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_pos(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_len(), target);
  }

  // optional uint32 copied = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_copied(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
  return target;
}

size_t Ext4JournalledWriteEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_pos());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint32 copied = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_copied());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4JournalledWriteEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4JournalledWriteEndFtraceEvent*>(
      &from));
}

void Ext4JournalledWriteEndFtraceEvent::MergeFrom(const Ext4JournalledWriteEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pos_ = from.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      copied_ = from.copied_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4JournalledWriteEndFtraceEvent::CopyFrom(const Ext4JournalledWriteEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4JournalledWriteEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4JournalledWriteEndFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4JournalledWriteEndFtraceEvent::InternalSwap(Ext4JournalledWriteEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4JournalledWriteEndFtraceEvent, copied_)
      + sizeof(Ext4JournalledWriteEndFtraceEvent::copied_)
      - PROTOBUF_FIELD_OFFSET(Ext4JournalledWriteEndFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4JournalledWriteEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4JournalledWriteEndFtraceEvent";
}


// ===================================================================

class Ext4LoadInodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4LoadInodeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Ext4LoadInodeFtraceEvent::Ext4LoadInodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4LoadInodeFtraceEvent)
}
Ext4LoadInodeFtraceEvent::Ext4LoadInodeFtraceEvent(const Ext4LoadInodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ino_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ino_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4LoadInodeFtraceEvent)
}

inline void Ext4LoadInodeFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ino_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ino_));
}

Ext4LoadInodeFtraceEvent::~Ext4LoadInodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4LoadInodeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4LoadInodeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4LoadInodeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4LoadInodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4LoadInodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ino_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ino_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4LoadInodeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4LoadInodeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4LoadInodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4LoadInodeFtraceEvent)
  return target;
}

size_t Ext4LoadInodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4LoadInodeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4LoadInodeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4LoadInodeFtraceEvent*>(
      &from));
}

void Ext4LoadInodeFtraceEvent::MergeFrom(const Ext4LoadInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4LoadInodeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4LoadInodeFtraceEvent::CopyFrom(const Ext4LoadInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4LoadInodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4LoadInodeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4LoadInodeFtraceEvent::InternalSwap(Ext4LoadInodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4LoadInodeFtraceEvent, ino_)
      + sizeof(Ext4LoadInodeFtraceEvent::ino_)
      - PROTOBUF_FIELD_OFFSET(Ext4LoadInodeFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4LoadInodeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4LoadInodeFtraceEvent";
}


// ===================================================================

class Ext4LoadInodeBitmapFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4LoadInodeBitmapFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Ext4LoadInodeBitmapFtraceEvent::Ext4LoadInodeBitmapFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
}
Ext4LoadInodeBitmapFtraceEvent::Ext4LoadInodeBitmapFtraceEvent(const Ext4LoadInodeBitmapFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&group_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(group_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
}

inline void Ext4LoadInodeBitmapFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&group_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(group_));
}

Ext4LoadInodeBitmapFtraceEvent::~Ext4LoadInodeBitmapFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4LoadInodeBitmapFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4LoadInodeBitmapFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4LoadInodeBitmapFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&group_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(group_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4LoadInodeBitmapFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 group = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_group(&has_bits);
          group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4LoadInodeBitmapFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint32 group = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_group(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
  return target;
}

size_t Ext4LoadInodeBitmapFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint32 group = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4LoadInodeBitmapFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4LoadInodeBitmapFtraceEvent*>(
      &from));
}

void Ext4LoadInodeBitmapFtraceEvent::MergeFrom(const Ext4LoadInodeBitmapFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      group_ = from.group_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4LoadInodeBitmapFtraceEvent::CopyFrom(const Ext4LoadInodeBitmapFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4LoadInodeBitmapFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4LoadInodeBitmapFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4LoadInodeBitmapFtraceEvent::InternalSwap(Ext4LoadInodeBitmapFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4LoadInodeBitmapFtraceEvent, group_)
      + sizeof(Ext4LoadInodeBitmapFtraceEvent::group_)
      - PROTOBUF_FIELD_OFFSET(Ext4LoadInodeBitmapFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4LoadInodeBitmapFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4LoadInodeBitmapFtraceEvent";
}


// ===================================================================

class Ext4MarkInodeDirtyFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MarkInodeDirtyFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4MarkInodeDirtyFtraceEvent::Ext4MarkInodeDirtyFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
}
Ext4MarkInodeDirtyFtraceEvent::Ext4MarkInodeDirtyFtraceEvent(const Ext4MarkInodeDirtyFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ip_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ip_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
}

inline void Ext4MarkInodeDirtyFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ip_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ip_));
}

Ext4MarkInodeDirtyFtraceEvent::~Ext4MarkInodeDirtyFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MarkInodeDirtyFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MarkInodeDirtyFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4MarkInodeDirtyFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ip_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ip_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4MarkInodeDirtyFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ip = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ip(&has_bits);
          ip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4MarkInodeDirtyFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 ip = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_ip(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
  return target;
}

size_t Ext4MarkInodeDirtyFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 ip = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ip());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MarkInodeDirtyFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4MarkInodeDirtyFtraceEvent*>(
      &from));
}

void Ext4MarkInodeDirtyFtraceEvent::MergeFrom(const Ext4MarkInodeDirtyFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      ip_ = from.ip_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4MarkInodeDirtyFtraceEvent::CopyFrom(const Ext4MarkInodeDirtyFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MarkInodeDirtyFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MarkInodeDirtyFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MarkInodeDirtyFtraceEvent::InternalSwap(Ext4MarkInodeDirtyFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MarkInodeDirtyFtraceEvent, ip_)
      + sizeof(Ext4MarkInodeDirtyFtraceEvent::ip_)
      - PROTOBUF_FIELD_OFFSET(Ext4MarkInodeDirtyFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4MarkInodeDirtyFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MarkInodeDirtyFtraceEvent";
}


// ===================================================================

class Ext4MbBitmapLoadFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MbBitmapLoadFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Ext4MbBitmapLoadFtraceEvent::Ext4MbBitmapLoadFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
}
Ext4MbBitmapLoadFtraceEvent::Ext4MbBitmapLoadFtraceEvent(const Ext4MbBitmapLoadFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&group_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(group_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
}

inline void Ext4MbBitmapLoadFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&group_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(group_));
}

Ext4MbBitmapLoadFtraceEvent::~Ext4MbBitmapLoadFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MbBitmapLoadFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MbBitmapLoadFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4MbBitmapLoadFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&group_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(group_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4MbBitmapLoadFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 group = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_group(&has_bits);
          group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4MbBitmapLoadFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint32 group = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_group(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
  return target;
}

size_t Ext4MbBitmapLoadFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint32 group = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MbBitmapLoadFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4MbBitmapLoadFtraceEvent*>(
      &from));
}

void Ext4MbBitmapLoadFtraceEvent::MergeFrom(const Ext4MbBitmapLoadFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      group_ = from.group_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4MbBitmapLoadFtraceEvent::CopyFrom(const Ext4MbBitmapLoadFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MbBitmapLoadFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MbBitmapLoadFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MbBitmapLoadFtraceEvent::InternalSwap(Ext4MbBitmapLoadFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MbBitmapLoadFtraceEvent, group_)
      + sizeof(Ext4MbBitmapLoadFtraceEvent::group_)
      - PROTOBUF_FIELD_OFFSET(Ext4MbBitmapLoadFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4MbBitmapLoadFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MbBitmapLoadFtraceEvent";
}


// ===================================================================

class Ext4MbBuddyBitmapLoadFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MbBuddyBitmapLoadFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Ext4MbBuddyBitmapLoadFtraceEvent::Ext4MbBuddyBitmapLoadFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
}
Ext4MbBuddyBitmapLoadFtraceEvent::Ext4MbBuddyBitmapLoadFtraceEvent(const Ext4MbBuddyBitmapLoadFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&group_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(group_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
}

inline void Ext4MbBuddyBitmapLoadFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&group_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(group_));
}

Ext4MbBuddyBitmapLoadFtraceEvent::~Ext4MbBuddyBitmapLoadFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MbBuddyBitmapLoadFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MbBuddyBitmapLoadFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4MbBuddyBitmapLoadFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&group_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(group_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4MbBuddyBitmapLoadFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 group = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_group(&has_bits);
          group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4MbBuddyBitmapLoadFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint32 group = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_group(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
  return target;
}

size_t Ext4MbBuddyBitmapLoadFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint32 group = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MbBuddyBitmapLoadFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4MbBuddyBitmapLoadFtraceEvent*>(
      &from));
}

void Ext4MbBuddyBitmapLoadFtraceEvent::MergeFrom(const Ext4MbBuddyBitmapLoadFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      group_ = from.group_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4MbBuddyBitmapLoadFtraceEvent::CopyFrom(const Ext4MbBuddyBitmapLoadFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MbBuddyBitmapLoadFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MbBuddyBitmapLoadFtraceEvent::InternalSwap(Ext4MbBuddyBitmapLoadFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MbBuddyBitmapLoadFtraceEvent, group_)
      + sizeof(Ext4MbBuddyBitmapLoadFtraceEvent::group_)
      - PROTOBUF_FIELD_OFFSET(Ext4MbBuddyBitmapLoadFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4MbBuddyBitmapLoadFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MbBuddyBitmapLoadFtraceEvent";
}


// ===================================================================

class Ext4MbDiscardPreallocationsFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MbDiscardPreallocationsFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_needed(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Ext4MbDiscardPreallocationsFtraceEvent::Ext4MbDiscardPreallocationsFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
}
Ext4MbDiscardPreallocationsFtraceEvent::Ext4MbDiscardPreallocationsFtraceEvent(const Ext4MbDiscardPreallocationsFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&needed_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(needed_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
}

inline void Ext4MbDiscardPreallocationsFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&needed_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(needed_));
}

Ext4MbDiscardPreallocationsFtraceEvent::~Ext4MbDiscardPreallocationsFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MbDiscardPreallocationsFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MbDiscardPreallocationsFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4MbDiscardPreallocationsFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&needed_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(needed_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4MbDiscardPreallocationsFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 needed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_needed(&has_bits);
          needed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4MbDiscardPreallocationsFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional int32 needed = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_needed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
  return target;
}

size_t Ext4MbDiscardPreallocationsFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional int32 needed = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_needed());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MbDiscardPreallocationsFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4MbDiscardPreallocationsFtraceEvent*>(
      &from));
}

void Ext4MbDiscardPreallocationsFtraceEvent::MergeFrom(const Ext4MbDiscardPreallocationsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      needed_ = from.needed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4MbDiscardPreallocationsFtraceEvent::CopyFrom(const Ext4MbDiscardPreallocationsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MbDiscardPreallocationsFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MbDiscardPreallocationsFtraceEvent::InternalSwap(Ext4MbDiscardPreallocationsFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MbDiscardPreallocationsFtraceEvent, needed_)
      + sizeof(Ext4MbDiscardPreallocationsFtraceEvent::needed_)
      - PROTOBUF_FIELD_OFFSET(Ext4MbDiscardPreallocationsFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4MbDiscardPreallocationsFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MbDiscardPreallocationsFtraceEvent";
}


// ===================================================================

class Ext4MbNewGroupPaFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MbNewGroupPaFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pa_pstart(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pa_lstart(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pa_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4MbNewGroupPaFtraceEvent::Ext4MbNewGroupPaFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
}
Ext4MbNewGroupPaFtraceEvent::Ext4MbNewGroupPaFtraceEvent(const Ext4MbNewGroupPaFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&pa_len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(pa_len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
}

inline void Ext4MbNewGroupPaFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&pa_len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(pa_len_));
}

Ext4MbNewGroupPaFtraceEvent::~Ext4MbNewGroupPaFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MbNewGroupPaFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MbNewGroupPaFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4MbNewGroupPaFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pa_len_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(pa_len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4MbNewGroupPaFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pa_pstart = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pa_pstart(&has_bits);
          pa_pstart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pa_lstart = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_pa_lstart(&has_bits);
          pa_lstart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pa_len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_pa_len(&has_bits);
          pa_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4MbNewGroupPaFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 pa_pstart = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_pa_pstart(), target);
  }

  // optional uint64 pa_lstart = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_pa_lstart(), target);
  }

  // optional uint32 pa_len = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_pa_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
  return target;
}

size_t Ext4MbNewGroupPaFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 pa_pstart = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pa_pstart());
    }

    // optional uint64 pa_lstart = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pa_lstart());
    }

    // optional uint32 pa_len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pa_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MbNewGroupPaFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4MbNewGroupPaFtraceEvent*>(
      &from));
}

void Ext4MbNewGroupPaFtraceEvent::MergeFrom(const Ext4MbNewGroupPaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pa_pstart_ = from.pa_pstart_;
    }
    if (cached_has_bits & 0x00000008u) {
      pa_lstart_ = from.pa_lstart_;
    }
    if (cached_has_bits & 0x00000010u) {
      pa_len_ = from.pa_len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4MbNewGroupPaFtraceEvent::CopyFrom(const Ext4MbNewGroupPaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MbNewGroupPaFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MbNewGroupPaFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MbNewGroupPaFtraceEvent::InternalSwap(Ext4MbNewGroupPaFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MbNewGroupPaFtraceEvent, pa_len_)
      + sizeof(Ext4MbNewGroupPaFtraceEvent::pa_len_)
      - PROTOBUF_FIELD_OFFSET(Ext4MbNewGroupPaFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4MbNewGroupPaFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MbNewGroupPaFtraceEvent";
}


// ===================================================================

class Ext4MbNewInodePaFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MbNewInodePaFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pa_pstart(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pa_lstart(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pa_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4MbNewInodePaFtraceEvent::Ext4MbNewInodePaFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
}
Ext4MbNewInodePaFtraceEvent::Ext4MbNewInodePaFtraceEvent(const Ext4MbNewInodePaFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&pa_len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(pa_len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
}

inline void Ext4MbNewInodePaFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&pa_len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(pa_len_));
}

Ext4MbNewInodePaFtraceEvent::~Ext4MbNewInodePaFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MbNewInodePaFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MbNewInodePaFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4MbNewInodePaFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pa_len_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(pa_len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4MbNewInodePaFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pa_pstart = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pa_pstart(&has_bits);
          pa_pstart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pa_lstart = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_pa_lstart(&has_bits);
          pa_lstart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pa_len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_pa_len(&has_bits);
          pa_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4MbNewInodePaFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 pa_pstart = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_pa_pstart(), target);
  }

  // optional uint64 pa_lstart = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_pa_lstart(), target);
  }

  // optional uint32 pa_len = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_pa_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
  return target;
}

size_t Ext4MbNewInodePaFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 pa_pstart = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pa_pstart());
    }

    // optional uint64 pa_lstart = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pa_lstart());
    }

    // optional uint32 pa_len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pa_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MbNewInodePaFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4MbNewInodePaFtraceEvent*>(
      &from));
}

void Ext4MbNewInodePaFtraceEvent::MergeFrom(const Ext4MbNewInodePaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pa_pstart_ = from.pa_pstart_;
    }
    if (cached_has_bits & 0x00000008u) {
      pa_lstart_ = from.pa_lstart_;
    }
    if (cached_has_bits & 0x00000010u) {
      pa_len_ = from.pa_len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4MbNewInodePaFtraceEvent::CopyFrom(const Ext4MbNewInodePaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MbNewInodePaFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MbNewInodePaFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MbNewInodePaFtraceEvent::InternalSwap(Ext4MbNewInodePaFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MbNewInodePaFtraceEvent, pa_len_)
      + sizeof(Ext4MbNewInodePaFtraceEvent::pa_len_)
      - PROTOBUF_FIELD_OFFSET(Ext4MbNewInodePaFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4MbNewInodePaFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MbNewInodePaFtraceEvent";
}


// ===================================================================

class Ext4MbReleaseGroupPaFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MbReleaseGroupPaFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pa_pstart(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pa_len(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4MbReleaseGroupPaFtraceEvent::Ext4MbReleaseGroupPaFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
}
Ext4MbReleaseGroupPaFtraceEvent::Ext4MbReleaseGroupPaFtraceEvent(const Ext4MbReleaseGroupPaFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&pa_len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(pa_len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
}

inline void Ext4MbReleaseGroupPaFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&pa_len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(pa_len_));
}

Ext4MbReleaseGroupPaFtraceEvent::~Ext4MbReleaseGroupPaFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MbReleaseGroupPaFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MbReleaseGroupPaFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4MbReleaseGroupPaFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pa_len_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(pa_len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4MbReleaseGroupPaFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pa_pstart = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pa_pstart(&has_bits);
          pa_pstart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pa_len = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pa_len(&has_bits);
          pa_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4MbReleaseGroupPaFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 pa_pstart = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_pa_pstart(), target);
  }

  // optional uint32 pa_len = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_pa_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
  return target;
}

size_t Ext4MbReleaseGroupPaFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 pa_pstart = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pa_pstart());
    }

    // optional uint32 pa_len = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pa_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MbReleaseGroupPaFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4MbReleaseGroupPaFtraceEvent*>(
      &from));
}

void Ext4MbReleaseGroupPaFtraceEvent::MergeFrom(const Ext4MbReleaseGroupPaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      pa_pstart_ = from.pa_pstart_;
    }
    if (cached_has_bits & 0x00000004u) {
      pa_len_ = from.pa_len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4MbReleaseGroupPaFtraceEvent::CopyFrom(const Ext4MbReleaseGroupPaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MbReleaseGroupPaFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MbReleaseGroupPaFtraceEvent::InternalSwap(Ext4MbReleaseGroupPaFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MbReleaseGroupPaFtraceEvent, pa_len_)
      + sizeof(Ext4MbReleaseGroupPaFtraceEvent::pa_len_)
      - PROTOBUF_FIELD_OFFSET(Ext4MbReleaseGroupPaFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4MbReleaseGroupPaFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MbReleaseGroupPaFtraceEvent";
}


// ===================================================================

class Ext4MbReleaseInodePaFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MbReleaseInodePaFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_block(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4MbReleaseInodePaFtraceEvent::Ext4MbReleaseInodePaFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
}
Ext4MbReleaseInodePaFtraceEvent::Ext4MbReleaseInodePaFtraceEvent(const Ext4MbReleaseInodePaFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(count_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
}

inline void Ext4MbReleaseInodePaFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(count_));
}

Ext4MbReleaseInodePaFtraceEvent::~Ext4MbReleaseInodePaFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MbReleaseInodePaFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MbReleaseInodePaFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4MbReleaseInodePaFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&count_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4MbReleaseInodePaFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 block = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_block(&has_bits);
          block_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4MbReleaseInodePaFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 block = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_block(), target);
  }

  // optional uint32 count = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
  return target;
}

size_t Ext4MbReleaseInodePaFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 block = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_block());
    }

    // optional uint32 count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MbReleaseInodePaFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4MbReleaseInodePaFtraceEvent*>(
      &from));
}

void Ext4MbReleaseInodePaFtraceEvent::MergeFrom(const Ext4MbReleaseInodePaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      block_ = from.block_;
    }
    if (cached_has_bits & 0x00000008u) {
      count_ = from.count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4MbReleaseInodePaFtraceEvent::CopyFrom(const Ext4MbReleaseInodePaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MbReleaseInodePaFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MbReleaseInodePaFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MbReleaseInodePaFtraceEvent::InternalSwap(Ext4MbReleaseInodePaFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MbReleaseInodePaFtraceEvent, count_)
      + sizeof(Ext4MbReleaseInodePaFtraceEvent::count_)
      - PROTOBUF_FIELD_OFFSET(Ext4MbReleaseInodePaFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4MbReleaseInodePaFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MbReleaseInodePaFtraceEvent";
}


// ===================================================================

class Ext4MballocAllocFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MballocAllocFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_orig_logical(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_orig_start(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_orig_group(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_orig_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_goal_logical(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_goal_start(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_goal_group(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_goal_len(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_result_logical(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_result_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_result_group(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_result_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_found(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_groups(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_buddy(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_tail(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_cr(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
};

Ext4MballocAllocFtraceEvent::Ext4MballocAllocFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MballocAllocFtraceEvent)
}
Ext4MballocAllocFtraceEvent::Ext4MballocAllocFtraceEvent(const Ext4MballocAllocFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&cr_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(cr_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MballocAllocFtraceEvent)
}

inline void Ext4MballocAllocFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&cr_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(cr_));
}

Ext4MballocAllocFtraceEvent::~Ext4MballocAllocFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MballocAllocFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MballocAllocFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MballocAllocFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4MballocAllocFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MballocAllocFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&goal_start_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(goal_start_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&goal_group_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&groups_) -
        reinterpret_cast<char*>(&goal_group_)) + sizeof(groups_));
  }
  if (cached_has_bits & 0x000f0000u) {
    ::memset(&buddy_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cr_) -
        reinterpret_cast<char*>(&buddy_)) + sizeof(cr_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4MballocAllocFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 orig_logical = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_orig_logical(&has_bits);
          orig_logical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 orig_start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_orig_start(&has_bits);
          orig_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 orig_group = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_orig_group(&has_bits);
          orig_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 orig_len = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_orig_len(&has_bits);
          orig_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 goal_logical = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_goal_logical(&has_bits);
          goal_logical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 goal_start = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_goal_start(&has_bits);
          goal_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 goal_group = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_goal_group(&has_bits);
          goal_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 goal_len = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_goal_len(&has_bits);
          goal_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 result_logical = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_result_logical(&has_bits);
          result_logical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 result_start = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_result_start(&has_bits);
          result_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 result_group = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_result_group(&has_bits);
          result_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 result_len = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_result_len(&has_bits);
          result_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 found = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_found(&has_bits);
          found_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 groups = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_groups(&has_bits);
          groups_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 buddy = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_buddy(&has_bits);
          buddy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tail = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_tail(&has_bits);
          tail_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cr = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_cr(&has_bits);
          cr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4MballocAllocFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MballocAllocFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 orig_logical = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_orig_logical(), target);
  }

  // optional int32 orig_start = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_orig_start(), target);
  }

  // optional uint32 orig_group = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_orig_group(), target);
  }

  // optional int32 orig_len = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_orig_len(), target);
  }

  // optional uint32 goal_logical = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_goal_logical(), target);
  }

  // optional int32 goal_start = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_goal_start(), target);
  }

  // optional uint32 goal_group = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_goal_group(), target);
  }

  // optional int32 goal_len = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_goal_len(), target);
  }

  // optional uint32 result_logical = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_result_logical(), target);
  }

  // optional int32 result_start = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_result_start(), target);
  }

  // optional uint32 result_group = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_result_group(), target);
  }

  // optional int32 result_len = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(14, this->_internal_result_len(), target);
  }

  // optional uint32 found = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_found(), target);
  }

  // optional uint32 groups = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_groups(), target);
  }

  // optional uint32 buddy = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_buddy(), target);
  }

  // optional uint32 flags = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_flags(), target);
  }

  // optional uint32 tail = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_tail(), target);
  }

  // optional uint32 cr = 20;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_cr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MballocAllocFtraceEvent)
  return target;
}

size_t Ext4MballocAllocFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MballocAllocFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 orig_logical = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_orig_logical());
    }

    // optional int32 orig_start = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_orig_start());
    }

    // optional uint32 orig_group = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_orig_group());
    }

    // optional int32 orig_len = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_orig_len());
    }

    // optional uint32 goal_logical = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_goal_logical());
    }

    // optional int32 goal_start = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_goal_start());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 goal_group = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_goal_group());
    }

    // optional int32 goal_len = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_goal_len());
    }

    // optional uint32 result_logical = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_result_logical());
    }

    // optional int32 result_start = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result_start());
    }

    // optional uint32 result_group = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_result_group());
    }

    // optional int32 result_len = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result_len());
    }

    // optional uint32 found = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_found());
    }

    // optional uint32 groups = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_groups());
    }

  }
  if (cached_has_bits & 0x000f0000u) {
    // optional uint32 buddy = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_buddy());
    }

    // optional uint32 flags = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_flags());
    }

    // optional uint32 tail = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_tail());
    }

    // optional uint32 cr = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_cr());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MballocAllocFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4MballocAllocFtraceEvent*>(
      &from));
}

void Ext4MballocAllocFtraceEvent::MergeFrom(const Ext4MballocAllocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MballocAllocFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      orig_logical_ = from.orig_logical_;
    }
    if (cached_has_bits & 0x00000008u) {
      orig_start_ = from.orig_start_;
    }
    if (cached_has_bits & 0x00000010u) {
      orig_group_ = from.orig_group_;
    }
    if (cached_has_bits & 0x00000020u) {
      orig_len_ = from.orig_len_;
    }
    if (cached_has_bits & 0x00000040u) {
      goal_logical_ = from.goal_logical_;
    }
    if (cached_has_bits & 0x00000080u) {
      goal_start_ = from.goal_start_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      goal_group_ = from.goal_group_;
    }
    if (cached_has_bits & 0x00000200u) {
      goal_len_ = from.goal_len_;
    }
    if (cached_has_bits & 0x00000400u) {
      result_logical_ = from.result_logical_;
    }
    if (cached_has_bits & 0x00000800u) {
      result_start_ = from.result_start_;
    }
    if (cached_has_bits & 0x00001000u) {
      result_group_ = from.result_group_;
    }
    if (cached_has_bits & 0x00002000u) {
      result_len_ = from.result_len_;
    }
    if (cached_has_bits & 0x00004000u) {
      found_ = from.found_;
    }
    if (cached_has_bits & 0x00008000u) {
      groups_ = from.groups_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x000f0000u) {
    if (cached_has_bits & 0x00010000u) {
      buddy_ = from.buddy_;
    }
    if (cached_has_bits & 0x00020000u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00040000u) {
      tail_ = from.tail_;
    }
    if (cached_has_bits & 0x00080000u) {
      cr_ = from.cr_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4MballocAllocFtraceEvent::CopyFrom(const Ext4MballocAllocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MballocAllocFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MballocAllocFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MballocAllocFtraceEvent::InternalSwap(Ext4MballocAllocFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MballocAllocFtraceEvent, cr_)
      + sizeof(Ext4MballocAllocFtraceEvent::cr_)
      - PROTOBUF_FIELD_OFFSET(Ext4MballocAllocFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4MballocAllocFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MballocAllocFtraceEvent";
}


// ===================================================================

class Ext4MballocDiscardFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MballocDiscardFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_result_start(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_result_group(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_result_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4MballocDiscardFtraceEvent::Ext4MballocDiscardFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MballocDiscardFtraceEvent)
}
Ext4MballocDiscardFtraceEvent::Ext4MballocDiscardFtraceEvent(const Ext4MballocDiscardFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&result_len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(result_len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MballocDiscardFtraceEvent)
}

inline void Ext4MballocDiscardFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&result_len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(result_len_));
}

Ext4MballocDiscardFtraceEvent::~Ext4MballocDiscardFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MballocDiscardFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MballocDiscardFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MballocDiscardFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4MballocDiscardFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MballocDiscardFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&result_len_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(result_len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4MballocDiscardFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 result_start = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_result_start(&has_bits);
          result_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 result_group = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_result_group(&has_bits);
          result_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 result_len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_result_len(&has_bits);
          result_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4MballocDiscardFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MballocDiscardFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 result_start = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_result_start(), target);
  }

  // optional uint32 result_group = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_result_group(), target);
  }

  // optional int32 result_len = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_result_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MballocDiscardFtraceEvent)
  return target;
}

size_t Ext4MballocDiscardFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MballocDiscardFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 result_start = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result_start());
    }

    // optional uint32 result_group = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_result_group());
    }

    // optional int32 result_len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MballocDiscardFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4MballocDiscardFtraceEvent*>(
      &from));
}

void Ext4MballocDiscardFtraceEvent::MergeFrom(const Ext4MballocDiscardFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MballocDiscardFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      result_start_ = from.result_start_;
    }
    if (cached_has_bits & 0x00000008u) {
      result_group_ = from.result_group_;
    }
    if (cached_has_bits & 0x00000010u) {
      result_len_ = from.result_len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4MballocDiscardFtraceEvent::CopyFrom(const Ext4MballocDiscardFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MballocDiscardFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MballocDiscardFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MballocDiscardFtraceEvent::InternalSwap(Ext4MballocDiscardFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MballocDiscardFtraceEvent, result_len_)
      + sizeof(Ext4MballocDiscardFtraceEvent::result_len_)
      - PROTOBUF_FIELD_OFFSET(Ext4MballocDiscardFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4MballocDiscardFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MballocDiscardFtraceEvent";
}


// ===================================================================

class Ext4MballocFreeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MballocFreeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_result_start(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_result_group(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_result_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4MballocFreeFtraceEvent::Ext4MballocFreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MballocFreeFtraceEvent)
}
Ext4MballocFreeFtraceEvent::Ext4MballocFreeFtraceEvent(const Ext4MballocFreeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&result_len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(result_len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MballocFreeFtraceEvent)
}

inline void Ext4MballocFreeFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&result_len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(result_len_));
}

Ext4MballocFreeFtraceEvent::~Ext4MballocFreeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MballocFreeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MballocFreeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MballocFreeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4MballocFreeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MballocFreeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&result_len_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(result_len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4MballocFreeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 result_start = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_result_start(&has_bits);
          result_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 result_group = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_result_group(&has_bits);
          result_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 result_len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_result_len(&has_bits);
          result_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4MballocFreeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MballocFreeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 result_start = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_result_start(), target);
  }

  // optional uint32 result_group = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_result_group(), target);
  }

  // optional int32 result_len = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_result_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MballocFreeFtraceEvent)
  return target;
}

size_t Ext4MballocFreeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MballocFreeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 result_start = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result_start());
    }

    // optional uint32 result_group = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_result_group());
    }

    // optional int32 result_len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MballocFreeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4MballocFreeFtraceEvent*>(
      &from));
}

void Ext4MballocFreeFtraceEvent::MergeFrom(const Ext4MballocFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MballocFreeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      result_start_ = from.result_start_;
    }
    if (cached_has_bits & 0x00000008u) {
      result_group_ = from.result_group_;
    }
    if (cached_has_bits & 0x00000010u) {
      result_len_ = from.result_len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4MballocFreeFtraceEvent::CopyFrom(const Ext4MballocFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MballocFreeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MballocFreeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MballocFreeFtraceEvent::InternalSwap(Ext4MballocFreeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MballocFreeFtraceEvent, result_len_)
      + sizeof(Ext4MballocFreeFtraceEvent::result_len_)
      - PROTOBUF_FIELD_OFFSET(Ext4MballocFreeFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4MballocFreeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MballocFreeFtraceEvent";
}


// ===================================================================

class Ext4MballocPreallocFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4MballocPreallocFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_orig_logical(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_orig_start(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_orig_group(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_orig_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_result_logical(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_result_start(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_result_group(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_result_len(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

Ext4MballocPreallocFtraceEvent::Ext4MballocPreallocFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4MballocPreallocFtraceEvent)
}
Ext4MballocPreallocFtraceEvent::Ext4MballocPreallocFtraceEvent(const Ext4MballocPreallocFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&result_len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(result_len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4MballocPreallocFtraceEvent)
}

inline void Ext4MballocPreallocFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&result_len_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(result_len_));
}

Ext4MballocPreallocFtraceEvent::~Ext4MballocPreallocFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4MballocPreallocFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4MballocPreallocFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4MballocPreallocFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4MballocPreallocFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4MballocPreallocFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&result_start_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(result_start_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&result_group_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&result_len_) -
        reinterpret_cast<char*>(&result_group_)) + sizeof(result_len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4MballocPreallocFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 orig_logical = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_orig_logical(&has_bits);
          orig_logical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 orig_start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_orig_start(&has_bits);
          orig_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 orig_group = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_orig_group(&has_bits);
          orig_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 orig_len = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_orig_len(&has_bits);
          orig_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 result_logical = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_result_logical(&has_bits);
          result_logical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 result_start = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_result_start(&has_bits);
          result_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 result_group = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_result_group(&has_bits);
          result_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 result_len = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_result_len(&has_bits);
          result_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4MballocPreallocFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4MballocPreallocFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 orig_logical = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_orig_logical(), target);
  }

  // optional int32 orig_start = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_orig_start(), target);
  }

  // optional uint32 orig_group = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_orig_group(), target);
  }

  // optional int32 orig_len = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_orig_len(), target);
  }

  // optional uint32 result_logical = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_result_logical(), target);
  }

  // optional int32 result_start = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_result_start(), target);
  }

  // optional uint32 result_group = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_result_group(), target);
  }

  // optional int32 result_len = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_result_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4MballocPreallocFtraceEvent)
  return target;
}

size_t Ext4MballocPreallocFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4MballocPreallocFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 orig_logical = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_orig_logical());
    }

    // optional int32 orig_start = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_orig_start());
    }

    // optional uint32 orig_group = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_orig_group());
    }

    // optional int32 orig_len = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_orig_len());
    }

    // optional uint32 result_logical = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_result_logical());
    }

    // optional int32 result_start = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result_start());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 result_group = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_result_group());
    }

    // optional int32 result_len = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4MballocPreallocFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4MballocPreallocFtraceEvent*>(
      &from));
}

void Ext4MballocPreallocFtraceEvent::MergeFrom(const Ext4MballocPreallocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4MballocPreallocFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      orig_logical_ = from.orig_logical_;
    }
    if (cached_has_bits & 0x00000008u) {
      orig_start_ = from.orig_start_;
    }
    if (cached_has_bits & 0x00000010u) {
      orig_group_ = from.orig_group_;
    }
    if (cached_has_bits & 0x00000020u) {
      orig_len_ = from.orig_len_;
    }
    if (cached_has_bits & 0x00000040u) {
      result_logical_ = from.result_logical_;
    }
    if (cached_has_bits & 0x00000080u) {
      result_start_ = from.result_start_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      result_group_ = from.result_group_;
    }
    if (cached_has_bits & 0x00000200u) {
      result_len_ = from.result_len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4MballocPreallocFtraceEvent::CopyFrom(const Ext4MballocPreallocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4MballocPreallocFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4MballocPreallocFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4MballocPreallocFtraceEvent::InternalSwap(Ext4MballocPreallocFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4MballocPreallocFtraceEvent, result_len_)
      + sizeof(Ext4MballocPreallocFtraceEvent::result_len_)
      - PROTOBUF_FIELD_OFFSET(Ext4MballocPreallocFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4MballocPreallocFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4MballocPreallocFtraceEvent";
}


// ===================================================================

class Ext4OtherInodeUpdateTimeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4OtherInodeUpdateTimeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_orig_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Ext4OtherInodeUpdateTimeFtraceEvent::Ext4OtherInodeUpdateTimeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
}
Ext4OtherInodeUpdateTimeFtraceEvent::Ext4OtherInodeUpdateTimeFtraceEvent(const Ext4OtherInodeUpdateTimeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
}

inline void Ext4OtherInodeUpdateTimeFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
}

Ext4OtherInodeUpdateTimeFtraceEvent::~Ext4OtherInodeUpdateTimeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4OtherInodeUpdateTimeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4OtherInodeUpdateTimeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4OtherInodeUpdateTimeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4OtherInodeUpdateTimeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 orig_ino = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_orig_ino(&has_bits);
          orig_ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 uid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_uid(&has_bits);
          uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_gid(&has_bits);
          gid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mode = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4OtherInodeUpdateTimeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 orig_ino = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_orig_ino(), target);
  }

  // optional uint32 uid = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_uid(), target);
  }

  // optional uint32 gid = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_gid(), target);
  }

  // optional uint32 mode = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
  return target;
}

size_t Ext4OtherInodeUpdateTimeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 orig_ino = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_orig_ino());
    }

    // optional uint32 uid = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_uid());
    }

    // optional uint32 gid = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gid());
    }

    // optional uint32 mode = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4OtherInodeUpdateTimeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4OtherInodeUpdateTimeFtraceEvent*>(
      &from));
}

void Ext4OtherInodeUpdateTimeFtraceEvent::MergeFrom(const Ext4OtherInodeUpdateTimeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      orig_ino_ = from.orig_ino_;
    }
    if (cached_has_bits & 0x00000008u) {
      uid_ = from.uid_;
    }
    if (cached_has_bits & 0x00000010u) {
      gid_ = from.gid_;
    }
    if (cached_has_bits & 0x00000020u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4OtherInodeUpdateTimeFtraceEvent::CopyFrom(const Ext4OtherInodeUpdateTimeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4OtherInodeUpdateTimeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4OtherInodeUpdateTimeFtraceEvent::InternalSwap(Ext4OtherInodeUpdateTimeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4OtherInodeUpdateTimeFtraceEvent, mode_)
      + sizeof(Ext4OtherInodeUpdateTimeFtraceEvent::mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4OtherInodeUpdateTimeFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4OtherInodeUpdateTimeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4OtherInodeUpdateTimeFtraceEvent";
}


// ===================================================================

class Ext4PunchHoleFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4PunchHoleFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4PunchHoleFtraceEvent::Ext4PunchHoleFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4PunchHoleFtraceEvent)
}
Ext4PunchHoleFtraceEvent::Ext4PunchHoleFtraceEvent(const Ext4PunchHoleFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4PunchHoleFtraceEvent)
}

inline void Ext4PunchHoleFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
}

Ext4PunchHoleFtraceEvent::~Ext4PunchHoleFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4PunchHoleFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4PunchHoleFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4PunchHoleFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4PunchHoleFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4PunchHoleFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4PunchHoleFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4PunchHoleFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4PunchHoleFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 offset = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_offset(), target);
  }

  // optional int64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_len(), target);
  }

  // optional int32 mode = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4PunchHoleFtraceEvent)
  return target;
}

size_t Ext4PunchHoleFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4PunchHoleFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 offset = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_offset());
    }

    // optional int64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_len());
    }

    // optional int32 mode = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mode());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4PunchHoleFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4PunchHoleFtraceEvent*>(
      &from));
}

void Ext4PunchHoleFtraceEvent::MergeFrom(const Ext4PunchHoleFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4PunchHoleFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4PunchHoleFtraceEvent::CopyFrom(const Ext4PunchHoleFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4PunchHoleFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4PunchHoleFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4PunchHoleFtraceEvent::InternalSwap(Ext4PunchHoleFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4PunchHoleFtraceEvent, mode_)
      + sizeof(Ext4PunchHoleFtraceEvent::mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4PunchHoleFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4PunchHoleFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4PunchHoleFtraceEvent";
}


// ===================================================================

class Ext4ReadBlockBitmapLoadFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ReadBlockBitmapLoadFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prefetch(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4ReadBlockBitmapLoadFtraceEvent::Ext4ReadBlockBitmapLoadFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
}
Ext4ReadBlockBitmapLoadFtraceEvent::Ext4ReadBlockBitmapLoadFtraceEvent(const Ext4ReadBlockBitmapLoadFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&prefetch_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(prefetch_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
}

inline void Ext4ReadBlockBitmapLoadFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&prefetch_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(prefetch_));
}

Ext4ReadBlockBitmapLoadFtraceEvent::~Ext4ReadBlockBitmapLoadFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ReadBlockBitmapLoadFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ReadBlockBitmapLoadFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4ReadBlockBitmapLoadFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&prefetch_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(prefetch_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4ReadBlockBitmapLoadFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 group = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_group(&has_bits);
          group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 prefetch = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_prefetch(&has_bits);
          prefetch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4ReadBlockBitmapLoadFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint32 group = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_group(), target);
  }

  // optional uint32 prefetch = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_prefetch(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
  return target;
}

size_t Ext4ReadBlockBitmapLoadFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint32 group = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group());
    }

    // optional uint32 prefetch = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_prefetch());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ReadBlockBitmapLoadFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4ReadBlockBitmapLoadFtraceEvent*>(
      &from));
}

void Ext4ReadBlockBitmapLoadFtraceEvent::MergeFrom(const Ext4ReadBlockBitmapLoadFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      group_ = from.group_;
    }
    if (cached_has_bits & 0x00000004u) {
      prefetch_ = from.prefetch_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4ReadBlockBitmapLoadFtraceEvent::CopyFrom(const Ext4ReadBlockBitmapLoadFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ReadBlockBitmapLoadFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ReadBlockBitmapLoadFtraceEvent::InternalSwap(Ext4ReadBlockBitmapLoadFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ReadBlockBitmapLoadFtraceEvent, prefetch_)
      + sizeof(Ext4ReadBlockBitmapLoadFtraceEvent::prefetch_)
      - PROTOBUF_FIELD_OFFSET(Ext4ReadBlockBitmapLoadFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4ReadBlockBitmapLoadFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ReadBlockBitmapLoadFtraceEvent";
}


// ===================================================================

class Ext4ReadpageFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ReadpageFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4ReadpageFtraceEvent::Ext4ReadpageFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ReadpageFtraceEvent)
}
Ext4ReadpageFtraceEvent::Ext4ReadpageFtraceEvent(const Ext4ReadpageFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(index_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ReadpageFtraceEvent)
}

inline void Ext4ReadpageFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(index_));
}

Ext4ReadpageFtraceEvent::~Ext4ReadpageFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ReadpageFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ReadpageFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ReadpageFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4ReadpageFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ReadpageFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&index_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(index_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4ReadpageFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4ReadpageFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ReadpageFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ReadpageFtraceEvent)
  return target;
}

size_t Ext4ReadpageFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ReadpageFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_index());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ReadpageFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4ReadpageFtraceEvent*>(
      &from));
}

void Ext4ReadpageFtraceEvent::MergeFrom(const Ext4ReadpageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ReadpageFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      index_ = from.index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4ReadpageFtraceEvent::CopyFrom(const Ext4ReadpageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ReadpageFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ReadpageFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ReadpageFtraceEvent::InternalSwap(Ext4ReadpageFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ReadpageFtraceEvent, index_)
      + sizeof(Ext4ReadpageFtraceEvent::index_)
      - PROTOBUF_FIELD_OFFSET(Ext4ReadpageFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4ReadpageFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ReadpageFtraceEvent";
}


// ===================================================================

class Ext4ReleasepageFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ReleasepageFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4ReleasepageFtraceEvent::Ext4ReleasepageFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ReleasepageFtraceEvent)
}
Ext4ReleasepageFtraceEvent::Ext4ReleasepageFtraceEvent(const Ext4ReleasepageFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(index_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ReleasepageFtraceEvent)
}

inline void Ext4ReleasepageFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(index_));
}

Ext4ReleasepageFtraceEvent::~Ext4ReleasepageFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ReleasepageFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ReleasepageFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ReleasepageFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4ReleasepageFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ReleasepageFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&index_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(index_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4ReleasepageFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4ReleasepageFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ReleasepageFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ReleasepageFtraceEvent)
  return target;
}

size_t Ext4ReleasepageFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ReleasepageFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_index());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ReleasepageFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4ReleasepageFtraceEvent*>(
      &from));
}

void Ext4ReleasepageFtraceEvent::MergeFrom(const Ext4ReleasepageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ReleasepageFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      index_ = from.index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4ReleasepageFtraceEvent::CopyFrom(const Ext4ReleasepageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ReleasepageFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ReleasepageFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ReleasepageFtraceEvent::InternalSwap(Ext4ReleasepageFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ReleasepageFtraceEvent, index_)
      + sizeof(Ext4ReleasepageFtraceEvent::index_)
      - PROTOBUF_FIELD_OFFSET(Ext4ReleasepageFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4ReleasepageFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ReleasepageFtraceEvent";
}


// ===================================================================

class Ext4RemoveBlocksFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4RemoveBlocksFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_from(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_to(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_partial(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ee_pblk(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_ee_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_ee_len(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_pc_lblk(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_pc_pclu(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_pc_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

Ext4RemoveBlocksFtraceEvent::Ext4RemoveBlocksFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
}
Ext4RemoveBlocksFtraceEvent::Ext4RemoveBlocksFtraceEvent(const Ext4RemoveBlocksFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&pc_state_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(pc_state_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
}

inline void Ext4RemoveBlocksFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&pc_state_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(pc_state_));
}

Ext4RemoveBlocksFtraceEvent::~Ext4RemoveBlocksFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4RemoveBlocksFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4RemoveBlocksFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4RemoveBlocksFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ee_len_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ee_len_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&pc_pclu_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pc_state_) -
        reinterpret_cast<char*>(&pc_pclu_)) + sizeof(pc_state_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4RemoveBlocksFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 from = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_from(&has_bits);
          from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 to = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_to(&has_bits);
          to_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 partial = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_partial(&has_bits);
          partial_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ee_pblk = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_ee_pblk(&has_bits);
          ee_pblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ee_lblk = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_ee_lblk(&has_bits);
          ee_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ee_len = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_ee_len(&has_bits);
          ee_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pc_lblk = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_pc_lblk(&has_bits);
          pc_lblk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pc_pclu = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_pc_pclu(&has_bits);
          pc_pclu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pc_state = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_pc_state(&has_bits);
          pc_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4RemoveBlocksFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 from = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_from(), target);
  }

  // optional uint32 to = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_to(), target);
  }

  // optional int64 partial = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_partial(), target);
  }

  // optional uint64 ee_pblk = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_ee_pblk(), target);
  }

  // optional uint32 ee_lblk = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_ee_lblk(), target);
  }

  // optional uint32 ee_len = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_ee_len(), target);
  }

  // optional uint32 pc_lblk = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_pc_lblk(), target);
  }

  // optional uint64 pc_pclu = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(10, this->_internal_pc_pclu(), target);
  }

  // optional int32 pc_state = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_pc_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
  return target;
}

size_t Ext4RemoveBlocksFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 from = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_from());
    }

    // optional uint32 to = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_to());
    }

    // optional int64 partial = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_partial());
    }

    // optional uint64 ee_pblk = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ee_pblk());
    }

    // optional uint32 ee_lblk = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ee_lblk());
    }

    // optional uint32 ee_len = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ee_len());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional uint64 pc_pclu = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pc_pclu());
    }

    // optional uint32 pc_lblk = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pc_lblk());
    }

    // optional int32 pc_state = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pc_state());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4RemoveBlocksFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4RemoveBlocksFtraceEvent*>(
      &from));
}

void Ext4RemoveBlocksFtraceEvent::MergeFrom(const Ext4RemoveBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      from_ = from.from_;
    }
    if (cached_has_bits & 0x00000008u) {
      to_ = from.to_;
    }
    if (cached_has_bits & 0x00000010u) {
      partial_ = from.partial_;
    }
    if (cached_has_bits & 0x00000020u) {
      ee_pblk_ = from.ee_pblk_;
    }
    if (cached_has_bits & 0x00000040u) {
      ee_lblk_ = from.ee_lblk_;
    }
    if (cached_has_bits & 0x00000080u) {
      ee_len_ = from.ee_len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      pc_pclu_ = from.pc_pclu_;
    }
    if (cached_has_bits & 0x00000200u) {
      pc_lblk_ = from.pc_lblk_;
    }
    if (cached_has_bits & 0x00000400u) {
      pc_state_ = from.pc_state_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4RemoveBlocksFtraceEvent::CopyFrom(const Ext4RemoveBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4RemoveBlocksFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4RemoveBlocksFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4RemoveBlocksFtraceEvent::InternalSwap(Ext4RemoveBlocksFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4RemoveBlocksFtraceEvent, pc_state_)
      + sizeof(Ext4RemoveBlocksFtraceEvent::pc_state_)
      - PROTOBUF_FIELD_OFFSET(Ext4RemoveBlocksFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4RemoveBlocksFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4RemoveBlocksFtraceEvent";
}


// ===================================================================

class Ext4RequestBlocksFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4RequestBlocksFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_logical(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_lleft(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_lright(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_goal(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_pleft(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_pright(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

Ext4RequestBlocksFtraceEvent::Ext4RequestBlocksFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4RequestBlocksFtraceEvent)
}
Ext4RequestBlocksFtraceEvent::Ext4RequestBlocksFtraceEvent(const Ext4RequestBlocksFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4RequestBlocksFtraceEvent)
}

inline void Ext4RequestBlocksFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
}

Ext4RequestBlocksFtraceEvent::~Ext4RequestBlocksFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4RequestBlocksFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4RequestBlocksFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4RequestBlocksFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4RequestBlocksFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4RequestBlocksFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pleft_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(pleft_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&pright_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flags_) -
        reinterpret_cast<char*>(&pright_)) + sizeof(flags_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4RequestBlocksFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 logical = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_logical(&has_bits);
          logical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lleft = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_lleft(&has_bits);
          lleft_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lright = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_lright(&has_bits);
          lright_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 goal = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_goal(&has_bits);
          goal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pleft = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_pleft(&has_bits);
          pleft_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pright = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_pright(&has_bits);
          pright_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4RequestBlocksFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4RequestBlocksFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 len = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_len(), target);
  }

  // optional uint32 logical = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_logical(), target);
  }

  // optional uint32 lleft = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_lleft(), target);
  }

  // optional uint32 lright = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_lright(), target);
  }

  // optional uint64 goal = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_goal(), target);
  }

  // optional uint64 pleft = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_pleft(), target);
  }

  // optional uint64 pright = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_pright(), target);
  }

  // optional uint32 flags = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4RequestBlocksFtraceEvent)
  return target;
}

size_t Ext4RequestBlocksFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4RequestBlocksFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 len = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint32 logical = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_logical());
    }

    // optional uint32 lleft = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lleft());
    }

    // optional uint32 lright = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lright());
    }

    // optional uint64 goal = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_goal());
    }

    // optional uint64 pleft = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pleft());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint64 pright = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pright());
    }

    // optional uint32 flags = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4RequestBlocksFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4RequestBlocksFtraceEvent*>(
      &from));
}

void Ext4RequestBlocksFtraceEvent::MergeFrom(const Ext4RequestBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4RequestBlocksFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000008u) {
      logical_ = from.logical_;
    }
    if (cached_has_bits & 0x00000010u) {
      lleft_ = from.lleft_;
    }
    if (cached_has_bits & 0x00000020u) {
      lright_ = from.lright_;
    }
    if (cached_has_bits & 0x00000040u) {
      goal_ = from.goal_;
    }
    if (cached_has_bits & 0x00000080u) {
      pleft_ = from.pleft_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      pright_ = from.pright_;
    }
    if (cached_has_bits & 0x00000200u) {
      flags_ = from.flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4RequestBlocksFtraceEvent::CopyFrom(const Ext4RequestBlocksFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4RequestBlocksFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4RequestBlocksFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4RequestBlocksFtraceEvent::InternalSwap(Ext4RequestBlocksFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4RequestBlocksFtraceEvent, flags_)
      + sizeof(Ext4RequestBlocksFtraceEvent::flags_)
      - PROTOBUF_FIELD_OFFSET(Ext4RequestBlocksFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4RequestBlocksFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4RequestBlocksFtraceEvent";
}


// ===================================================================

class Ext4RequestInodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4RequestInodeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4RequestInodeFtraceEvent::Ext4RequestInodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4RequestInodeFtraceEvent)
}
Ext4RequestInodeFtraceEvent::Ext4RequestInodeFtraceEvent(const Ext4RequestInodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4RequestInodeFtraceEvent)
}

inline void Ext4RequestInodeFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
}

Ext4RequestInodeFtraceEvent::~Ext4RequestInodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4RequestInodeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4RequestInodeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4RequestInodeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4RequestInodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4RequestInodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4RequestInodeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 dir = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_dir(&has_bits);
          dir_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4RequestInodeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4RequestInodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 dir = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_dir(), target);
  }

  // optional uint32 mode = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4RequestInodeFtraceEvent)
  return target;
}

size_t Ext4RequestInodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4RequestInodeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 dir = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dir());
    }

    // optional uint32 mode = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4RequestInodeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4RequestInodeFtraceEvent*>(
      &from));
}

void Ext4RequestInodeFtraceEvent::MergeFrom(const Ext4RequestInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4RequestInodeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      dir_ = from.dir_;
    }
    if (cached_has_bits & 0x00000004u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4RequestInodeFtraceEvent::CopyFrom(const Ext4RequestInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4RequestInodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4RequestInodeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4RequestInodeFtraceEvent::InternalSwap(Ext4RequestInodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4RequestInodeFtraceEvent, mode_)
      + sizeof(Ext4RequestInodeFtraceEvent::mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4RequestInodeFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4RequestInodeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4RequestInodeFtraceEvent";
}


// ===================================================================

class Ext4SyncFsFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4SyncFsFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_wait(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Ext4SyncFsFtraceEvent::Ext4SyncFsFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4SyncFsFtraceEvent)
}
Ext4SyncFsFtraceEvent::Ext4SyncFsFtraceEvent(const Ext4SyncFsFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&wait_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(wait_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4SyncFsFtraceEvent)
}

inline void Ext4SyncFsFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&wait_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(wait_));
}

Ext4SyncFsFtraceEvent::~Ext4SyncFsFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4SyncFsFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4SyncFsFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4SyncFsFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4SyncFsFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4SyncFsFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&wait_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(wait_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4SyncFsFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 wait = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_wait(&has_bits);
          wait_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4SyncFsFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4SyncFsFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional int32 wait = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_wait(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4SyncFsFtraceEvent)
  return target;
}

size_t Ext4SyncFsFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4SyncFsFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional int32 wait = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_wait());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4SyncFsFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4SyncFsFtraceEvent*>(
      &from));
}

void Ext4SyncFsFtraceEvent::MergeFrom(const Ext4SyncFsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4SyncFsFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      wait_ = from.wait_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4SyncFsFtraceEvent::CopyFrom(const Ext4SyncFsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4SyncFsFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4SyncFsFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4SyncFsFtraceEvent::InternalSwap(Ext4SyncFsFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4SyncFsFtraceEvent, wait_)
      + sizeof(Ext4SyncFsFtraceEvent::wait_)
      - PROTOBUF_FIELD_OFFSET(Ext4SyncFsFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4SyncFsFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4SyncFsFtraceEvent";
}


// ===================================================================

class Ext4TrimAllFreeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4TrimAllFreeFtraceEvent>()._has_bits_);
  static void set_has_dev_major(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dev_minor(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4TrimAllFreeFtraceEvent::Ext4TrimAllFreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
}
Ext4TrimAllFreeFtraceEvent::Ext4TrimAllFreeFtraceEvent(const Ext4TrimAllFreeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_major_, &from.dev_major_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&dev_major_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
}

inline void Ext4TrimAllFreeFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_major_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&dev_major_)) + sizeof(len_));
}

Ext4TrimAllFreeFtraceEvent::~Ext4TrimAllFreeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4TrimAllFreeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4TrimAllFreeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4TrimAllFreeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_major_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&dev_major_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4TrimAllFreeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 dev_major = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev_major(&has_bits);
          dev_major_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dev_minor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_dev_minor(&has_bits);
          dev_minor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 group = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_group(&has_bits);
          group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_start(&has_bits);
          start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4TrimAllFreeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 dev_major = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_dev_major(), target);
  }

  // optional int32 dev_minor = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_dev_minor(), target);
  }

  // optional uint32 group = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_group(), target);
  }

  // optional int32 start = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_start(), target);
  }

  // optional int32 len = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
  return target;
}

size_t Ext4TrimAllFreeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int32 dev_major = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dev_major());
    }

    // optional int32 dev_minor = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dev_minor());
    }

    // optional uint32 group = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group());
    }

    // optional int32 start = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_start());
    }

    // optional int32 len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4TrimAllFreeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4TrimAllFreeFtraceEvent*>(
      &from));
}

void Ext4TrimAllFreeFtraceEvent::MergeFrom(const Ext4TrimAllFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_major_ = from.dev_major_;
    }
    if (cached_has_bits & 0x00000002u) {
      dev_minor_ = from.dev_minor_;
    }
    if (cached_has_bits & 0x00000004u) {
      group_ = from.group_;
    }
    if (cached_has_bits & 0x00000008u) {
      start_ = from.start_;
    }
    if (cached_has_bits & 0x00000010u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4TrimAllFreeFtraceEvent::CopyFrom(const Ext4TrimAllFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4TrimAllFreeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4TrimAllFreeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4TrimAllFreeFtraceEvent::InternalSwap(Ext4TrimAllFreeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4TrimAllFreeFtraceEvent, len_)
      + sizeof(Ext4TrimAllFreeFtraceEvent::len_)
      - PROTOBUF_FIELD_OFFSET(Ext4TrimAllFreeFtraceEvent, dev_major_)>(
          reinterpret_cast<char*>(&dev_major_),
          reinterpret_cast<char*>(&other->dev_major_));
}

std::string Ext4TrimAllFreeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4TrimAllFreeFtraceEvent";
}


// ===================================================================

class Ext4TrimExtentFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4TrimExtentFtraceEvent>()._has_bits_);
  static void set_has_dev_major(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dev_minor(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4TrimExtentFtraceEvent::Ext4TrimExtentFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4TrimExtentFtraceEvent)
}
Ext4TrimExtentFtraceEvent::Ext4TrimExtentFtraceEvent(const Ext4TrimExtentFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_major_, &from.dev_major_,
    static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&dev_major_)) + sizeof(len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4TrimExtentFtraceEvent)
}

inline void Ext4TrimExtentFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_major_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&len_) -
    reinterpret_cast<char*>(&dev_major_)) + sizeof(len_));
}

Ext4TrimExtentFtraceEvent::~Ext4TrimExtentFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4TrimExtentFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4TrimExtentFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4TrimExtentFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4TrimExtentFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4TrimExtentFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_major_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&len_) -
        reinterpret_cast<char*>(&dev_major_)) + sizeof(len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4TrimExtentFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 dev_major = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev_major(&has_bits);
          dev_major_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dev_minor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_dev_minor(&has_bits);
          dev_minor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 group = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_group(&has_bits);
          group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_start(&has_bits);
          start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4TrimExtentFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4TrimExtentFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 dev_major = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_dev_major(), target);
  }

  // optional int32 dev_minor = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_dev_minor(), target);
  }

  // optional uint32 group = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_group(), target);
  }

  // optional int32 start = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_start(), target);
  }

  // optional int32 len = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4TrimExtentFtraceEvent)
  return target;
}

size_t Ext4TrimExtentFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4TrimExtentFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int32 dev_major = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dev_major());
    }

    // optional int32 dev_minor = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dev_minor());
    }

    // optional uint32 group = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group());
    }

    // optional int32 start = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_start());
    }

    // optional int32 len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4TrimExtentFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4TrimExtentFtraceEvent*>(
      &from));
}

void Ext4TrimExtentFtraceEvent::MergeFrom(const Ext4TrimExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4TrimExtentFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_major_ = from.dev_major_;
    }
    if (cached_has_bits & 0x00000002u) {
      dev_minor_ = from.dev_minor_;
    }
    if (cached_has_bits & 0x00000004u) {
      group_ = from.group_;
    }
    if (cached_has_bits & 0x00000008u) {
      start_ = from.start_;
    }
    if (cached_has_bits & 0x00000010u) {
      len_ = from.len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4TrimExtentFtraceEvent::CopyFrom(const Ext4TrimExtentFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4TrimExtentFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4TrimExtentFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4TrimExtentFtraceEvent::InternalSwap(Ext4TrimExtentFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4TrimExtentFtraceEvent, len_)
      + sizeof(Ext4TrimExtentFtraceEvent::len_)
      - PROTOBUF_FIELD_OFFSET(Ext4TrimExtentFtraceEvent, dev_major_)>(
          reinterpret_cast<char*>(&dev_major_),
          reinterpret_cast<char*>(&other->dev_major_));
}

std::string Ext4TrimExtentFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4TrimExtentFtraceEvent";
}


// ===================================================================

class Ext4TruncateEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4TruncateEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4TruncateEnterFtraceEvent::Ext4TruncateEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4TruncateEnterFtraceEvent)
}
Ext4TruncateEnterFtraceEvent::Ext4TruncateEnterFtraceEvent(const Ext4TruncateEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&blocks_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4TruncateEnterFtraceEvent)
}

inline void Ext4TruncateEnterFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&blocks_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
}

Ext4TruncateEnterFtraceEvent::~Ext4TruncateEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4TruncateEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4TruncateEnterFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4TruncateEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4TruncateEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4TruncateEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&blocks_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4TruncateEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_blocks(&has_bits);
          blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4TruncateEnterFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4TruncateEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_blocks(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4TruncateEnterFtraceEvent)
  return target;
}

size_t Ext4TruncateEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4TruncateEnterFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_blocks());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4TruncateEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4TruncateEnterFtraceEvent*>(
      &from));
}

void Ext4TruncateEnterFtraceEvent::MergeFrom(const Ext4TruncateEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4TruncateEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      blocks_ = from.blocks_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4TruncateEnterFtraceEvent::CopyFrom(const Ext4TruncateEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4TruncateEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4TruncateEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4TruncateEnterFtraceEvent::InternalSwap(Ext4TruncateEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4TruncateEnterFtraceEvent, blocks_)
      + sizeof(Ext4TruncateEnterFtraceEvent::blocks_)
      - PROTOBUF_FIELD_OFFSET(Ext4TruncateEnterFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4TruncateEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4TruncateEnterFtraceEvent";
}


// ===================================================================

class Ext4TruncateExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4TruncateExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4TruncateExitFtraceEvent::Ext4TruncateExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4TruncateExitFtraceEvent)
}
Ext4TruncateExitFtraceEvent::Ext4TruncateExitFtraceEvent(const Ext4TruncateExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&blocks_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4TruncateExitFtraceEvent)
}

inline void Ext4TruncateExitFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&blocks_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
}

Ext4TruncateExitFtraceEvent::~Ext4TruncateExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4TruncateExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4TruncateExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4TruncateExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4TruncateExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4TruncateExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&blocks_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4TruncateExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blocks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_blocks(&has_bits);
          blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4TruncateExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4TruncateExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 blocks = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_blocks(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4TruncateExitFtraceEvent)
  return target;
}

size_t Ext4TruncateExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4TruncateExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 blocks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_blocks());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4TruncateExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4TruncateExitFtraceEvent*>(
      &from));
}

void Ext4TruncateExitFtraceEvent::MergeFrom(const Ext4TruncateExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4TruncateExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      blocks_ = from.blocks_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4TruncateExitFtraceEvent::CopyFrom(const Ext4TruncateExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4TruncateExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4TruncateExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4TruncateExitFtraceEvent::InternalSwap(Ext4TruncateExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4TruncateExitFtraceEvent, blocks_)
      + sizeof(Ext4TruncateExitFtraceEvent::blocks_)
      - PROTOBUF_FIELD_OFFSET(Ext4TruncateExitFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4TruncateExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4TruncateExitFtraceEvent";
}


// ===================================================================

class Ext4UnlinkEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4UnlinkEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Ext4UnlinkEnterFtraceEvent::Ext4UnlinkEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
}
Ext4UnlinkEnterFtraceEvent::Ext4UnlinkEnterFtraceEvent(const Ext4UnlinkEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&size_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(size_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
}

inline void Ext4UnlinkEnterFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&size_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(size_));
}

Ext4UnlinkEnterFtraceEvent::~Ext4UnlinkEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4UnlinkEnterFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4UnlinkEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4UnlinkEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&size_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(size_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4UnlinkEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 parent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_parent(&has_bits);
          parent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4UnlinkEnterFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 parent = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_parent(), target);
  }

  // optional int64 size = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
  return target;
}

size_t Ext4UnlinkEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 parent = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_parent());
    }

    // optional int64 size = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_size());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4UnlinkEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4UnlinkEnterFtraceEvent*>(
      &from));
}

void Ext4UnlinkEnterFtraceEvent::MergeFrom(const Ext4UnlinkEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      parent_ = from.parent_;
    }
    if (cached_has_bits & 0x00000008u) {
      size_ = from.size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4UnlinkEnterFtraceEvent::CopyFrom(const Ext4UnlinkEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4UnlinkEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4UnlinkEnterFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4UnlinkEnterFtraceEvent::InternalSwap(Ext4UnlinkEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4UnlinkEnterFtraceEvent, size_)
      + sizeof(Ext4UnlinkEnterFtraceEvent::size_)
      - PROTOBUF_FIELD_OFFSET(Ext4UnlinkEnterFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4UnlinkEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4UnlinkEnterFtraceEvent";
}


// ===================================================================

class Ext4UnlinkExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4UnlinkExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4UnlinkExitFtraceEvent::Ext4UnlinkExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4UnlinkExitFtraceEvent)
}
Ext4UnlinkExitFtraceEvent::Ext4UnlinkExitFtraceEvent(const Ext4UnlinkExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4UnlinkExitFtraceEvent)
}

inline void Ext4UnlinkExitFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
}

Ext4UnlinkExitFtraceEvent::~Ext4UnlinkExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4UnlinkExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4UnlinkExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4UnlinkExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4UnlinkExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4UnlinkExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ret_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4UnlinkExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4UnlinkExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4UnlinkExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 ret = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4UnlinkExitFtraceEvent)
  return target;
}

size_t Ext4UnlinkExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4UnlinkExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 ret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4UnlinkExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4UnlinkExitFtraceEvent*>(
      &from));
}

void Ext4UnlinkExitFtraceEvent::MergeFrom(const Ext4UnlinkExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4UnlinkExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      ret_ = from.ret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4UnlinkExitFtraceEvent::CopyFrom(const Ext4UnlinkExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4UnlinkExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4UnlinkExitFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4UnlinkExitFtraceEvent::InternalSwap(Ext4UnlinkExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4UnlinkExitFtraceEvent, ret_)
      + sizeof(Ext4UnlinkExitFtraceEvent::ret_)
      - PROTOBUF_FIELD_OFFSET(Ext4UnlinkExitFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4UnlinkExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4UnlinkExitFtraceEvent";
}


// ===================================================================

class Ext4WriteBeginFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4WriteBeginFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4WriteBeginFtraceEvent::Ext4WriteBeginFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4WriteBeginFtraceEvent)
}
Ext4WriteBeginFtraceEvent::Ext4WriteBeginFtraceEvent(const Ext4WriteBeginFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4WriteBeginFtraceEvent)
}

inline void Ext4WriteBeginFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
}

Ext4WriteBeginFtraceEvent::~Ext4WriteBeginFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4WriteBeginFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4WriteBeginFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4WriteBeginFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4WriteBeginFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4WriteBeginFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flags_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4WriteBeginFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4WriteBeginFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4WriteBeginFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_pos(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_len(), target);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4WriteBeginFtraceEvent)
  return target;
}

size_t Ext4WriteBeginFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4WriteBeginFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_pos());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4WriteBeginFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4WriteBeginFtraceEvent*>(
      &from));
}

void Ext4WriteBeginFtraceEvent::MergeFrom(const Ext4WriteBeginFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4WriteBeginFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pos_ = from.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      flags_ = from.flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4WriteBeginFtraceEvent::CopyFrom(const Ext4WriteBeginFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4WriteBeginFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4WriteBeginFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4WriteBeginFtraceEvent::InternalSwap(Ext4WriteBeginFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4WriteBeginFtraceEvent, flags_)
      + sizeof(Ext4WriteBeginFtraceEvent::flags_)
      - PROTOBUF_FIELD_OFFSET(Ext4WriteBeginFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4WriteBeginFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4WriteBeginFtraceEvent";
}


// ===================================================================

class Ext4WriteEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4WriteEndFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_copied(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4WriteEndFtraceEvent::Ext4WriteEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4WriteEndFtraceEvent)
}
Ext4WriteEndFtraceEvent::Ext4WriteEndFtraceEvent(const Ext4WriteEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&copied_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(copied_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4WriteEndFtraceEvent)
}

inline void Ext4WriteEndFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&copied_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(copied_));
}

Ext4WriteEndFtraceEvent::~Ext4WriteEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4WriteEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4WriteEndFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4WriteEndFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4WriteEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4WriteEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&copied_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(copied_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4WriteEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 copied = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_copied(&has_bits);
          copied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4WriteEndFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4WriteEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_pos(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_len(), target);
  }

  // optional uint32 copied = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_copied(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4WriteEndFtraceEvent)
  return target;
}

size_t Ext4WriteEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4WriteEndFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_pos());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint32 copied = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_copied());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4WriteEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4WriteEndFtraceEvent*>(
      &from));
}

void Ext4WriteEndFtraceEvent::MergeFrom(const Ext4WriteEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4WriteEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pos_ = from.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      copied_ = from.copied_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4WriteEndFtraceEvent::CopyFrom(const Ext4WriteEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4WriteEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4WriteEndFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4WriteEndFtraceEvent::InternalSwap(Ext4WriteEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4WriteEndFtraceEvent, copied_)
      + sizeof(Ext4WriteEndFtraceEvent::copied_)
      - PROTOBUF_FIELD_OFFSET(Ext4WriteEndFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4WriteEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4WriteEndFtraceEvent";
}


// ===================================================================

class Ext4WritepageFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4WritepageFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Ext4WritepageFtraceEvent::Ext4WritepageFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4WritepageFtraceEvent)
}
Ext4WritepageFtraceEvent::Ext4WritepageFtraceEvent(const Ext4WritepageFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(index_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4WritepageFtraceEvent)
}

inline void Ext4WritepageFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(index_));
}

Ext4WritepageFtraceEvent::~Ext4WritepageFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4WritepageFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4WritepageFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4WritepageFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4WritepageFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4WritepageFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&index_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(index_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4WritepageFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4WritepageFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4WritepageFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4WritepageFtraceEvent)
  return target;
}

size_t Ext4WritepageFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4WritepageFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_index());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4WritepageFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4WritepageFtraceEvent*>(
      &from));
}

void Ext4WritepageFtraceEvent::MergeFrom(const Ext4WritepageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4WritepageFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      index_ = from.index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4WritepageFtraceEvent::CopyFrom(const Ext4WritepageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4WritepageFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4WritepageFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4WritepageFtraceEvent::InternalSwap(Ext4WritepageFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4WritepageFtraceEvent, index_)
      + sizeof(Ext4WritepageFtraceEvent::index_)
      - PROTOBUF_FIELD_OFFSET(Ext4WritepageFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4WritepageFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4WritepageFtraceEvent";
}


// ===================================================================

class Ext4WritepagesFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4WritepagesFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nr_to_write(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pages_skipped(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_range_start(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_range_end(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_writeback_index(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_sync_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_for_kupdate(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_range_cyclic(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

Ext4WritepagesFtraceEvent::Ext4WritepagesFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4WritepagesFtraceEvent)
}
Ext4WritepagesFtraceEvent::Ext4WritepagesFtraceEvent(const Ext4WritepagesFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&range_cyclic_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(range_cyclic_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4WritepagesFtraceEvent)
}

inline void Ext4WritepagesFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&range_cyclic_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(range_cyclic_));
}

Ext4WritepagesFtraceEvent::~Ext4WritepagesFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4WritepagesFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4WritepagesFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4WritepagesFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4WritepagesFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4WritepagesFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&sync_mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(sync_mode_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&for_kupdate_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&range_cyclic_) -
        reinterpret_cast<char*>(&for_kupdate_)) + sizeof(range_cyclic_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4WritepagesFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 nr_to_write = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_nr_to_write(&has_bits);
          nr_to_write_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 pages_skipped = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_pages_skipped(&has_bits);
          pages_skipped_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 range_start = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_range_start(&has_bits);
          range_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 range_end = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_range_end(&has_bits);
          range_end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 writeback_index = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_writeback_index(&has_bits);
          writeback_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 sync_mode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_sync_mode(&has_bits);
          sync_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 for_kupdate = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_for_kupdate(&has_bits);
          for_kupdate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 range_cyclic = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_range_cyclic(&has_bits);
          range_cyclic_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4WritepagesFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4WritepagesFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 nr_to_write = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_nr_to_write(), target);
  }

  // optional int64 pages_skipped = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_pages_skipped(), target);
  }

  // optional int64 range_start = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_range_start(), target);
  }

  // optional int64 range_end = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_range_end(), target);
  }

  // optional uint64 writeback_index = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_writeback_index(), target);
  }

  // optional int32 sync_mode = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_sync_mode(), target);
  }

  // optional uint32 for_kupdate = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_for_kupdate(), target);
  }

  // optional uint32 range_cyclic = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_range_cyclic(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4WritepagesFtraceEvent)
  return target;
}

size_t Ext4WritepagesFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4WritepagesFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 nr_to_write = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_nr_to_write());
    }

    // optional int64 pages_skipped = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_pages_skipped());
    }

    // optional int64 range_start = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_range_start());
    }

    // optional int64 range_end = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_range_end());
    }

    // optional uint64 writeback_index = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_writeback_index());
    }

    // optional int32 sync_mode = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sync_mode());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 for_kupdate = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_for_kupdate());
    }

    // optional uint32 range_cyclic = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_range_cyclic());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4WritepagesFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4WritepagesFtraceEvent*>(
      &from));
}

void Ext4WritepagesFtraceEvent::MergeFrom(const Ext4WritepagesFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4WritepagesFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      nr_to_write_ = from.nr_to_write_;
    }
    if (cached_has_bits & 0x00000008u) {
      pages_skipped_ = from.pages_skipped_;
    }
    if (cached_has_bits & 0x00000010u) {
      range_start_ = from.range_start_;
    }
    if (cached_has_bits & 0x00000020u) {
      range_end_ = from.range_end_;
    }
    if (cached_has_bits & 0x00000040u) {
      writeback_index_ = from.writeback_index_;
    }
    if (cached_has_bits & 0x00000080u) {
      sync_mode_ = from.sync_mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      for_kupdate_ = from.for_kupdate_;
    }
    if (cached_has_bits & 0x00000200u) {
      range_cyclic_ = from.range_cyclic_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4WritepagesFtraceEvent::CopyFrom(const Ext4WritepagesFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4WritepagesFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4WritepagesFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4WritepagesFtraceEvent::InternalSwap(Ext4WritepagesFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4WritepagesFtraceEvent, range_cyclic_)
      + sizeof(Ext4WritepagesFtraceEvent::range_cyclic_)
      - PROTOBUF_FIELD_OFFSET(Ext4WritepagesFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4WritepagesFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4WritepagesFtraceEvent";
}


// ===================================================================

class Ext4WritepagesResultFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4WritepagesResultFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pages_written(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pages_skipped(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_writeback_index(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_sync_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

Ext4WritepagesResultFtraceEvent::Ext4WritepagesResultFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4WritepagesResultFtraceEvent)
}
Ext4WritepagesResultFtraceEvent::Ext4WritepagesResultFtraceEvent(const Ext4WritepagesResultFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&sync_mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(sync_mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4WritepagesResultFtraceEvent)
}

inline void Ext4WritepagesResultFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&sync_mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(sync_mode_));
}

Ext4WritepagesResultFtraceEvent::~Ext4WritepagesResultFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4WritepagesResultFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4WritepagesResultFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4WritepagesResultFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4WritepagesResultFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4WritepagesResultFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&sync_mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(sync_mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4WritepagesResultFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pages_written = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_pages_written(&has_bits);
          pages_written_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 pages_skipped = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_pages_skipped(&has_bits);
          pages_skipped_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 writeback_index = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_writeback_index(&has_bits);
          writeback_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 sync_mode = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_sync_mode(&has_bits);
          sync_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4WritepagesResultFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4WritepagesResultFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 ret = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_ret(), target);
  }

  // optional int32 pages_written = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_pages_written(), target);
  }

  // optional int64 pages_skipped = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_pages_skipped(), target);
  }

  // optional uint64 writeback_index = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_writeback_index(), target);
  }

  // optional int32 sync_mode = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_sync_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4WritepagesResultFtraceEvent)
  return target;
}

size_t Ext4WritepagesResultFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4WritepagesResultFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 ret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

    // optional int32 pages_written = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pages_written());
    }

    // optional int64 pages_skipped = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_pages_skipped());
    }

    // optional uint64 writeback_index = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_writeback_index());
    }

    // optional int32 sync_mode = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sync_mode());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4WritepagesResultFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4WritepagesResultFtraceEvent*>(
      &from));
}

void Ext4WritepagesResultFtraceEvent::MergeFrom(const Ext4WritepagesResultFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4WritepagesResultFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      ret_ = from.ret_;
    }
    if (cached_has_bits & 0x00000008u) {
      pages_written_ = from.pages_written_;
    }
    if (cached_has_bits & 0x00000010u) {
      pages_skipped_ = from.pages_skipped_;
    }
    if (cached_has_bits & 0x00000020u) {
      writeback_index_ = from.writeback_index_;
    }
    if (cached_has_bits & 0x00000040u) {
      sync_mode_ = from.sync_mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4WritepagesResultFtraceEvent::CopyFrom(const Ext4WritepagesResultFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4WritepagesResultFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4WritepagesResultFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4WritepagesResultFtraceEvent::InternalSwap(Ext4WritepagesResultFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4WritepagesResultFtraceEvent, sync_mode_)
      + sizeof(Ext4WritepagesResultFtraceEvent::sync_mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4WritepagesResultFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4WritepagesResultFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4WritepagesResultFtraceEvent";
}


// ===================================================================

class Ext4ZeroRangeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<Ext4ZeroRangeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Ext4ZeroRangeFtraceEvent::Ext4ZeroRangeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.Ext4ZeroRangeFtraceEvent)
}
Ext4ZeroRangeFtraceEvent::Ext4ZeroRangeFtraceEvent(const Ext4ZeroRangeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Ext4ZeroRangeFtraceEvent)
}

inline void Ext4ZeroRangeFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
}

Ext4ZeroRangeFtraceEvent::~Ext4ZeroRangeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Ext4ZeroRangeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ext4ZeroRangeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ext4ZeroRangeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Ext4ZeroRangeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Ext4ZeroRangeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mode_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Ext4ZeroRangeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ext4ZeroRangeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.Ext4ZeroRangeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 offset = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_offset(), target);
  }

  // optional int64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_len(), target);
  }

  // optional int32 mode = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.Ext4ZeroRangeFtraceEvent)
  return target;
}

size_t Ext4ZeroRangeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Ext4ZeroRangeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 offset = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_offset());
    }

    // optional int64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_len());
    }

    // optional int32 mode = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mode());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Ext4ZeroRangeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Ext4ZeroRangeFtraceEvent*>(
      &from));
}

void Ext4ZeroRangeFtraceEvent::MergeFrom(const Ext4ZeroRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Ext4ZeroRangeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Ext4ZeroRangeFtraceEvent::CopyFrom(const Ext4ZeroRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Ext4ZeroRangeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ext4ZeroRangeFtraceEvent::IsInitialized() const {
  return true;
}

void Ext4ZeroRangeFtraceEvent::InternalSwap(Ext4ZeroRangeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ext4ZeroRangeFtraceEvent, mode_)
      + sizeof(Ext4ZeroRangeFtraceEvent::mode_)
      - PROTOBUF_FIELD_OFFSET(Ext4ZeroRangeFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string Ext4ZeroRangeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.Ext4ZeroRangeFtraceEvent";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DaWriteBeginFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DaWriteBeginFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DaWriteBeginFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DaWriteEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DaWriteEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DaWriteEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4SyncFileEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4SyncFileEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4SyncFileEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4SyncFileExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4SyncFileExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4SyncFileExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4AllocDaBlocksFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4AllocDaBlocksFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4AllocDaBlocksFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4AllocateBlocksFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4AllocateBlocksFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4AllocateBlocksFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4AllocateInodeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4AllocateInodeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4AllocateInodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4BeginOrderedTruncateFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4BeginOrderedTruncateFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4BeginOrderedTruncateFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4CollapseRangeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4CollapseRangeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4CollapseRangeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DaReleaseSpaceFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DaReleaseSpaceFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DaReleaseSpaceFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DaReserveSpaceFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DaReserveSpaceFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DaReserveSpaceFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DaUpdateReserveSpaceFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DaUpdateReserveSpaceFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DaUpdateReserveSpaceFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DaWritePagesFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DaWritePagesFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DaWritePagesFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DaWritePagesExtentFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DaWritePagesExtentFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DaWritePagesExtentFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DirectIOEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DirectIOEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DirectIOEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DirectIOExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DirectIOExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DirectIOExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DiscardBlocksFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DiscardBlocksFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DiscardBlocksFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DiscardPreallocationsFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DiscardPreallocationsFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DiscardPreallocationsFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4DropInodeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4DropInodeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4DropInodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsCacheExtentFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsCacheExtentFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EsCacheExtentFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsFindDelayedExtentRangeEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsFindDelayedExtentRangeEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EsFindDelayedExtentRangeEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsFindDelayedExtentRangeExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsFindDelayedExtentRangeExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EsFindDelayedExtentRangeExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsInsertExtentFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsInsertExtentFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EsInsertExtentFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsLookupExtentEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsLookupExtentEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EsLookupExtentEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsLookupExtentExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsLookupExtentExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EsLookupExtentExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsRemoveExtentFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsRemoveExtentFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EsRemoveExtentFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsShrinkFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsShrinkFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EsShrinkFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsShrinkCountFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsShrinkCountFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EsShrinkCountFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsShrinkScanEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsShrinkScanEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EsShrinkScanEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EsShrinkScanExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EsShrinkScanExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EsShrinkScanExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4EvictInodeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4EvictInodeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4EvictInodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtConvertToInitializedEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtConvertToInitializedEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtConvertToInitializedEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtConvertToInitializedFastpathFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtHandleUnwrittenExtentsFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtHandleUnwrittenExtentsFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtHandleUnwrittenExtentsFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtInCacheFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtInCacheFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtInCacheFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtLoadExtentFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtLoadExtentFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtLoadExtentFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtMapBlocksEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtMapBlocksEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtMapBlocksEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtMapBlocksExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtMapBlocksExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtMapBlocksExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtPutInCacheFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtPutInCacheFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtPutInCacheFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtRemoveSpaceFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtRemoveSpaceFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtRemoveSpaceFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtRemoveSpaceDoneFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtRmIdxFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtRmIdxFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtRmIdxFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtRmLeafFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtRmLeafFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtRmLeafFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ExtShowExtentFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ExtShowExtentFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ExtShowExtentFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4FallocateEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4FallocateEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4FallocateEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4FallocateExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4FallocateExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4FallocateExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4FindDelallocRangeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4FindDelallocRangeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4FindDelallocRangeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ForgetFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ForgetFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ForgetFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4FreeBlocksFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4FreeBlocksFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4FreeBlocksFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4FreeInodeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4FreeInodeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4FreeInodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4GetImpliedClusterAllocExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4GetImpliedClusterAllocExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4GetImpliedClusterAllocExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4GetReservedClusterAllocFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4GetReservedClusterAllocFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4GetReservedClusterAllocFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4IndMapBlocksEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4IndMapBlocksEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4IndMapBlocksEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4IndMapBlocksExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4IndMapBlocksExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4IndMapBlocksExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4InsertRangeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4InsertRangeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4InsertRangeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4InvalidatepageFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4InvalidatepageFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4InvalidatepageFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4JournalStartFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4JournalStartFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4JournalStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4JournalStartReservedFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4JournalStartReservedFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4JournalStartReservedFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4JournalledInvalidatepageFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4JournalledInvalidatepageFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4JournalledInvalidatepageFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4JournalledWriteEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4JournalledWriteEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4JournalledWriteEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4LoadInodeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4LoadInodeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4LoadInodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4LoadInodeBitmapFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4LoadInodeBitmapFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4LoadInodeBitmapFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MarkInodeDirtyFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MarkInodeDirtyFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MarkInodeDirtyFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MbBitmapLoadFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MbBitmapLoadFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MbBitmapLoadFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MbBuddyBitmapLoadFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MbBuddyBitmapLoadFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MbBuddyBitmapLoadFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MbDiscardPreallocationsFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MbDiscardPreallocationsFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MbDiscardPreallocationsFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MbNewGroupPaFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MbNewGroupPaFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MbNewGroupPaFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MbNewInodePaFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MbNewInodePaFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MbNewInodePaFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MbReleaseGroupPaFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MbReleaseGroupPaFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MbReleaseGroupPaFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MbReleaseInodePaFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MbReleaseInodePaFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MbReleaseInodePaFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MballocAllocFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MballocAllocFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MballocAllocFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MballocDiscardFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MballocDiscardFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MballocDiscardFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MballocFreeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MballocFreeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MballocFreeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4MballocPreallocFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4MballocPreallocFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4MballocPreallocFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4OtherInodeUpdateTimeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4OtherInodeUpdateTimeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4OtherInodeUpdateTimeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4PunchHoleFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4PunchHoleFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4PunchHoleFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ReadBlockBitmapLoadFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ReadBlockBitmapLoadFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ReadBlockBitmapLoadFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ReadpageFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ReadpageFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ReadpageFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ReleasepageFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ReleasepageFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ReleasepageFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4RemoveBlocksFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4RemoveBlocksFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4RemoveBlocksFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4RequestBlocksFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4RequestBlocksFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4RequestBlocksFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4RequestInodeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4RequestInodeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4RequestInodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4SyncFsFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4SyncFsFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4SyncFsFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4TrimAllFreeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4TrimAllFreeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4TrimAllFreeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4TrimExtentFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4TrimExtentFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4TrimExtentFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4TruncateEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4TruncateEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4TruncateEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4TruncateExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4TruncateExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4TruncateExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4UnlinkEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4UnlinkEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4UnlinkEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4UnlinkExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4UnlinkExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4UnlinkExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4WriteBeginFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4WriteBeginFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4WriteBeginFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4WriteEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4WriteEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4WriteEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4WritepageFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4WritepageFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4WritepageFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4WritepagesFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4WritepagesFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4WritepagesFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4WritepagesResultFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4WritepagesResultFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4WritepagesResultFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::Ext4ZeroRangeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::Ext4ZeroRangeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::Ext4ZeroRangeFtraceEvent >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
