// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/ftrace/sched.proto

#include "protos/perfetto/trace/ftrace/sched.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace perfetto {
namespace protos {
PROTOBUF_CONSTEXPR SchedSwitchFtraceEvent::SchedSwitchFtraceEvent(
    ::_pbi::ConstantInitialized)
  : prev_comm_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , next_comm_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , prev_pid_(0)
  , prev_prio_(0)
  , prev_state_(int64_t{0})
  , next_pid_(0)
  , next_prio_(0){}
struct SchedSwitchFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedSwitchFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedSwitchFtraceEventDefaultTypeInternal() {}
  union {
    SchedSwitchFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedSwitchFtraceEventDefaultTypeInternal _SchedSwitchFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedWakeupFtraceEvent::SchedWakeupFtraceEvent(
    ::_pbi::ConstantInitialized)
  : comm_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , pid_(0)
  , prio_(0)
  , success_(0)
  , target_cpu_(0){}
struct SchedWakeupFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedWakeupFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedWakeupFtraceEventDefaultTypeInternal() {}
  union {
    SchedWakeupFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedWakeupFtraceEventDefaultTypeInternal _SchedWakeupFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedBlockedReasonFtraceEvent::SchedBlockedReasonFtraceEvent(
    ::_pbi::ConstantInitialized)
  : caller_(uint64_t{0u})
  , pid_(0)
  , io_wait_(0u){}
struct SchedBlockedReasonFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedBlockedReasonFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedBlockedReasonFtraceEventDefaultTypeInternal() {}
  union {
    SchedBlockedReasonFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedBlockedReasonFtraceEventDefaultTypeInternal _SchedBlockedReasonFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedCpuHotplugFtraceEvent::SchedCpuHotplugFtraceEvent(
    ::_pbi::ConstantInitialized)
  : affected_cpu_(0)
  , error_(0)
  , status_(0){}
struct SchedCpuHotplugFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedCpuHotplugFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedCpuHotplugFtraceEventDefaultTypeInternal() {}
  union {
    SchedCpuHotplugFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedCpuHotplugFtraceEventDefaultTypeInternal _SchedCpuHotplugFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedWakingFtraceEvent::SchedWakingFtraceEvent(
    ::_pbi::ConstantInitialized)
  : comm_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , pid_(0)
  , prio_(0)
  , success_(0)
  , target_cpu_(0){}
struct SchedWakingFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedWakingFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedWakingFtraceEventDefaultTypeInternal() {}
  union {
    SchedWakingFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedWakingFtraceEventDefaultTypeInternal _SchedWakingFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedWakeupNewFtraceEvent::SchedWakeupNewFtraceEvent(
    ::_pbi::ConstantInitialized)
  : comm_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , pid_(0)
  , prio_(0)
  , success_(0)
  , target_cpu_(0){}
struct SchedWakeupNewFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedWakeupNewFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedWakeupNewFtraceEventDefaultTypeInternal() {}
  union {
    SchedWakeupNewFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedWakeupNewFtraceEventDefaultTypeInternal _SchedWakeupNewFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedProcessExecFtraceEvent::SchedProcessExecFtraceEvent(
    ::_pbi::ConstantInitialized)
  : filename_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , pid_(0)
  , old_pid_(0){}
struct SchedProcessExecFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedProcessExecFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedProcessExecFtraceEventDefaultTypeInternal() {}
  union {
    SchedProcessExecFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedProcessExecFtraceEventDefaultTypeInternal _SchedProcessExecFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedProcessExitFtraceEvent::SchedProcessExitFtraceEvent(
    ::_pbi::ConstantInitialized)
  : comm_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , pid_(0)
  , tgid_(0)
  , prio_(0){}
struct SchedProcessExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedProcessExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedProcessExitFtraceEventDefaultTypeInternal() {}
  union {
    SchedProcessExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedProcessExitFtraceEventDefaultTypeInternal _SchedProcessExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedProcessForkFtraceEvent::SchedProcessForkFtraceEvent(
    ::_pbi::ConstantInitialized)
  : parent_comm_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , child_comm_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , parent_pid_(0)
  , child_pid_(0){}
struct SchedProcessForkFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedProcessForkFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedProcessForkFtraceEventDefaultTypeInternal() {}
  union {
    SchedProcessForkFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedProcessForkFtraceEventDefaultTypeInternal _SchedProcessForkFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedProcessFreeFtraceEvent::SchedProcessFreeFtraceEvent(
    ::_pbi::ConstantInitialized)
  : comm_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , pid_(0)
  , prio_(0){}
struct SchedProcessFreeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedProcessFreeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedProcessFreeFtraceEventDefaultTypeInternal() {}
  union {
    SchedProcessFreeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedProcessFreeFtraceEventDefaultTypeInternal _SchedProcessFreeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedProcessHangFtraceEvent::SchedProcessHangFtraceEvent(
    ::_pbi::ConstantInitialized)
  : comm_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , pid_(0){}
struct SchedProcessHangFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedProcessHangFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedProcessHangFtraceEventDefaultTypeInternal() {}
  union {
    SchedProcessHangFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedProcessHangFtraceEventDefaultTypeInternal _SchedProcessHangFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedProcessWaitFtraceEvent::SchedProcessWaitFtraceEvent(
    ::_pbi::ConstantInitialized)
  : comm_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , pid_(0)
  , prio_(0){}
struct SchedProcessWaitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedProcessWaitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedProcessWaitFtraceEventDefaultTypeInternal() {}
  union {
    SchedProcessWaitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedProcessWaitFtraceEventDefaultTypeInternal _SchedProcessWaitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedPiSetprioFtraceEvent::SchedPiSetprioFtraceEvent(
    ::_pbi::ConstantInitialized)
  : comm_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , newprio_(0)
  , oldprio_(0)
  , pid_(0){}
struct SchedPiSetprioFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedPiSetprioFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedPiSetprioFtraceEventDefaultTypeInternal() {}
  union {
    SchedPiSetprioFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedPiSetprioFtraceEventDefaultTypeInternal _SchedPiSetprioFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedCpuUtilCfsFtraceEvent::SchedCpuUtilCfsFtraceEvent(
    ::_pbi::ConstantInitialized)
  : capacity_(uint64_t{0u})
  , active_(0)
  , cpu_(0u)
  , capacity_orig_(uint64_t{0u})
  , cpu_importance_(uint64_t{0u})
  , cpu_util_(uint64_t{0u})
  , group_capacity_(uint64_t{0u})
  , exit_lat_(0u)
  , grp_overutilized_(0u)
  , idle_cpu_(0u)
  , nr_running_(0u)
  , spare_cap_(int64_t{0})
  , wake_group_util_(uint64_t{0u})
  , wake_util_(uint64_t{0u})
  , task_fits_(0u){}
struct SchedCpuUtilCfsFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedCpuUtilCfsFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedCpuUtilCfsFtraceEventDefaultTypeInternal() {}
  union {
    SchedCpuUtilCfsFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedCpuUtilCfsFtraceEventDefaultTypeInternal _SchedCpuUtilCfsFtraceEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
namespace perfetto {
namespace protos {

// ===================================================================

class SchedSwitchFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedSwitchFtraceEvent>()._has_bits_);
  static void set_has_prev_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_prev_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_prev_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_prev_state(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_next_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_next_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_next_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

SchedSwitchFtraceEvent::SchedSwitchFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedSwitchFtraceEvent)
}
SchedSwitchFtraceEvent::SchedSwitchFtraceEvent(const SchedSwitchFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  prev_comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    prev_comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_prev_comm()) {
    prev_comm_.Set(from._internal_prev_comm(), 
      GetArenaForAllocation());
  }
  next_comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    next_comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_next_comm()) {
    next_comm_.Set(from._internal_next_comm(), 
      GetArenaForAllocation());
  }
  ::memcpy(&prev_pid_, &from.prev_pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&next_prio_) -
    reinterpret_cast<char*>(&prev_pid_)) + sizeof(next_prio_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedSwitchFtraceEvent)
}

inline void SchedSwitchFtraceEvent::SharedCtor() {
prev_comm_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  prev_comm_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
next_comm_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  next_comm_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&prev_pid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&next_prio_) -
    reinterpret_cast<char*>(&prev_pid_)) + sizeof(next_prio_));
}

SchedSwitchFtraceEvent::~SchedSwitchFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedSwitchFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedSwitchFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  prev_comm_.Destroy();
  next_comm_.Destroy();
}

void SchedSwitchFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SchedSwitchFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedSwitchFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      prev_comm_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      next_comm_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&prev_pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&next_prio_) -
        reinterpret_cast<char*>(&prev_pid_)) + sizeof(next_prio_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedSwitchFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string prev_comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_prev_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 prev_pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_prev_pid(&has_bits);
          prev_pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 prev_prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_prev_prio(&has_bits);
          prev_prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 prev_state = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_prev_state(&has_bits);
          prev_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string next_comm = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_next_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 next_pid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_next_pid(&has_bits);
          next_pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 next_prio = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_next_prio(&has_bits);
          next_prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedSwitchFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedSwitchFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string prev_comm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_prev_comm(), target);
  }

  // optional int32 prev_pid = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_prev_pid(), target);
  }

  // optional int32 prev_prio = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_prev_prio(), target);
  }

  // optional int64 prev_state = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_prev_state(), target);
  }

  // optional string next_comm = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_next_comm(), target);
  }

  // optional int32 next_pid = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_next_pid(), target);
  }

  // optional int32 next_prio = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_next_prio(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedSwitchFtraceEvent)
  return target;
}

size_t SchedSwitchFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedSwitchFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string prev_comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_prev_comm());
    }

    // optional string next_comm = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_next_comm());
    }

    // optional int32 prev_pid = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prev_pid());
    }

    // optional int32 prev_prio = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prev_prio());
    }

    // optional int64 prev_state = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_prev_state());
    }

    // optional int32 next_pid = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_next_pid());
    }

    // optional int32 next_prio = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_next_prio());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedSwitchFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedSwitchFtraceEvent*>(
      &from));
}

void SchedSwitchFtraceEvent::MergeFrom(const SchedSwitchFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedSwitchFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_prev_comm(from._internal_prev_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_next_comm(from._internal_next_comm());
    }
    if (cached_has_bits & 0x00000004u) {
      prev_pid_ = from.prev_pid_;
    }
    if (cached_has_bits & 0x00000008u) {
      prev_prio_ = from.prev_prio_;
    }
    if (cached_has_bits & 0x00000010u) {
      prev_state_ = from.prev_state_;
    }
    if (cached_has_bits & 0x00000020u) {
      next_pid_ = from.next_pid_;
    }
    if (cached_has_bits & 0x00000040u) {
      next_prio_ = from.next_prio_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedSwitchFtraceEvent::CopyFrom(const SchedSwitchFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedSwitchFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedSwitchFtraceEvent::IsInitialized() const {
  return true;
}

void SchedSwitchFtraceEvent::InternalSwap(SchedSwitchFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &prev_comm_, lhs_arena,
      &other->prev_comm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &next_comm_, lhs_arena,
      &other->next_comm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedSwitchFtraceEvent, next_prio_)
      + sizeof(SchedSwitchFtraceEvent::next_prio_)
      - PROTOBUF_FIELD_OFFSET(SchedSwitchFtraceEvent, prev_pid_)>(
          reinterpret_cast<char*>(&prev_pid_),
          reinterpret_cast<char*>(&other->prev_pid_));
}

std::string SchedSwitchFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedSwitchFtraceEvent";
}


// ===================================================================

class SchedWakeupFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedWakeupFtraceEvent>()._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_target_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

SchedWakeupFtraceEvent::SchedWakeupFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedWakeupFtraceEvent)
}
SchedWakeupFtraceEvent::SchedWakeupFtraceEvent(const SchedWakeupFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_comm()) {
    comm_.Set(from._internal_comm(), 
      GetArenaForAllocation());
  }
  ::memcpy(&pid_, &from.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&target_cpu_) -
    reinterpret_cast<char*>(&pid_)) + sizeof(target_cpu_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedWakeupFtraceEvent)
}

inline void SchedWakeupFtraceEvent::SharedCtor() {
comm_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  comm_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&pid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&target_cpu_) -
    reinterpret_cast<char*>(&pid_)) + sizeof(target_cpu_));
}

SchedWakeupFtraceEvent::~SchedWakeupFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedWakeupFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedWakeupFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  comm_.Destroy();
}

void SchedWakeupFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SchedWakeupFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedWakeupFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    comm_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&target_cpu_) -
        reinterpret_cast<char*>(&pid_)) + sizeof(target_cpu_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedWakeupFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_prio(&has_bits);
          prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 success = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_success(&has_bits);
          success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 target_cpu = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_target_cpu(&has_bits);
          target_cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedWakeupFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedWakeupFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_comm(), target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_pid(), target);
  }

  // optional int32 prio = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_prio(), target);
  }

  // optional int32 success = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_success(), target);
  }

  // optional int32 target_cpu = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_target_cpu(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedWakeupFtraceEvent)
  return target;
}

size_t SchedWakeupFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedWakeupFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

    // optional int32 prio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prio());
    }

    // optional int32 success = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_success());
    }

    // optional int32 target_cpu = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_cpu());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedWakeupFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedWakeupFtraceEvent*>(
      &from));
}

void SchedWakeupFtraceEvent::MergeFrom(const SchedWakeupFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedWakeupFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      pid_ = from.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      prio_ = from.prio_;
    }
    if (cached_has_bits & 0x00000008u) {
      success_ = from.success_;
    }
    if (cached_has_bits & 0x00000010u) {
      target_cpu_ = from.target_cpu_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedWakeupFtraceEvent::CopyFrom(const SchedWakeupFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedWakeupFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedWakeupFtraceEvent::IsInitialized() const {
  return true;
}

void SchedWakeupFtraceEvent::InternalSwap(SchedWakeupFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &comm_, lhs_arena,
      &other->comm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedWakeupFtraceEvent, target_cpu_)
      + sizeof(SchedWakeupFtraceEvent::target_cpu_)
      - PROTOBUF_FIELD_OFFSET(SchedWakeupFtraceEvent, pid_)>(
          reinterpret_cast<char*>(&pid_),
          reinterpret_cast<char*>(&other->pid_));
}

std::string SchedWakeupFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedWakeupFtraceEvent";
}


// ===================================================================

class SchedBlockedReasonFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedBlockedReasonFtraceEvent>()._has_bits_);
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_caller(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_io_wait(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SchedBlockedReasonFtraceEvent::SchedBlockedReasonFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedBlockedReasonFtraceEvent)
}
SchedBlockedReasonFtraceEvent::SchedBlockedReasonFtraceEvent(const SchedBlockedReasonFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&caller_, &from.caller_,
    static_cast<size_t>(reinterpret_cast<char*>(&io_wait_) -
    reinterpret_cast<char*>(&caller_)) + sizeof(io_wait_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedBlockedReasonFtraceEvent)
}

inline void SchedBlockedReasonFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&caller_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&io_wait_) -
    reinterpret_cast<char*>(&caller_)) + sizeof(io_wait_));
}

SchedBlockedReasonFtraceEvent::~SchedBlockedReasonFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedBlockedReasonFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedBlockedReasonFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SchedBlockedReasonFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SchedBlockedReasonFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedBlockedReasonFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&caller_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&io_wait_) -
        reinterpret_cast<char*>(&caller_)) + sizeof(io_wait_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedBlockedReasonFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 pid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_pid(&has_bits);
          pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 caller = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_caller(&has_bits);
          caller_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 io_wait = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_io_wait(&has_bits);
          io_wait_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedBlockedReasonFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedBlockedReasonFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 pid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_pid(), target);
  }

  // optional uint64 caller = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_caller(), target);
  }

  // optional uint32 io_wait = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_io_wait(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedBlockedReasonFtraceEvent)
  return target;
}

size_t SchedBlockedReasonFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedBlockedReasonFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 caller = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_caller());
    }

    // optional int32 pid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

    // optional uint32 io_wait = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_io_wait());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedBlockedReasonFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedBlockedReasonFtraceEvent*>(
      &from));
}

void SchedBlockedReasonFtraceEvent::MergeFrom(const SchedBlockedReasonFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedBlockedReasonFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      caller_ = from.caller_;
    }
    if (cached_has_bits & 0x00000002u) {
      pid_ = from.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      io_wait_ = from.io_wait_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedBlockedReasonFtraceEvent::CopyFrom(const SchedBlockedReasonFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedBlockedReasonFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedBlockedReasonFtraceEvent::IsInitialized() const {
  return true;
}

void SchedBlockedReasonFtraceEvent::InternalSwap(SchedBlockedReasonFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedBlockedReasonFtraceEvent, io_wait_)
      + sizeof(SchedBlockedReasonFtraceEvent::io_wait_)
      - PROTOBUF_FIELD_OFFSET(SchedBlockedReasonFtraceEvent, caller_)>(
          reinterpret_cast<char*>(&caller_),
          reinterpret_cast<char*>(&other->caller_));
}

std::string SchedBlockedReasonFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedBlockedReasonFtraceEvent";
}


// ===================================================================

class SchedCpuHotplugFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedCpuHotplugFtraceEvent>()._has_bits_);
  static void set_has_affected_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SchedCpuHotplugFtraceEvent::SchedCpuHotplugFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedCpuHotplugFtraceEvent)
}
SchedCpuHotplugFtraceEvent::SchedCpuHotplugFtraceEvent(const SchedCpuHotplugFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&affected_cpu_, &from.affected_cpu_,
    static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&affected_cpu_)) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedCpuHotplugFtraceEvent)
}

inline void SchedCpuHotplugFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&affected_cpu_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&affected_cpu_)) + sizeof(status_));
}

SchedCpuHotplugFtraceEvent::~SchedCpuHotplugFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedCpuHotplugFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedCpuHotplugFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SchedCpuHotplugFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SchedCpuHotplugFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedCpuHotplugFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&affected_cpu_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&status_) -
        reinterpret_cast<char*>(&affected_cpu_)) + sizeof(status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedCpuHotplugFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 affected_cpu = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_affected_cpu(&has_bits);
          affected_cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 error = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_error(&has_bits);
          error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedCpuHotplugFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedCpuHotplugFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 affected_cpu = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_affected_cpu(), target);
  }

  // optional int32 error = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_error(), target);
  }

  // optional int32 status = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedCpuHotplugFtraceEvent)
  return target;
}

size_t SchedCpuHotplugFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedCpuHotplugFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int32 affected_cpu = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_affected_cpu());
    }

    // optional int32 error = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_error());
    }

    // optional int32 status = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_status());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedCpuHotplugFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedCpuHotplugFtraceEvent*>(
      &from));
}

void SchedCpuHotplugFtraceEvent::MergeFrom(const SchedCpuHotplugFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedCpuHotplugFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      affected_cpu_ = from.affected_cpu_;
    }
    if (cached_has_bits & 0x00000002u) {
      error_ = from.error_;
    }
    if (cached_has_bits & 0x00000004u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedCpuHotplugFtraceEvent::CopyFrom(const SchedCpuHotplugFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedCpuHotplugFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedCpuHotplugFtraceEvent::IsInitialized() const {
  return true;
}

void SchedCpuHotplugFtraceEvent::InternalSwap(SchedCpuHotplugFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedCpuHotplugFtraceEvent, status_)
      + sizeof(SchedCpuHotplugFtraceEvent::status_)
      - PROTOBUF_FIELD_OFFSET(SchedCpuHotplugFtraceEvent, affected_cpu_)>(
          reinterpret_cast<char*>(&affected_cpu_),
          reinterpret_cast<char*>(&other->affected_cpu_));
}

std::string SchedCpuHotplugFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedCpuHotplugFtraceEvent";
}


// ===================================================================

class SchedWakingFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedWakingFtraceEvent>()._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_target_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

SchedWakingFtraceEvent::SchedWakingFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedWakingFtraceEvent)
}
SchedWakingFtraceEvent::SchedWakingFtraceEvent(const SchedWakingFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_comm()) {
    comm_.Set(from._internal_comm(), 
      GetArenaForAllocation());
  }
  ::memcpy(&pid_, &from.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&target_cpu_) -
    reinterpret_cast<char*>(&pid_)) + sizeof(target_cpu_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedWakingFtraceEvent)
}

inline void SchedWakingFtraceEvent::SharedCtor() {
comm_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  comm_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&pid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&target_cpu_) -
    reinterpret_cast<char*>(&pid_)) + sizeof(target_cpu_));
}

SchedWakingFtraceEvent::~SchedWakingFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedWakingFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedWakingFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  comm_.Destroy();
}

void SchedWakingFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SchedWakingFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedWakingFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    comm_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&target_cpu_) -
        reinterpret_cast<char*>(&pid_)) + sizeof(target_cpu_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedWakingFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_prio(&has_bits);
          prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 success = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_success(&has_bits);
          success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 target_cpu = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_target_cpu(&has_bits);
          target_cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedWakingFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedWakingFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_comm(), target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_pid(), target);
  }

  // optional int32 prio = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_prio(), target);
  }

  // optional int32 success = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_success(), target);
  }

  // optional int32 target_cpu = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_target_cpu(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedWakingFtraceEvent)
  return target;
}

size_t SchedWakingFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedWakingFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

    // optional int32 prio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prio());
    }

    // optional int32 success = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_success());
    }

    // optional int32 target_cpu = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_cpu());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedWakingFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedWakingFtraceEvent*>(
      &from));
}

void SchedWakingFtraceEvent::MergeFrom(const SchedWakingFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedWakingFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      pid_ = from.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      prio_ = from.prio_;
    }
    if (cached_has_bits & 0x00000008u) {
      success_ = from.success_;
    }
    if (cached_has_bits & 0x00000010u) {
      target_cpu_ = from.target_cpu_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedWakingFtraceEvent::CopyFrom(const SchedWakingFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedWakingFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedWakingFtraceEvent::IsInitialized() const {
  return true;
}

void SchedWakingFtraceEvent::InternalSwap(SchedWakingFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &comm_, lhs_arena,
      &other->comm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedWakingFtraceEvent, target_cpu_)
      + sizeof(SchedWakingFtraceEvent::target_cpu_)
      - PROTOBUF_FIELD_OFFSET(SchedWakingFtraceEvent, pid_)>(
          reinterpret_cast<char*>(&pid_),
          reinterpret_cast<char*>(&other->pid_));
}

std::string SchedWakingFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedWakingFtraceEvent";
}


// ===================================================================

class SchedWakeupNewFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedWakeupNewFtraceEvent>()._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_target_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

SchedWakeupNewFtraceEvent::SchedWakeupNewFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedWakeupNewFtraceEvent)
}
SchedWakeupNewFtraceEvent::SchedWakeupNewFtraceEvent(const SchedWakeupNewFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_comm()) {
    comm_.Set(from._internal_comm(), 
      GetArenaForAllocation());
  }
  ::memcpy(&pid_, &from.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&target_cpu_) -
    reinterpret_cast<char*>(&pid_)) + sizeof(target_cpu_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedWakeupNewFtraceEvent)
}

inline void SchedWakeupNewFtraceEvent::SharedCtor() {
comm_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  comm_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&pid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&target_cpu_) -
    reinterpret_cast<char*>(&pid_)) + sizeof(target_cpu_));
}

SchedWakeupNewFtraceEvent::~SchedWakeupNewFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedWakeupNewFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedWakeupNewFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  comm_.Destroy();
}

void SchedWakeupNewFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SchedWakeupNewFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedWakeupNewFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    comm_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&target_cpu_) -
        reinterpret_cast<char*>(&pid_)) + sizeof(target_cpu_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedWakeupNewFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_prio(&has_bits);
          prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 success = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_success(&has_bits);
          success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 target_cpu = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_target_cpu(&has_bits);
          target_cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedWakeupNewFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedWakeupNewFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_comm(), target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_pid(), target);
  }

  // optional int32 prio = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_prio(), target);
  }

  // optional int32 success = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_success(), target);
  }

  // optional int32 target_cpu = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_target_cpu(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedWakeupNewFtraceEvent)
  return target;
}

size_t SchedWakeupNewFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedWakeupNewFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

    // optional int32 prio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prio());
    }

    // optional int32 success = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_success());
    }

    // optional int32 target_cpu = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_cpu());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedWakeupNewFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedWakeupNewFtraceEvent*>(
      &from));
}

void SchedWakeupNewFtraceEvent::MergeFrom(const SchedWakeupNewFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedWakeupNewFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      pid_ = from.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      prio_ = from.prio_;
    }
    if (cached_has_bits & 0x00000008u) {
      success_ = from.success_;
    }
    if (cached_has_bits & 0x00000010u) {
      target_cpu_ = from.target_cpu_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedWakeupNewFtraceEvent::CopyFrom(const SchedWakeupNewFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedWakeupNewFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedWakeupNewFtraceEvent::IsInitialized() const {
  return true;
}

void SchedWakeupNewFtraceEvent::InternalSwap(SchedWakeupNewFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &comm_, lhs_arena,
      &other->comm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedWakeupNewFtraceEvent, target_cpu_)
      + sizeof(SchedWakeupNewFtraceEvent::target_cpu_)
      - PROTOBUF_FIELD_OFFSET(SchedWakeupNewFtraceEvent, pid_)>(
          reinterpret_cast<char*>(&pid_),
          reinterpret_cast<char*>(&other->pid_));
}

std::string SchedWakeupNewFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedWakeupNewFtraceEvent";
}


// ===================================================================

class SchedProcessExecFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessExecFtraceEvent>()._has_bits_);
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_old_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SchedProcessExecFtraceEvent::SchedProcessExecFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedProcessExecFtraceEvent)
}
SchedProcessExecFtraceEvent::SchedProcessExecFtraceEvent(const SchedProcessExecFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filename()) {
    filename_.Set(from._internal_filename(), 
      GetArenaForAllocation());
  }
  ::memcpy(&pid_, &from.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&old_pid_) -
    reinterpret_cast<char*>(&pid_)) + sizeof(old_pid_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessExecFtraceEvent)
}

inline void SchedProcessExecFtraceEvent::SharedCtor() {
filename_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  filename_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&pid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&old_pid_) -
    reinterpret_cast<char*>(&pid_)) + sizeof(old_pid_));
}

SchedProcessExecFtraceEvent::~SchedProcessExecFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessExecFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedProcessExecFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  filename_.Destroy();
}

void SchedProcessExecFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SchedProcessExecFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessExecFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    filename_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&old_pid_) -
        reinterpret_cast<char*>(&pid_)) + sizeof(old_pid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedProcessExecFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string filename = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 old_pid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_old_pid(&has_bits);
          old_pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedProcessExecFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedProcessExecFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string filename = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_filename(), target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_pid(), target);
  }

  // optional int32 old_pid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_old_pid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedProcessExecFtraceEvent)
  return target;
}

size_t SchedProcessExecFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessExecFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string filename = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_filename());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

    // optional int32 old_pid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_old_pid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedProcessExecFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedProcessExecFtraceEvent*>(
      &from));
}

void SchedProcessExecFtraceEvent::MergeFrom(const SchedProcessExecFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessExecFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_filename(from._internal_filename());
    }
    if (cached_has_bits & 0x00000002u) {
      pid_ = from.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      old_pid_ = from.old_pid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedProcessExecFtraceEvent::CopyFrom(const SchedProcessExecFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessExecFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessExecFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessExecFtraceEvent::InternalSwap(SchedProcessExecFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &filename_, lhs_arena,
      &other->filename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedProcessExecFtraceEvent, old_pid_)
      + sizeof(SchedProcessExecFtraceEvent::old_pid_)
      - PROTOBUF_FIELD_OFFSET(SchedProcessExecFtraceEvent, pid_)>(
          reinterpret_cast<char*>(&pid_),
          reinterpret_cast<char*>(&other->pid_));
}

std::string SchedProcessExecFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedProcessExecFtraceEvent";
}


// ===================================================================

class SchedProcessExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessExitFtraceEvent>()._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tgid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SchedProcessExitFtraceEvent::SchedProcessExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedProcessExitFtraceEvent)
}
SchedProcessExitFtraceEvent::SchedProcessExitFtraceEvent(const SchedProcessExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_comm()) {
    comm_.Set(from._internal_comm(), 
      GetArenaForAllocation());
  }
  ::memcpy(&pid_, &from.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&prio_) -
    reinterpret_cast<char*>(&pid_)) + sizeof(prio_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessExitFtraceEvent)
}

inline void SchedProcessExitFtraceEvent::SharedCtor() {
comm_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  comm_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&pid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&prio_) -
    reinterpret_cast<char*>(&pid_)) + sizeof(prio_));
}

SchedProcessExitFtraceEvent::~SchedProcessExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedProcessExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  comm_.Destroy();
}

void SchedProcessExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SchedProcessExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    comm_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&prio_) -
        reinterpret_cast<char*>(&pid_)) + sizeof(prio_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedProcessExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 tgid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_tgid(&has_bits);
          tgid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 prio = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_prio(&has_bits);
          prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedProcessExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedProcessExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_comm(), target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_pid(), target);
  }

  // optional int32 tgid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_tgid(), target);
  }

  // optional int32 prio = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_prio(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedProcessExitFtraceEvent)
  return target;
}

size_t SchedProcessExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

    // optional int32 tgid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tgid());
    }

    // optional int32 prio = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prio());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedProcessExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedProcessExitFtraceEvent*>(
      &from));
}

void SchedProcessExitFtraceEvent::MergeFrom(const SchedProcessExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      pid_ = from.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      tgid_ = from.tgid_;
    }
    if (cached_has_bits & 0x00000008u) {
      prio_ = from.prio_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedProcessExitFtraceEvent::CopyFrom(const SchedProcessExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessExitFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessExitFtraceEvent::InternalSwap(SchedProcessExitFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &comm_, lhs_arena,
      &other->comm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedProcessExitFtraceEvent, prio_)
      + sizeof(SchedProcessExitFtraceEvent::prio_)
      - PROTOBUF_FIELD_OFFSET(SchedProcessExitFtraceEvent, pid_)>(
          reinterpret_cast<char*>(&pid_),
          reinterpret_cast<char*>(&other->pid_));
}

std::string SchedProcessExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedProcessExitFtraceEvent";
}


// ===================================================================

class SchedProcessForkFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessForkFtraceEvent>()._has_bits_);
  static void set_has_parent_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_parent_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_child_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_child_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SchedProcessForkFtraceEvent::SchedProcessForkFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedProcessForkFtraceEvent)
}
SchedProcessForkFtraceEvent::SchedProcessForkFtraceEvent(const SchedProcessForkFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  parent_comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    parent_comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_parent_comm()) {
    parent_comm_.Set(from._internal_parent_comm(), 
      GetArenaForAllocation());
  }
  child_comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    child_comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_child_comm()) {
    child_comm_.Set(from._internal_child_comm(), 
      GetArenaForAllocation());
  }
  ::memcpy(&parent_pid_, &from.parent_pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&child_pid_) -
    reinterpret_cast<char*>(&parent_pid_)) + sizeof(child_pid_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessForkFtraceEvent)
}

inline void SchedProcessForkFtraceEvent::SharedCtor() {
parent_comm_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  parent_comm_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
child_comm_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  child_comm_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&parent_pid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&child_pid_) -
    reinterpret_cast<char*>(&parent_pid_)) + sizeof(child_pid_));
}

SchedProcessForkFtraceEvent::~SchedProcessForkFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessForkFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedProcessForkFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  parent_comm_.Destroy();
  child_comm_.Destroy();
}

void SchedProcessForkFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SchedProcessForkFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessForkFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      parent_comm_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      child_comm_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&parent_pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&child_pid_) -
        reinterpret_cast<char*>(&parent_pid_)) + sizeof(child_pid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedProcessForkFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string parent_comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_parent_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 parent_pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_parent_pid(&has_bits);
          parent_pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string child_comm = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_child_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 child_pid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_child_pid(&has_bits);
          child_pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedProcessForkFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedProcessForkFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string parent_comm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_parent_comm(), target);
  }

  // optional int32 parent_pid = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_parent_pid(), target);
  }

  // optional string child_comm = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_child_comm(), target);
  }

  // optional int32 child_pid = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_child_pid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedProcessForkFtraceEvent)
  return target;
}

size_t SchedProcessForkFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessForkFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string parent_comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_parent_comm());
    }

    // optional string child_comm = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_child_comm());
    }

    // optional int32 parent_pid = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_parent_pid());
    }

    // optional int32 child_pid = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_child_pid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedProcessForkFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedProcessForkFtraceEvent*>(
      &from));
}

void SchedProcessForkFtraceEvent::MergeFrom(const SchedProcessForkFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessForkFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_parent_comm(from._internal_parent_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_child_comm(from._internal_child_comm());
    }
    if (cached_has_bits & 0x00000004u) {
      parent_pid_ = from.parent_pid_;
    }
    if (cached_has_bits & 0x00000008u) {
      child_pid_ = from.child_pid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedProcessForkFtraceEvent::CopyFrom(const SchedProcessForkFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessForkFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessForkFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessForkFtraceEvent::InternalSwap(SchedProcessForkFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &parent_comm_, lhs_arena,
      &other->parent_comm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &child_comm_, lhs_arena,
      &other->child_comm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedProcessForkFtraceEvent, child_pid_)
      + sizeof(SchedProcessForkFtraceEvent::child_pid_)
      - PROTOBUF_FIELD_OFFSET(SchedProcessForkFtraceEvent, parent_pid_)>(
          reinterpret_cast<char*>(&parent_pid_),
          reinterpret_cast<char*>(&other->parent_pid_));
}

std::string SchedProcessForkFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedProcessForkFtraceEvent";
}


// ===================================================================

class SchedProcessFreeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessFreeFtraceEvent>()._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SchedProcessFreeFtraceEvent::SchedProcessFreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedProcessFreeFtraceEvent)
}
SchedProcessFreeFtraceEvent::SchedProcessFreeFtraceEvent(const SchedProcessFreeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_comm()) {
    comm_.Set(from._internal_comm(), 
      GetArenaForAllocation());
  }
  ::memcpy(&pid_, &from.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&prio_) -
    reinterpret_cast<char*>(&pid_)) + sizeof(prio_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessFreeFtraceEvent)
}

inline void SchedProcessFreeFtraceEvent::SharedCtor() {
comm_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  comm_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&pid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&prio_) -
    reinterpret_cast<char*>(&pid_)) + sizeof(prio_));
}

SchedProcessFreeFtraceEvent::~SchedProcessFreeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessFreeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedProcessFreeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  comm_.Destroy();
}

void SchedProcessFreeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SchedProcessFreeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessFreeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    comm_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&prio_) -
        reinterpret_cast<char*>(&pid_)) + sizeof(prio_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedProcessFreeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_prio(&has_bits);
          prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedProcessFreeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedProcessFreeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_comm(), target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_pid(), target);
  }

  // optional int32 prio = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_prio(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedProcessFreeFtraceEvent)
  return target;
}

size_t SchedProcessFreeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessFreeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

    // optional int32 prio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prio());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedProcessFreeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedProcessFreeFtraceEvent*>(
      &from));
}

void SchedProcessFreeFtraceEvent::MergeFrom(const SchedProcessFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessFreeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      pid_ = from.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      prio_ = from.prio_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedProcessFreeFtraceEvent::CopyFrom(const SchedProcessFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessFreeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessFreeFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessFreeFtraceEvent::InternalSwap(SchedProcessFreeFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &comm_, lhs_arena,
      &other->comm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedProcessFreeFtraceEvent, prio_)
      + sizeof(SchedProcessFreeFtraceEvent::prio_)
      - PROTOBUF_FIELD_OFFSET(SchedProcessFreeFtraceEvent, pid_)>(
          reinterpret_cast<char*>(&pid_),
          reinterpret_cast<char*>(&other->pid_));
}

std::string SchedProcessFreeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedProcessFreeFtraceEvent";
}


// ===================================================================

class SchedProcessHangFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessHangFtraceEvent>()._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

SchedProcessHangFtraceEvent::SchedProcessHangFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedProcessHangFtraceEvent)
}
SchedProcessHangFtraceEvent::SchedProcessHangFtraceEvent(const SchedProcessHangFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_comm()) {
    comm_.Set(from._internal_comm(), 
      GetArenaForAllocation());
  }
  pid_ = from.pid_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessHangFtraceEvent)
}

inline void SchedProcessHangFtraceEvent::SharedCtor() {
comm_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  comm_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
pid_ = 0;
}

SchedProcessHangFtraceEvent::~SchedProcessHangFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessHangFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedProcessHangFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  comm_.Destroy();
}

void SchedProcessHangFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SchedProcessHangFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessHangFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    comm_.ClearNonDefaultToEmpty();
  }
  pid_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedProcessHangFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedProcessHangFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedProcessHangFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_comm(), target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_pid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedProcessHangFtraceEvent)
  return target;
}

size_t SchedProcessHangFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessHangFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedProcessHangFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedProcessHangFtraceEvent*>(
      &from));
}

void SchedProcessHangFtraceEvent::MergeFrom(const SchedProcessHangFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessHangFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      pid_ = from.pid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedProcessHangFtraceEvent::CopyFrom(const SchedProcessHangFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessHangFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessHangFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessHangFtraceEvent::InternalSwap(SchedProcessHangFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &comm_, lhs_arena,
      &other->comm_, rhs_arena
  );
  swap(pid_, other->pid_);
}

std::string SchedProcessHangFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedProcessHangFtraceEvent";
}


// ===================================================================

class SchedProcessWaitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessWaitFtraceEvent>()._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SchedProcessWaitFtraceEvent::SchedProcessWaitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedProcessWaitFtraceEvent)
}
SchedProcessWaitFtraceEvent::SchedProcessWaitFtraceEvent(const SchedProcessWaitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_comm()) {
    comm_.Set(from._internal_comm(), 
      GetArenaForAllocation());
  }
  ::memcpy(&pid_, &from.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&prio_) -
    reinterpret_cast<char*>(&pid_)) + sizeof(prio_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessWaitFtraceEvent)
}

inline void SchedProcessWaitFtraceEvent::SharedCtor() {
comm_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  comm_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&pid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&prio_) -
    reinterpret_cast<char*>(&pid_)) + sizeof(prio_));
}

SchedProcessWaitFtraceEvent::~SchedProcessWaitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessWaitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedProcessWaitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  comm_.Destroy();
}

void SchedProcessWaitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SchedProcessWaitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessWaitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    comm_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&prio_) -
        reinterpret_cast<char*>(&pid_)) + sizeof(prio_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedProcessWaitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_prio(&has_bits);
          prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedProcessWaitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedProcessWaitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_comm(), target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_pid(), target);
  }

  // optional int32 prio = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_prio(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedProcessWaitFtraceEvent)
  return target;
}

size_t SchedProcessWaitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessWaitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

    // optional int32 prio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prio());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedProcessWaitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedProcessWaitFtraceEvent*>(
      &from));
}

void SchedProcessWaitFtraceEvent::MergeFrom(const SchedProcessWaitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessWaitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      pid_ = from.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      prio_ = from.prio_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedProcessWaitFtraceEvent::CopyFrom(const SchedProcessWaitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessWaitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessWaitFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessWaitFtraceEvent::InternalSwap(SchedProcessWaitFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &comm_, lhs_arena,
      &other->comm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedProcessWaitFtraceEvent, prio_)
      + sizeof(SchedProcessWaitFtraceEvent::prio_)
      - PROTOBUF_FIELD_OFFSET(SchedProcessWaitFtraceEvent, pid_)>(
          reinterpret_cast<char*>(&pid_),
          reinterpret_cast<char*>(&other->pid_));
}

std::string SchedProcessWaitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedProcessWaitFtraceEvent";
}


// ===================================================================

class SchedPiSetprioFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedPiSetprioFtraceEvent>()._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_newprio(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_oldprio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SchedPiSetprioFtraceEvent::SchedPiSetprioFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedPiSetprioFtraceEvent)
}
SchedPiSetprioFtraceEvent::SchedPiSetprioFtraceEvent(const SchedPiSetprioFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_comm()) {
    comm_.Set(from._internal_comm(), 
      GetArenaForAllocation());
  }
  ::memcpy(&newprio_, &from.newprio_,
    static_cast<size_t>(reinterpret_cast<char*>(&pid_) -
    reinterpret_cast<char*>(&newprio_)) + sizeof(pid_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedPiSetprioFtraceEvent)
}

inline void SchedPiSetprioFtraceEvent::SharedCtor() {
comm_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  comm_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&newprio_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&pid_) -
    reinterpret_cast<char*>(&newprio_)) + sizeof(pid_));
}

SchedPiSetprioFtraceEvent::~SchedPiSetprioFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedPiSetprioFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedPiSetprioFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  comm_.Destroy();
}

void SchedPiSetprioFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SchedPiSetprioFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedPiSetprioFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    comm_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&newprio_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pid_) -
        reinterpret_cast<char*>(&newprio_)) + sizeof(pid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedPiSetprioFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 newprio = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_newprio(&has_bits);
          newprio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 oldprio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_oldprio(&has_bits);
          oldprio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_pid(&has_bits);
          pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedPiSetprioFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedPiSetprioFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_comm(), target);
  }

  // optional int32 newprio = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_newprio(), target);
  }

  // optional int32 oldprio = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_oldprio(), target);
  }

  // optional int32 pid = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_pid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedPiSetprioFtraceEvent)
  return target;
}

size_t SchedPiSetprioFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedPiSetprioFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_comm());
    }

    // optional int32 newprio = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_newprio());
    }

    // optional int32 oldprio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_oldprio());
    }

    // optional int32 pid = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedPiSetprioFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedPiSetprioFtraceEvent*>(
      &from));
}

void SchedPiSetprioFtraceEvent::MergeFrom(const SchedPiSetprioFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedPiSetprioFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      newprio_ = from.newprio_;
    }
    if (cached_has_bits & 0x00000004u) {
      oldprio_ = from.oldprio_;
    }
    if (cached_has_bits & 0x00000008u) {
      pid_ = from.pid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedPiSetprioFtraceEvent::CopyFrom(const SchedPiSetprioFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedPiSetprioFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedPiSetprioFtraceEvent::IsInitialized() const {
  return true;
}

void SchedPiSetprioFtraceEvent::InternalSwap(SchedPiSetprioFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &comm_, lhs_arena,
      &other->comm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedPiSetprioFtraceEvent, pid_)
      + sizeof(SchedPiSetprioFtraceEvent::pid_)
      - PROTOBUF_FIELD_OFFSET(SchedPiSetprioFtraceEvent, newprio_)>(
          reinterpret_cast<char*>(&newprio_),
          reinterpret_cast<char*>(&other->newprio_));
}

std::string SchedPiSetprioFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedPiSetprioFtraceEvent";
}


// ===================================================================

class SchedCpuUtilCfsFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedCpuUtilCfsFtraceEvent>()._has_bits_);
  static void set_has_active(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_capacity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_capacity_orig(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_cpu_importance(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_cpu_util(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_exit_lat(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_group_capacity(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_grp_overutilized(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_idle_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_nr_running(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_spare_cap(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_task_fits(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_wake_group_util(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_wake_util(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

SchedCpuUtilCfsFtraceEvent::SchedCpuUtilCfsFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
}
SchedCpuUtilCfsFtraceEvent::SchedCpuUtilCfsFtraceEvent(const SchedCpuUtilCfsFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&capacity_, &from.capacity_,
    static_cast<size_t>(reinterpret_cast<char*>(&task_fits_) -
    reinterpret_cast<char*>(&capacity_)) + sizeof(task_fits_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
}

inline void SchedCpuUtilCfsFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&capacity_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&task_fits_) -
    reinterpret_cast<char*>(&capacity_)) + sizeof(task_fits_));
}

SchedCpuUtilCfsFtraceEvent::~SchedCpuUtilCfsFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedCpuUtilCfsFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SchedCpuUtilCfsFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SchedCpuUtilCfsFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&capacity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&exit_lat_) -
        reinterpret_cast<char*>(&capacity_)) + sizeof(exit_lat_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&grp_overutilized_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&task_fits_) -
        reinterpret_cast<char*>(&grp_overutilized_)) + sizeof(task_fits_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedCpuUtilCfsFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 active = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_active(&has_bits);
          active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 capacity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_capacity(&has_bits);
          capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 capacity_orig = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_capacity_orig(&has_bits);
          capacity_orig_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cpu = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_cpu(&has_bits);
          cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 cpu_importance = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_cpu_importance(&has_bits);
          cpu_importance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 cpu_util = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_cpu_util(&has_bits);
          cpu_util_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 exit_lat = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_exit_lat(&has_bits);
          exit_lat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 group_capacity = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_group_capacity(&has_bits);
          group_capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 grp_overutilized = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_grp_overutilized(&has_bits);
          grp_overutilized_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 idle_cpu = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_idle_cpu(&has_bits);
          idle_cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 nr_running = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_nr_running(&has_bits);
          nr_running_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 spare_cap = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_spare_cap(&has_bits);
          spare_cap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 task_fits = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_task_fits(&has_bits);
          task_fits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 wake_group_util = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_wake_group_util(&has_bits);
          wake_group_util_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 wake_util = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_wake_util(&has_bits);
          wake_util_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedCpuUtilCfsFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 active = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_active(), target);
  }

  // optional uint64 capacity = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_capacity(), target);
  }

  // optional uint64 capacity_orig = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_capacity_orig(), target);
  }

  // optional uint32 cpu = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_cpu(), target);
  }

  // optional uint64 cpu_importance = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_cpu_importance(), target);
  }

  // optional uint64 cpu_util = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_cpu_util(), target);
  }

  // optional uint32 exit_lat = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_exit_lat(), target);
  }

  // optional uint64 group_capacity = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_group_capacity(), target);
  }

  // optional uint32 grp_overutilized = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_grp_overutilized(), target);
  }

  // optional uint32 idle_cpu = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_idle_cpu(), target);
  }

  // optional uint32 nr_running = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_nr_running(), target);
  }

  // optional int64 spare_cap = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(12, this->_internal_spare_cap(), target);
  }

  // optional uint32 task_fits = 13;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_task_fits(), target);
  }

  // optional uint64 wake_group_util = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(14, this->_internal_wake_group_util(), target);
  }

  // optional uint64 wake_util = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(15, this->_internal_wake_util(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
  return target;
}

size_t SchedCpuUtilCfsFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 capacity = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_capacity());
    }

    // optional int32 active = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_active());
    }

    // optional uint32 cpu = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cpu());
    }

    // optional uint64 capacity_orig = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_capacity_orig());
    }

    // optional uint64 cpu_importance = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_cpu_importance());
    }

    // optional uint64 cpu_util = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_cpu_util());
    }

    // optional uint64 group_capacity = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_group_capacity());
    }

    // optional uint32 exit_lat = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_exit_lat());
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional uint32 grp_overutilized = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_grp_overutilized());
    }

    // optional uint32 idle_cpu = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_idle_cpu());
    }

    // optional uint32 nr_running = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nr_running());
    }

    // optional int64 spare_cap = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_spare_cap());
    }

    // optional uint64 wake_group_util = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_wake_group_util());
    }

    // optional uint64 wake_util = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_wake_util());
    }

    // optional uint32 task_fits = 13;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_task_fits());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedCpuUtilCfsFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedCpuUtilCfsFtraceEvent*>(
      &from));
}

void SchedCpuUtilCfsFtraceEvent::MergeFrom(const SchedCpuUtilCfsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      capacity_ = from.capacity_;
    }
    if (cached_has_bits & 0x00000002u) {
      active_ = from.active_;
    }
    if (cached_has_bits & 0x00000004u) {
      cpu_ = from.cpu_;
    }
    if (cached_has_bits & 0x00000008u) {
      capacity_orig_ = from.capacity_orig_;
    }
    if (cached_has_bits & 0x00000010u) {
      cpu_importance_ = from.cpu_importance_;
    }
    if (cached_has_bits & 0x00000020u) {
      cpu_util_ = from.cpu_util_;
    }
    if (cached_has_bits & 0x00000040u) {
      group_capacity_ = from.group_capacity_;
    }
    if (cached_has_bits & 0x00000080u) {
      exit_lat_ = from.exit_lat_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      grp_overutilized_ = from.grp_overutilized_;
    }
    if (cached_has_bits & 0x00000200u) {
      idle_cpu_ = from.idle_cpu_;
    }
    if (cached_has_bits & 0x00000400u) {
      nr_running_ = from.nr_running_;
    }
    if (cached_has_bits & 0x00000800u) {
      spare_cap_ = from.spare_cap_;
    }
    if (cached_has_bits & 0x00001000u) {
      wake_group_util_ = from.wake_group_util_;
    }
    if (cached_has_bits & 0x00002000u) {
      wake_util_ = from.wake_util_;
    }
    if (cached_has_bits & 0x00004000u) {
      task_fits_ = from.task_fits_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedCpuUtilCfsFtraceEvent::CopyFrom(const SchedCpuUtilCfsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedCpuUtilCfsFtraceEvent::IsInitialized() const {
  return true;
}

void SchedCpuUtilCfsFtraceEvent::InternalSwap(SchedCpuUtilCfsFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedCpuUtilCfsFtraceEvent, task_fits_)
      + sizeof(SchedCpuUtilCfsFtraceEvent::task_fits_)
      - PROTOBUF_FIELD_OFFSET(SchedCpuUtilCfsFtraceEvent, capacity_)>(
          reinterpret_cast<char*>(&capacity_),
          reinterpret_cast<char*>(&other->capacity_));
}

std::string SchedCpuUtilCfsFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedCpuUtilCfsFtraceEvent";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedSwitchFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedSwitchFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedSwitchFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedWakeupFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedWakeupFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedWakeupFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedBlockedReasonFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedBlockedReasonFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedBlockedReasonFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedCpuHotplugFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedCpuHotplugFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedCpuHotplugFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedWakingFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedWakingFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedWakingFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedWakeupNewFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedWakeupNewFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedWakeupNewFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessExecFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessExecFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedProcessExecFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedProcessExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessForkFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessForkFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedProcessForkFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessFreeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessFreeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedProcessFreeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessHangFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessHangFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedProcessHangFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessWaitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessWaitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedProcessWaitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedPiSetprioFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedPiSetprioFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedPiSetprioFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedCpuUtilCfsFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedCpuUtilCfsFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedCpuUtilCfsFtraceEvent >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
