// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/ftrace/f2fs.proto

#include "protos/perfetto/trace/ftrace/f2fs.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace perfetto {
namespace protos {
PROTOBUF_CONSTEXPR F2fsDoSubmitBioFtraceEvent::F2fsDoSubmitBioFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , btype_(0)
  , sync_(0u)
  , sector_(uint64_t{0u})
  , size_(0u){}
struct F2fsDoSubmitBioFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsDoSubmitBioFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsDoSubmitBioFtraceEventDefaultTypeInternal() {}
  union {
    F2fsDoSubmitBioFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsDoSubmitBioFtraceEventDefaultTypeInternal _F2fsDoSubmitBioFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsEvictInodeFtraceEvent::F2fsEvictInodeFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , pino_(uint64_t{0u})
  , size_(int64_t{0})
  , mode_(0u)
  , nlink_(0u)
  , blocks_(uint64_t{0u})
  , advise_(0u){}
struct F2fsEvictInodeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsEvictInodeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsEvictInodeFtraceEventDefaultTypeInternal() {}
  union {
    F2fsEvictInodeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsEvictInodeFtraceEventDefaultTypeInternal _F2fsEvictInodeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsFallocateFtraceEvent::F2fsFallocateFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , offset_(int64_t{0})
  , len_(int64_t{0})
  , mode_(0)
  , ret_(0)
  , size_(int64_t{0})
  , blocks_(uint64_t{0u}){}
struct F2fsFallocateFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsFallocateFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsFallocateFtraceEventDefaultTypeInternal() {}
  union {
    F2fsFallocateFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsFallocateFtraceEventDefaultTypeInternal _F2fsFallocateFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsGetDataBlockFtraceEvent::F2fsGetDataBlockFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , iblock_(uint64_t{0u})
  , bh_start_(uint64_t{0u})
  , bh_size_(uint64_t{0u})
  , ret_(0){}
struct F2fsGetDataBlockFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsGetDataBlockFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsGetDataBlockFtraceEventDefaultTypeInternal() {}
  union {
    F2fsGetDataBlockFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsGetDataBlockFtraceEventDefaultTypeInternal _F2fsGetDataBlockFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsGetVictimFtraceEvent::F2fsGetVictimFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , type_(0)
  , gc_type_(0)
  , alloc_mode_(0)
  , gc_mode_(0)
  , victim_(0u)
  , ofs_unit_(0u)
  , pre_victim_(0u)
  , prefree_(0u)
  , free_(0u)
  , cost_(0u){}
struct F2fsGetVictimFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsGetVictimFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsGetVictimFtraceEventDefaultTypeInternal() {}
  union {
    F2fsGetVictimFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsGetVictimFtraceEventDefaultTypeInternal _F2fsGetVictimFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsIgetFtraceEvent::F2fsIgetFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , pino_(uint64_t{0u})
  , size_(int64_t{0})
  , mode_(0u)
  , nlink_(0u)
  , blocks_(uint64_t{0u})
  , advise_(0u){}
struct F2fsIgetFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsIgetFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsIgetFtraceEventDefaultTypeInternal() {}
  union {
    F2fsIgetFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsIgetFtraceEventDefaultTypeInternal _F2fsIgetFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsIgetExitFtraceEvent::F2fsIgetExitFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , ret_(0){}
struct F2fsIgetExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsIgetExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsIgetExitFtraceEventDefaultTypeInternal() {}
  union {
    F2fsIgetExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsIgetExitFtraceEventDefaultTypeInternal _F2fsIgetExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsNewInodeFtraceEvent::F2fsNewInodeFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , ret_(0){}
struct F2fsNewInodeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsNewInodeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsNewInodeFtraceEventDefaultTypeInternal() {}
  union {
    F2fsNewInodeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsNewInodeFtraceEventDefaultTypeInternal _F2fsNewInodeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsReadpageFtraceEvent::F2fsReadpageFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , index_(uint64_t{0u})
  , blkaddr_(uint64_t{0u})
  , type_(0)
  , dir_(0)
  , dirty_(0)
  , uptodate_(0){}
struct F2fsReadpageFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsReadpageFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsReadpageFtraceEventDefaultTypeInternal() {}
  union {
    F2fsReadpageFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsReadpageFtraceEventDefaultTypeInternal _F2fsReadpageFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsReserveNewBlockFtraceEvent::F2fsReserveNewBlockFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , nid_(0u)
  , ofs_in_node_(0u){}
struct F2fsReserveNewBlockFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsReserveNewBlockFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsReserveNewBlockFtraceEventDefaultTypeInternal() {}
  union {
    F2fsReserveNewBlockFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsReserveNewBlockFtraceEventDefaultTypeInternal _F2fsReserveNewBlockFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsSetPageDirtyFtraceEvent::F2fsSetPageDirtyFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , type_(0)
  , dir_(0)
  , index_(uint64_t{0u})
  , dirty_(0)
  , uptodate_(0){}
struct F2fsSetPageDirtyFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsSetPageDirtyFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsSetPageDirtyFtraceEventDefaultTypeInternal() {}
  union {
    F2fsSetPageDirtyFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsSetPageDirtyFtraceEventDefaultTypeInternal _F2fsSetPageDirtyFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsSubmitWritePageFtraceEvent::F2fsSubmitWritePageFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , index_(uint64_t{0u})
  , type_(0)
  , block_(0u){}
struct F2fsSubmitWritePageFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsSubmitWritePageFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsSubmitWritePageFtraceEventDefaultTypeInternal() {}
  union {
    F2fsSubmitWritePageFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsSubmitWritePageFtraceEventDefaultTypeInternal _F2fsSubmitWritePageFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsSyncFileEnterFtraceEvent::F2fsSyncFileEnterFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , pino_(uint64_t{0u})
  , size_(int64_t{0})
  , mode_(0u)
  , nlink_(0u)
  , blocks_(uint64_t{0u})
  , advise_(0u){}
struct F2fsSyncFileEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsSyncFileEnterFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsSyncFileEnterFtraceEventDefaultTypeInternal() {}
  union {
    F2fsSyncFileEnterFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsSyncFileEnterFtraceEventDefaultTypeInternal _F2fsSyncFileEnterFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsSyncFileExitFtraceEvent::F2fsSyncFileExitFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , need_cp_(0u)
  , datasync_(0)
  , ret_(0)
  , cp_reason_(0){}
struct F2fsSyncFileExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsSyncFileExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsSyncFileExitFtraceEventDefaultTypeInternal() {}
  union {
    F2fsSyncFileExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsSyncFileExitFtraceEventDefaultTypeInternal _F2fsSyncFileExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsSyncFsFtraceEvent::F2fsSyncFsFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , dirty_(0)
  , wait_(0){}
struct F2fsSyncFsFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsSyncFsFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsSyncFsFtraceEventDefaultTypeInternal() {}
  union {
    F2fsSyncFsFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsSyncFsFtraceEventDefaultTypeInternal _F2fsSyncFsFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsTruncateFtraceEvent::F2fsTruncateFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , pino_(uint64_t{0u})
  , size_(int64_t{0})
  , mode_(0u)
  , nlink_(0u)
  , blocks_(uint64_t{0u})
  , advise_(0u){}
struct F2fsTruncateFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsTruncateFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsTruncateFtraceEventDefaultTypeInternal() {}
  union {
    F2fsTruncateFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsTruncateFtraceEventDefaultTypeInternal _F2fsTruncateFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsTruncateBlocksEnterFtraceEvent::F2fsTruncateBlocksEnterFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , size_(int64_t{0})
  , blocks_(uint64_t{0u})
  , from_(uint64_t{0u}){}
struct F2fsTruncateBlocksEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsTruncateBlocksEnterFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsTruncateBlocksEnterFtraceEventDefaultTypeInternal() {}
  union {
    F2fsTruncateBlocksEnterFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsTruncateBlocksEnterFtraceEventDefaultTypeInternal _F2fsTruncateBlocksEnterFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsTruncateBlocksExitFtraceEvent::F2fsTruncateBlocksExitFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , ret_(0){}
struct F2fsTruncateBlocksExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsTruncateBlocksExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsTruncateBlocksExitFtraceEventDefaultTypeInternal() {}
  union {
    F2fsTruncateBlocksExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsTruncateBlocksExitFtraceEventDefaultTypeInternal _F2fsTruncateBlocksExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsTruncateDataBlocksRangeFtraceEvent::F2fsTruncateDataBlocksRangeFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , nid_(0u)
  , ofs_(0u)
  , free_(0){}
struct F2fsTruncateDataBlocksRangeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsTruncateDataBlocksRangeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsTruncateDataBlocksRangeFtraceEventDefaultTypeInternal() {}
  union {
    F2fsTruncateDataBlocksRangeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsTruncateDataBlocksRangeFtraceEventDefaultTypeInternal _F2fsTruncateDataBlocksRangeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsTruncateInodeBlocksEnterFtraceEvent::F2fsTruncateInodeBlocksEnterFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , size_(int64_t{0})
  , blocks_(uint64_t{0u})
  , from_(uint64_t{0u}){}
struct F2fsTruncateInodeBlocksEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsTruncateInodeBlocksEnterFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsTruncateInodeBlocksEnterFtraceEventDefaultTypeInternal() {}
  union {
    F2fsTruncateInodeBlocksEnterFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsTruncateInodeBlocksEnterFtraceEventDefaultTypeInternal _F2fsTruncateInodeBlocksEnterFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsTruncateInodeBlocksExitFtraceEvent::F2fsTruncateInodeBlocksExitFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , ret_(0){}
struct F2fsTruncateInodeBlocksExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsTruncateInodeBlocksExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsTruncateInodeBlocksExitFtraceEventDefaultTypeInternal() {}
  union {
    F2fsTruncateInodeBlocksExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsTruncateInodeBlocksExitFtraceEventDefaultTypeInternal _F2fsTruncateInodeBlocksExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsTruncateNodeFtraceEvent::F2fsTruncateNodeFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , nid_(0u)
  , blk_addr_(0u){}
struct F2fsTruncateNodeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsTruncateNodeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsTruncateNodeFtraceEventDefaultTypeInternal() {}
  union {
    F2fsTruncateNodeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsTruncateNodeFtraceEventDefaultTypeInternal _F2fsTruncateNodeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsTruncateNodesEnterFtraceEvent::F2fsTruncateNodesEnterFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , nid_(0u)
  , blk_addr_(0u){}
struct F2fsTruncateNodesEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsTruncateNodesEnterFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsTruncateNodesEnterFtraceEventDefaultTypeInternal() {}
  union {
    F2fsTruncateNodesEnterFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsTruncateNodesEnterFtraceEventDefaultTypeInternal _F2fsTruncateNodesEnterFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsTruncateNodesExitFtraceEvent::F2fsTruncateNodesExitFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , ret_(0){}
struct F2fsTruncateNodesExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsTruncateNodesExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsTruncateNodesExitFtraceEventDefaultTypeInternal() {}
  union {
    F2fsTruncateNodesExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsTruncateNodesExitFtraceEventDefaultTypeInternal _F2fsTruncateNodesExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsTruncatePartialNodesFtraceEvent::F2fsTruncatePartialNodesFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , nid_(0u)
  , depth_(0)
  , err_(0){}
struct F2fsTruncatePartialNodesFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsTruncatePartialNodesFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsTruncatePartialNodesFtraceEventDefaultTypeInternal() {}
  union {
    F2fsTruncatePartialNodesFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsTruncatePartialNodesFtraceEventDefaultTypeInternal _F2fsTruncatePartialNodesFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsUnlinkEnterFtraceEvent::F2fsUnlinkEnterFtraceEvent(
    ::_pbi::ConstantInitialized)
  : name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , size_(int64_t{0})
  , blocks_(uint64_t{0u}){}
struct F2fsUnlinkEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsUnlinkEnterFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsUnlinkEnterFtraceEventDefaultTypeInternal() {}
  union {
    F2fsUnlinkEnterFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsUnlinkEnterFtraceEventDefaultTypeInternal _F2fsUnlinkEnterFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsUnlinkExitFtraceEvent::F2fsUnlinkExitFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , ret_(0){}
struct F2fsUnlinkExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsUnlinkExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsUnlinkExitFtraceEventDefaultTypeInternal() {}
  union {
    F2fsUnlinkExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsUnlinkExitFtraceEventDefaultTypeInternal _F2fsUnlinkExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsVmPageMkwriteFtraceEvent::F2fsVmPageMkwriteFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , type_(0)
  , dir_(0)
  , index_(uint64_t{0u})
  , dirty_(0)
  , uptodate_(0){}
struct F2fsVmPageMkwriteFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsVmPageMkwriteFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsVmPageMkwriteFtraceEventDefaultTypeInternal() {}
  union {
    F2fsVmPageMkwriteFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsVmPageMkwriteFtraceEventDefaultTypeInternal _F2fsVmPageMkwriteFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsWriteBeginFtraceEvent::F2fsWriteBeginFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , pos_(int64_t{0})
  , len_(0u)
  , flags_(0u){}
struct F2fsWriteBeginFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsWriteBeginFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsWriteBeginFtraceEventDefaultTypeInternal() {}
  union {
    F2fsWriteBeginFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsWriteBeginFtraceEventDefaultTypeInternal _F2fsWriteBeginFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsWriteCheckpointFtraceEvent::F2fsWriteCheckpointFtraceEvent(
    ::_pbi::ConstantInitialized)
  : msg_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , dev_(uint64_t{0u})
  , is_umount_(0u)
  , reason_(0){}
struct F2fsWriteCheckpointFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsWriteCheckpointFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsWriteCheckpointFtraceEventDefaultTypeInternal() {}
  union {
    F2fsWriteCheckpointFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsWriteCheckpointFtraceEventDefaultTypeInternal _F2fsWriteCheckpointFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsWriteEndFtraceEvent::F2fsWriteEndFtraceEvent(
    ::_pbi::ConstantInitialized)
  : dev_(uint64_t{0u})
  , ino_(uint64_t{0u})
  , pos_(int64_t{0})
  , len_(0u)
  , copied_(0u){}
struct F2fsWriteEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsWriteEndFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsWriteEndFtraceEventDefaultTypeInternal() {}
  union {
    F2fsWriteEndFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsWriteEndFtraceEventDefaultTypeInternal _F2fsWriteEndFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsIostatFtraceEvent::F2fsIostatFtraceEvent(
    ::_pbi::ConstantInitialized)
  : app_bio_(uint64_t{0u})
  , app_brio_(uint64_t{0u})
  , app_dio_(uint64_t{0u})
  , app_drio_(uint64_t{0u})
  , app_mio_(uint64_t{0u})
  , app_mrio_(uint64_t{0u})
  , app_rio_(uint64_t{0u})
  , app_wio_(uint64_t{0u})
  , dev_(uint64_t{0u})
  , fs_cdrio_(uint64_t{0u})
  , fs_cp_dio_(uint64_t{0u})
  , fs_cp_mio_(uint64_t{0u})
  , fs_cp_nio_(uint64_t{0u})
  , fs_dio_(uint64_t{0u})
  , fs_discard_(uint64_t{0u})
  , fs_drio_(uint64_t{0u})
  , fs_gc_dio_(uint64_t{0u})
  , fs_gc_nio_(uint64_t{0u})
  , fs_gdrio_(uint64_t{0u})
  , fs_mio_(uint64_t{0u})
  , fs_mrio_(uint64_t{0u})
  , fs_nio_(uint64_t{0u})
  , fs_nrio_(uint64_t{0u}){}
struct F2fsIostatFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsIostatFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsIostatFtraceEventDefaultTypeInternal() {}
  union {
    F2fsIostatFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsIostatFtraceEventDefaultTypeInternal _F2fsIostatFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsIostatLatencyFtraceEvent::F2fsIostatLatencyFtraceEvent(
    ::_pbi::ConstantInitialized)
  : d_rd_avg_(0u)
  , d_rd_cnt_(0u)
  , d_rd_peak_(0u)
  , d_wr_as_avg_(0u)
  , d_wr_as_cnt_(0u)
  , d_wr_as_peak_(0u)
  , d_wr_s_avg_(0u)
  , d_wr_s_cnt_(0u)
  , dev_(uint64_t{0u})
  , d_wr_s_peak_(0u)
  , m_rd_avg_(0u)
  , m_rd_cnt_(0u)
  , m_rd_peak_(0u)
  , m_wr_as_avg_(0u)
  , m_wr_as_cnt_(0u)
  , m_wr_as_peak_(0u)
  , m_wr_s_avg_(0u)
  , m_wr_s_cnt_(0u)
  , m_wr_s_peak_(0u)
  , n_rd_avg_(0u)
  , n_rd_cnt_(0u)
  , n_rd_peak_(0u)
  , n_wr_as_avg_(0u)
  , n_wr_as_cnt_(0u)
  , n_wr_as_peak_(0u)
  , n_wr_s_avg_(0u)
  , n_wr_s_cnt_(0u)
  , n_wr_s_peak_(0u){}
struct F2fsIostatLatencyFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsIostatLatencyFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsIostatLatencyFtraceEventDefaultTypeInternal() {}
  union {
    F2fsIostatLatencyFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsIostatLatencyFtraceEventDefaultTypeInternal _F2fsIostatLatencyFtraceEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
namespace perfetto {
namespace protos {

// ===================================================================

class F2fsDoSubmitBioFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsDoSubmitBioFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_btype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sync(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sector(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

F2fsDoSubmitBioFtraceEvent::F2fsDoSubmitBioFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsDoSubmitBioFtraceEvent)
}
F2fsDoSubmitBioFtraceEvent::F2fsDoSubmitBioFtraceEvent(const F2fsDoSubmitBioFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&size_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(size_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsDoSubmitBioFtraceEvent)
}

inline void F2fsDoSubmitBioFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&size_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(size_));
}

F2fsDoSubmitBioFtraceEvent::~F2fsDoSubmitBioFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsDoSubmitBioFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsDoSubmitBioFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsDoSubmitBioFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsDoSubmitBioFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsDoSubmitBioFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&size_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(size_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsDoSubmitBioFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 btype = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_btype(&has_bits);
          btype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sync = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_sync(&has_bits);
          sync_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 sector = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_sector(&has_bits);
          sector_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsDoSubmitBioFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsDoSubmitBioFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional int32 btype = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_btype(), target);
  }

  // optional uint32 sync = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_sync(), target);
  }

  // optional uint64 sector = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_sector(), target);
  }

  // optional uint32 size = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsDoSubmitBioFtraceEvent)
  return target;
}

size_t F2fsDoSubmitBioFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsDoSubmitBioFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional int32 btype = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_btype());
    }

    // optional uint32 sync = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sync());
    }

    // optional uint64 sector = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_sector());
    }

    // optional uint32 size = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_size());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsDoSubmitBioFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsDoSubmitBioFtraceEvent*>(
      &from));
}

void F2fsDoSubmitBioFtraceEvent::MergeFrom(const F2fsDoSubmitBioFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsDoSubmitBioFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      btype_ = from.btype_;
    }
    if (cached_has_bits & 0x00000004u) {
      sync_ = from.sync_;
    }
    if (cached_has_bits & 0x00000008u) {
      sector_ = from.sector_;
    }
    if (cached_has_bits & 0x00000010u) {
      size_ = from.size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsDoSubmitBioFtraceEvent::CopyFrom(const F2fsDoSubmitBioFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsDoSubmitBioFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsDoSubmitBioFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsDoSubmitBioFtraceEvent::InternalSwap(F2fsDoSubmitBioFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsDoSubmitBioFtraceEvent, size_)
      + sizeof(F2fsDoSubmitBioFtraceEvent::size_)
      - PROTOBUF_FIELD_OFFSET(F2fsDoSubmitBioFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsDoSubmitBioFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsDoSubmitBioFtraceEvent";
}


// ===================================================================

class F2fsEvictInodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsEvictInodeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pino(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nlink(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_advise(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

F2fsEvictInodeFtraceEvent::F2fsEvictInodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsEvictInodeFtraceEvent)
}
F2fsEvictInodeFtraceEvent::F2fsEvictInodeFtraceEvent(const F2fsEvictInodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&advise_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(advise_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsEvictInodeFtraceEvent)
}

inline void F2fsEvictInodeFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&advise_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(advise_));
}

F2fsEvictInodeFtraceEvent::~F2fsEvictInodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsEvictInodeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsEvictInodeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsEvictInodeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsEvictInodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsEvictInodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&advise_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(advise_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsEvictInodeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pino = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pino(&has_bits);
          pino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 nlink = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_nlink(&has_bits);
          nlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blocks = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_blocks(&has_bits);
          blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 advise = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_advise(&has_bits);
          advise_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsEvictInodeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsEvictInodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 pino = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_pino(), target);
  }

  // optional uint32 mode = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_mode(), target);
  }

  // optional int64 size = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_size(), target);
  }

  // optional uint32 nlink = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_nlink(), target);
  }

  // optional uint64 blocks = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_blocks(), target);
  }

  // optional uint32 advise = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_advise(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsEvictInodeFtraceEvent)
  return target;
}

size_t F2fsEvictInodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsEvictInodeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 pino = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pino());
    }

    // optional int64 size = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_size());
    }

    // optional uint32 mode = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
    }

    // optional uint32 nlink = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nlink());
    }

    // optional uint64 blocks = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_blocks());
    }

    // optional uint32 advise = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_advise());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsEvictInodeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsEvictInodeFtraceEvent*>(
      &from));
}

void F2fsEvictInodeFtraceEvent::MergeFrom(const F2fsEvictInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsEvictInodeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pino_ = from.pino_;
    }
    if (cached_has_bits & 0x00000008u) {
      size_ = from.size_;
    }
    if (cached_has_bits & 0x00000010u) {
      mode_ = from.mode_;
    }
    if (cached_has_bits & 0x00000020u) {
      nlink_ = from.nlink_;
    }
    if (cached_has_bits & 0x00000040u) {
      blocks_ = from.blocks_;
    }
    if (cached_has_bits & 0x00000080u) {
      advise_ = from.advise_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsEvictInodeFtraceEvent::CopyFrom(const F2fsEvictInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsEvictInodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsEvictInodeFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsEvictInodeFtraceEvent::InternalSwap(F2fsEvictInodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsEvictInodeFtraceEvent, advise_)
      + sizeof(F2fsEvictInodeFtraceEvent::advise_)
      - PROTOBUF_FIELD_OFFSET(F2fsEvictInodeFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsEvictInodeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsEvictInodeFtraceEvent";
}


// ===================================================================

class F2fsFallocateFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsFallocateFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

F2fsFallocateFtraceEvent::F2fsFallocateFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsFallocateFtraceEvent)
}
F2fsFallocateFtraceEvent::F2fsFallocateFtraceEvent(const F2fsFallocateFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&blocks_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsFallocateFtraceEvent)
}

inline void F2fsFallocateFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&blocks_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
}

F2fsFallocateFtraceEvent::~F2fsFallocateFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsFallocateFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsFallocateFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsFallocateFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsFallocateFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsFallocateFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&blocks_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsFallocateFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 offset = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 size = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blocks = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_blocks(&has_bits);
          blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsFallocateFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsFallocateFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 mode = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_mode(), target);
  }

  // optional int64 offset = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_offset(), target);
  }

  // optional int64 len = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_len(), target);
  }

  // optional int64 size = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_size(), target);
  }

  // optional uint64 blocks = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_blocks(), target);
  }

  // optional int32 ret = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsFallocateFtraceEvent)
  return target;
}

size_t F2fsFallocateFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsFallocateFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 offset = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_offset());
    }

    // optional int64 len = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_len());
    }

    // optional int32 mode = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mode());
    }

    // optional int32 ret = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

    // optional int64 size = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_size());
    }

    // optional uint64 blocks = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_blocks());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsFallocateFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsFallocateFtraceEvent*>(
      &from));
}

void F2fsFallocateFtraceEvent::MergeFrom(const F2fsFallocateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsFallocateFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      mode_ = from.mode_;
    }
    if (cached_has_bits & 0x00000020u) {
      ret_ = from.ret_;
    }
    if (cached_has_bits & 0x00000040u) {
      size_ = from.size_;
    }
    if (cached_has_bits & 0x00000080u) {
      blocks_ = from.blocks_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsFallocateFtraceEvent::CopyFrom(const F2fsFallocateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsFallocateFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsFallocateFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsFallocateFtraceEvent::InternalSwap(F2fsFallocateFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsFallocateFtraceEvent, blocks_)
      + sizeof(F2fsFallocateFtraceEvent::blocks_)
      - PROTOBUF_FIELD_OFFSET(F2fsFallocateFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsFallocateFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsFallocateFtraceEvent";
}


// ===================================================================

class F2fsGetDataBlockFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsGetDataBlockFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_iblock(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bh_start(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_bh_size(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

F2fsGetDataBlockFtraceEvent::F2fsGetDataBlockFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsGetDataBlockFtraceEvent)
}
F2fsGetDataBlockFtraceEvent::F2fsGetDataBlockFtraceEvent(const F2fsGetDataBlockFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsGetDataBlockFtraceEvent)
}

inline void F2fsGetDataBlockFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
}

F2fsGetDataBlockFtraceEvent::~F2fsGetDataBlockFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsGetDataBlockFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsGetDataBlockFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsGetDataBlockFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsGetDataBlockFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsGetDataBlockFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ret_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsGetDataBlockFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 iblock = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_iblock(&has_bits);
          iblock_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 bh_start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_bh_start(&has_bits);
          bh_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 bh_size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_bh_size(&has_bits);
          bh_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsGetDataBlockFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsGetDataBlockFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 iblock = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_iblock(), target);
  }

  // optional uint64 bh_start = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_bh_start(), target);
  }

  // optional uint64 bh_size = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_bh_size(), target);
  }

  // optional int32 ret = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsGetDataBlockFtraceEvent)
  return target;
}

size_t F2fsGetDataBlockFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsGetDataBlockFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 iblock = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_iblock());
    }

    // optional uint64 bh_start = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bh_start());
    }

    // optional uint64 bh_size = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bh_size());
    }

    // optional int32 ret = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsGetDataBlockFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsGetDataBlockFtraceEvent*>(
      &from));
}

void F2fsGetDataBlockFtraceEvent::MergeFrom(const F2fsGetDataBlockFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsGetDataBlockFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      iblock_ = from.iblock_;
    }
    if (cached_has_bits & 0x00000008u) {
      bh_start_ = from.bh_start_;
    }
    if (cached_has_bits & 0x00000010u) {
      bh_size_ = from.bh_size_;
    }
    if (cached_has_bits & 0x00000020u) {
      ret_ = from.ret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsGetDataBlockFtraceEvent::CopyFrom(const F2fsGetDataBlockFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsGetDataBlockFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsGetDataBlockFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsGetDataBlockFtraceEvent::InternalSwap(F2fsGetDataBlockFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsGetDataBlockFtraceEvent, ret_)
      + sizeof(F2fsGetDataBlockFtraceEvent::ret_)
      - PROTOBUF_FIELD_OFFSET(F2fsGetDataBlockFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsGetDataBlockFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsGetDataBlockFtraceEvent";
}


// ===================================================================

class F2fsGetVictimFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsGetVictimFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_gc_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_alloc_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gc_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_victim(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_ofs_unit(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_pre_victim(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_prefree(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_free(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

F2fsGetVictimFtraceEvent::F2fsGetVictimFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsGetVictimFtraceEvent)
}
F2fsGetVictimFtraceEvent::F2fsGetVictimFtraceEvent(const F2fsGetVictimFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&cost_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(cost_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsGetVictimFtraceEvent)
}

inline void F2fsGetVictimFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&cost_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(cost_));
}

F2fsGetVictimFtraceEvent::~F2fsGetVictimFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsGetVictimFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsGetVictimFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsGetVictimFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsGetVictimFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsGetVictimFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pre_victim_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(pre_victim_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&prefree_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cost_) -
        reinterpret_cast<char*>(&prefree_)) + sizeof(cost_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsGetVictimFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 gc_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_gc_type(&has_bits);
          gc_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 alloc_mode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_alloc_mode(&has_bits);
          alloc_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 gc_mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_gc_mode(&has_bits);
          gc_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 victim = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_victim(&has_bits);
          victim_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ofs_unit = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_ofs_unit(&has_bits);
          ofs_unit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pre_victim = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_pre_victim(&has_bits);
          pre_victim_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 prefree = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_prefree(&has_bits);
          prefree_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 free = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_free(&has_bits);
          free_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cost = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_cost(&has_bits);
          cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsGetVictimFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsGetVictimFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional int32 type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_type(), target);
  }

  // optional int32 gc_type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_gc_type(), target);
  }

  // optional int32 alloc_mode = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_alloc_mode(), target);
  }

  // optional int32 gc_mode = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_gc_mode(), target);
  }

  // optional uint32 victim = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_victim(), target);
  }

  // optional uint32 ofs_unit = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_ofs_unit(), target);
  }

  // optional uint32 pre_victim = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_pre_victim(), target);
  }

  // optional uint32 prefree = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_prefree(), target);
  }

  // optional uint32 free = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_free(), target);
  }

  // optional uint32 cost = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_cost(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsGetVictimFtraceEvent)
  return target;
}

size_t F2fsGetVictimFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsGetVictimFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional int32 type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
    }

    // optional int32 gc_type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_gc_type());
    }

    // optional int32 alloc_mode = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_alloc_mode());
    }

    // optional int32 gc_mode = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_gc_mode());
    }

    // optional uint32 victim = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_victim());
    }

    // optional uint32 ofs_unit = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ofs_unit());
    }

    // optional uint32 pre_victim = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pre_victim());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional uint32 prefree = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_prefree());
    }

    // optional uint32 free = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_free());
    }

    // optional uint32 cost = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cost());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsGetVictimFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsGetVictimFtraceEvent*>(
      &from));
}

void F2fsGetVictimFtraceEvent::MergeFrom(const F2fsGetVictimFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsGetVictimFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000004u) {
      gc_type_ = from.gc_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      alloc_mode_ = from.alloc_mode_;
    }
    if (cached_has_bits & 0x00000010u) {
      gc_mode_ = from.gc_mode_;
    }
    if (cached_has_bits & 0x00000020u) {
      victim_ = from.victim_;
    }
    if (cached_has_bits & 0x00000040u) {
      ofs_unit_ = from.ofs_unit_;
    }
    if (cached_has_bits & 0x00000080u) {
      pre_victim_ = from.pre_victim_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      prefree_ = from.prefree_;
    }
    if (cached_has_bits & 0x00000200u) {
      free_ = from.free_;
    }
    if (cached_has_bits & 0x00000400u) {
      cost_ = from.cost_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsGetVictimFtraceEvent::CopyFrom(const F2fsGetVictimFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsGetVictimFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsGetVictimFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsGetVictimFtraceEvent::InternalSwap(F2fsGetVictimFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsGetVictimFtraceEvent, cost_)
      + sizeof(F2fsGetVictimFtraceEvent::cost_)
      - PROTOBUF_FIELD_OFFSET(F2fsGetVictimFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsGetVictimFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsGetVictimFtraceEvent";
}


// ===================================================================

class F2fsIgetFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsIgetFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pino(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nlink(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_advise(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

F2fsIgetFtraceEvent::F2fsIgetFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsIgetFtraceEvent)
}
F2fsIgetFtraceEvent::F2fsIgetFtraceEvent(const F2fsIgetFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&advise_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(advise_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsIgetFtraceEvent)
}

inline void F2fsIgetFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&advise_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(advise_));
}

F2fsIgetFtraceEvent::~F2fsIgetFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsIgetFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsIgetFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsIgetFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsIgetFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsIgetFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&advise_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(advise_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsIgetFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pino = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pino(&has_bits);
          pino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 nlink = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_nlink(&has_bits);
          nlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blocks = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_blocks(&has_bits);
          blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 advise = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_advise(&has_bits);
          advise_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsIgetFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsIgetFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 pino = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_pino(), target);
  }

  // optional uint32 mode = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_mode(), target);
  }

  // optional int64 size = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_size(), target);
  }

  // optional uint32 nlink = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_nlink(), target);
  }

  // optional uint64 blocks = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_blocks(), target);
  }

  // optional uint32 advise = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_advise(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsIgetFtraceEvent)
  return target;
}

size_t F2fsIgetFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsIgetFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 pino = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pino());
    }

    // optional int64 size = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_size());
    }

    // optional uint32 mode = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
    }

    // optional uint32 nlink = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nlink());
    }

    // optional uint64 blocks = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_blocks());
    }

    // optional uint32 advise = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_advise());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsIgetFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsIgetFtraceEvent*>(
      &from));
}

void F2fsIgetFtraceEvent::MergeFrom(const F2fsIgetFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsIgetFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pino_ = from.pino_;
    }
    if (cached_has_bits & 0x00000008u) {
      size_ = from.size_;
    }
    if (cached_has_bits & 0x00000010u) {
      mode_ = from.mode_;
    }
    if (cached_has_bits & 0x00000020u) {
      nlink_ = from.nlink_;
    }
    if (cached_has_bits & 0x00000040u) {
      blocks_ = from.blocks_;
    }
    if (cached_has_bits & 0x00000080u) {
      advise_ = from.advise_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsIgetFtraceEvent::CopyFrom(const F2fsIgetFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsIgetFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsIgetFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsIgetFtraceEvent::InternalSwap(F2fsIgetFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsIgetFtraceEvent, advise_)
      + sizeof(F2fsIgetFtraceEvent::advise_)
      - PROTOBUF_FIELD_OFFSET(F2fsIgetFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsIgetFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsIgetFtraceEvent";
}


// ===================================================================

class F2fsIgetExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsIgetExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

F2fsIgetExitFtraceEvent::F2fsIgetExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsIgetExitFtraceEvent)
}
F2fsIgetExitFtraceEvent::F2fsIgetExitFtraceEvent(const F2fsIgetExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsIgetExitFtraceEvent)
}

inline void F2fsIgetExitFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
}

F2fsIgetExitFtraceEvent::~F2fsIgetExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsIgetExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsIgetExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsIgetExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsIgetExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsIgetExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ret_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsIgetExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsIgetExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsIgetExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 ret = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsIgetExitFtraceEvent)
  return target;
}

size_t F2fsIgetExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsIgetExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 ret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsIgetExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsIgetExitFtraceEvent*>(
      &from));
}

void F2fsIgetExitFtraceEvent::MergeFrom(const F2fsIgetExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsIgetExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      ret_ = from.ret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsIgetExitFtraceEvent::CopyFrom(const F2fsIgetExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsIgetExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsIgetExitFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsIgetExitFtraceEvent::InternalSwap(F2fsIgetExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsIgetExitFtraceEvent, ret_)
      + sizeof(F2fsIgetExitFtraceEvent::ret_)
      - PROTOBUF_FIELD_OFFSET(F2fsIgetExitFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsIgetExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsIgetExitFtraceEvent";
}


// ===================================================================

class F2fsNewInodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsNewInodeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

F2fsNewInodeFtraceEvent::F2fsNewInodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsNewInodeFtraceEvent)
}
F2fsNewInodeFtraceEvent::F2fsNewInodeFtraceEvent(const F2fsNewInodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsNewInodeFtraceEvent)
}

inline void F2fsNewInodeFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
}

F2fsNewInodeFtraceEvent::~F2fsNewInodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsNewInodeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsNewInodeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsNewInodeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsNewInodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsNewInodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ret_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsNewInodeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsNewInodeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsNewInodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 ret = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsNewInodeFtraceEvent)
  return target;
}

size_t F2fsNewInodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsNewInodeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 ret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsNewInodeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsNewInodeFtraceEvent*>(
      &from));
}

void F2fsNewInodeFtraceEvent::MergeFrom(const F2fsNewInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsNewInodeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      ret_ = from.ret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsNewInodeFtraceEvent::CopyFrom(const F2fsNewInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsNewInodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsNewInodeFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsNewInodeFtraceEvent::InternalSwap(F2fsNewInodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsNewInodeFtraceEvent, ret_)
      + sizeof(F2fsNewInodeFtraceEvent::ret_)
      - PROTOBUF_FIELD_OFFSET(F2fsNewInodeFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsNewInodeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsNewInodeFtraceEvent";
}


// ===================================================================

class F2fsReadpageFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsReadpageFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_blkaddr(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_dirty(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_uptodate(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

F2fsReadpageFtraceEvent::F2fsReadpageFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsReadpageFtraceEvent)
}
F2fsReadpageFtraceEvent::F2fsReadpageFtraceEvent(const F2fsReadpageFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&uptodate_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(uptodate_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsReadpageFtraceEvent)
}

inline void F2fsReadpageFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&uptodate_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(uptodate_));
}

F2fsReadpageFtraceEvent::~F2fsReadpageFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsReadpageFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsReadpageFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsReadpageFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsReadpageFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsReadpageFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&uptodate_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(uptodate_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsReadpageFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blkaddr = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_blkaddr(&has_bits);
          blkaddr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dir = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_dir(&has_bits);
          dir_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dirty = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_dirty(&has_bits);
          dirty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 uptodate = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_uptodate(&has_bits);
          uptodate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsReadpageFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsReadpageFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_index(), target);
  }

  // optional uint64 blkaddr = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_blkaddr(), target);
  }

  // optional int32 type = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_type(), target);
  }

  // optional int32 dir = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_dir(), target);
  }

  // optional int32 dirty = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_dirty(), target);
  }

  // optional int32 uptodate = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_uptodate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsReadpageFtraceEvent)
  return target;
}

size_t F2fsReadpageFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsReadpageFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_index());
    }

    // optional uint64 blkaddr = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_blkaddr());
    }

    // optional int32 type = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
    }

    // optional int32 dir = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dir());
    }

    // optional int32 dirty = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dirty());
    }

    // optional int32 uptodate = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_uptodate());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsReadpageFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsReadpageFtraceEvent*>(
      &from));
}

void F2fsReadpageFtraceEvent::MergeFrom(const F2fsReadpageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsReadpageFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      index_ = from.index_;
    }
    if (cached_has_bits & 0x00000008u) {
      blkaddr_ = from.blkaddr_;
    }
    if (cached_has_bits & 0x00000010u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000020u) {
      dir_ = from.dir_;
    }
    if (cached_has_bits & 0x00000040u) {
      dirty_ = from.dirty_;
    }
    if (cached_has_bits & 0x00000080u) {
      uptodate_ = from.uptodate_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsReadpageFtraceEvent::CopyFrom(const F2fsReadpageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsReadpageFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsReadpageFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsReadpageFtraceEvent::InternalSwap(F2fsReadpageFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsReadpageFtraceEvent, uptodate_)
      + sizeof(F2fsReadpageFtraceEvent::uptodate_)
      - PROTOBUF_FIELD_OFFSET(F2fsReadpageFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsReadpageFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsReadpageFtraceEvent";
}


// ===================================================================

class F2fsReserveNewBlockFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsReserveNewBlockFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ofs_in_node(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

F2fsReserveNewBlockFtraceEvent::F2fsReserveNewBlockFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsReserveNewBlockFtraceEvent)
}
F2fsReserveNewBlockFtraceEvent::F2fsReserveNewBlockFtraceEvent(const F2fsReserveNewBlockFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ofs_in_node_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ofs_in_node_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsReserveNewBlockFtraceEvent)
}

inline void F2fsReserveNewBlockFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ofs_in_node_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ofs_in_node_));
}

F2fsReserveNewBlockFtraceEvent::~F2fsReserveNewBlockFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsReserveNewBlockFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsReserveNewBlockFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsReserveNewBlockFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsReserveNewBlockFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsReserveNewBlockFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ofs_in_node_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ofs_in_node_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsReserveNewBlockFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 nid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_nid(&has_bits);
          nid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ofs_in_node = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ofs_in_node(&has_bits);
          ofs_in_node_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsReserveNewBlockFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsReserveNewBlockFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint32 nid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_nid(), target);
  }

  // optional uint32 ofs_in_node = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_ofs_in_node(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsReserveNewBlockFtraceEvent)
  return target;
}

size_t F2fsReserveNewBlockFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsReserveNewBlockFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint32 nid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nid());
    }

    // optional uint32 ofs_in_node = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ofs_in_node());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsReserveNewBlockFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsReserveNewBlockFtraceEvent*>(
      &from));
}

void F2fsReserveNewBlockFtraceEvent::MergeFrom(const F2fsReserveNewBlockFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsReserveNewBlockFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      nid_ = from.nid_;
    }
    if (cached_has_bits & 0x00000004u) {
      ofs_in_node_ = from.ofs_in_node_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsReserveNewBlockFtraceEvent::CopyFrom(const F2fsReserveNewBlockFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsReserveNewBlockFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsReserveNewBlockFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsReserveNewBlockFtraceEvent::InternalSwap(F2fsReserveNewBlockFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsReserveNewBlockFtraceEvent, ofs_in_node_)
      + sizeof(F2fsReserveNewBlockFtraceEvent::ofs_in_node_)
      - PROTOBUF_FIELD_OFFSET(F2fsReserveNewBlockFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsReserveNewBlockFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsReserveNewBlockFtraceEvent";
}


// ===================================================================

class F2fsSetPageDirtyFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsSetPageDirtyFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_dirty(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_uptodate(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

F2fsSetPageDirtyFtraceEvent::F2fsSetPageDirtyFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsSetPageDirtyFtraceEvent)
}
F2fsSetPageDirtyFtraceEvent::F2fsSetPageDirtyFtraceEvent(const F2fsSetPageDirtyFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&uptodate_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(uptodate_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsSetPageDirtyFtraceEvent)
}

inline void F2fsSetPageDirtyFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&uptodate_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(uptodate_));
}

F2fsSetPageDirtyFtraceEvent::~F2fsSetPageDirtyFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsSetPageDirtyFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsSetPageDirtyFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsSetPageDirtyFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsSetPageDirtyFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsSetPageDirtyFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&uptodate_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(uptodate_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsSetPageDirtyFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dir = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_dir(&has_bits);
          dir_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 index = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dirty = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_dirty(&has_bits);
          dirty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 uptodate = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_uptodate(&has_bits);
          uptodate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsSetPageDirtyFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsSetPageDirtyFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_type(), target);
  }

  // optional int32 dir = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_dir(), target);
  }

  // optional uint64 index = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_index(), target);
  }

  // optional int32 dirty = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_dirty(), target);
  }

  // optional int32 uptodate = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_uptodate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsSetPageDirtyFtraceEvent)
  return target;
}

size_t F2fsSetPageDirtyFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsSetPageDirtyFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
    }

    // optional int32 dir = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dir());
    }

    // optional uint64 index = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_index());
    }

    // optional int32 dirty = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dirty());
    }

    // optional int32 uptodate = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_uptodate());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsSetPageDirtyFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsSetPageDirtyFtraceEvent*>(
      &from));
}

void F2fsSetPageDirtyFtraceEvent::MergeFrom(const F2fsSetPageDirtyFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsSetPageDirtyFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      dir_ = from.dir_;
    }
    if (cached_has_bits & 0x00000010u) {
      index_ = from.index_;
    }
    if (cached_has_bits & 0x00000020u) {
      dirty_ = from.dirty_;
    }
    if (cached_has_bits & 0x00000040u) {
      uptodate_ = from.uptodate_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsSetPageDirtyFtraceEvent::CopyFrom(const F2fsSetPageDirtyFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsSetPageDirtyFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsSetPageDirtyFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsSetPageDirtyFtraceEvent::InternalSwap(F2fsSetPageDirtyFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsSetPageDirtyFtraceEvent, uptodate_)
      + sizeof(F2fsSetPageDirtyFtraceEvent::uptodate_)
      - PROTOBUF_FIELD_OFFSET(F2fsSetPageDirtyFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsSetPageDirtyFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsSetPageDirtyFtraceEvent";
}


// ===================================================================

class F2fsSubmitWritePageFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsSubmitWritePageFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_block(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

F2fsSubmitWritePageFtraceEvent::F2fsSubmitWritePageFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsSubmitWritePageFtraceEvent)
}
F2fsSubmitWritePageFtraceEvent::F2fsSubmitWritePageFtraceEvent(const F2fsSubmitWritePageFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&block_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(block_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsSubmitWritePageFtraceEvent)
}

inline void F2fsSubmitWritePageFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&block_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(block_));
}

F2fsSubmitWritePageFtraceEvent::~F2fsSubmitWritePageFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsSubmitWritePageFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsSubmitWritePageFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsSubmitWritePageFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsSubmitWritePageFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsSubmitWritePageFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&block_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(block_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsSubmitWritePageFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 block = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_block(&has_bits);
          block_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsSubmitWritePageFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsSubmitWritePageFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 type = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_type(), target);
  }

  // optional uint64 index = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_index(), target);
  }

  // optional uint32 block = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_block(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsSubmitWritePageFtraceEvent)
  return target;
}

size_t F2fsSubmitWritePageFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsSubmitWritePageFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 index = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_index());
    }

    // optional int32 type = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
    }

    // optional uint32 block = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_block());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsSubmitWritePageFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsSubmitWritePageFtraceEvent*>(
      &from));
}

void F2fsSubmitWritePageFtraceEvent::MergeFrom(const F2fsSubmitWritePageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsSubmitWritePageFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      index_ = from.index_;
    }
    if (cached_has_bits & 0x00000008u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000010u) {
      block_ = from.block_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsSubmitWritePageFtraceEvent::CopyFrom(const F2fsSubmitWritePageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsSubmitWritePageFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsSubmitWritePageFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsSubmitWritePageFtraceEvent::InternalSwap(F2fsSubmitWritePageFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsSubmitWritePageFtraceEvent, block_)
      + sizeof(F2fsSubmitWritePageFtraceEvent::block_)
      - PROTOBUF_FIELD_OFFSET(F2fsSubmitWritePageFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsSubmitWritePageFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsSubmitWritePageFtraceEvent";
}


// ===================================================================

class F2fsSyncFileEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsSyncFileEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pino(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nlink(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_advise(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

F2fsSyncFileEnterFtraceEvent::F2fsSyncFileEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsSyncFileEnterFtraceEvent)
}
F2fsSyncFileEnterFtraceEvent::F2fsSyncFileEnterFtraceEvent(const F2fsSyncFileEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&advise_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(advise_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsSyncFileEnterFtraceEvent)
}

inline void F2fsSyncFileEnterFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&advise_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(advise_));
}

F2fsSyncFileEnterFtraceEvent::~F2fsSyncFileEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsSyncFileEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsSyncFileEnterFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsSyncFileEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsSyncFileEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsSyncFileEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&advise_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(advise_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsSyncFileEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pino = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pino(&has_bits);
          pino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 nlink = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_nlink(&has_bits);
          nlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blocks = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_blocks(&has_bits);
          blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 advise = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_advise(&has_bits);
          advise_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsSyncFileEnterFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsSyncFileEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 pino = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_pino(), target);
  }

  // optional uint32 mode = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_mode(), target);
  }

  // optional int64 size = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_size(), target);
  }

  // optional uint32 nlink = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_nlink(), target);
  }

  // optional uint64 blocks = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_blocks(), target);
  }

  // optional uint32 advise = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_advise(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsSyncFileEnterFtraceEvent)
  return target;
}

size_t F2fsSyncFileEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsSyncFileEnterFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 pino = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pino());
    }

    // optional int64 size = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_size());
    }

    // optional uint32 mode = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
    }

    // optional uint32 nlink = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nlink());
    }

    // optional uint64 blocks = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_blocks());
    }

    // optional uint32 advise = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_advise());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsSyncFileEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsSyncFileEnterFtraceEvent*>(
      &from));
}

void F2fsSyncFileEnterFtraceEvent::MergeFrom(const F2fsSyncFileEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsSyncFileEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pino_ = from.pino_;
    }
    if (cached_has_bits & 0x00000008u) {
      size_ = from.size_;
    }
    if (cached_has_bits & 0x00000010u) {
      mode_ = from.mode_;
    }
    if (cached_has_bits & 0x00000020u) {
      nlink_ = from.nlink_;
    }
    if (cached_has_bits & 0x00000040u) {
      blocks_ = from.blocks_;
    }
    if (cached_has_bits & 0x00000080u) {
      advise_ = from.advise_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsSyncFileEnterFtraceEvent::CopyFrom(const F2fsSyncFileEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsSyncFileEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsSyncFileEnterFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsSyncFileEnterFtraceEvent::InternalSwap(F2fsSyncFileEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsSyncFileEnterFtraceEvent, advise_)
      + sizeof(F2fsSyncFileEnterFtraceEvent::advise_)
      - PROTOBUF_FIELD_OFFSET(F2fsSyncFileEnterFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsSyncFileEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsSyncFileEnterFtraceEvent";
}


// ===================================================================

class F2fsSyncFileExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsSyncFileExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_need_cp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_datasync(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_cp_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

F2fsSyncFileExitFtraceEvent::F2fsSyncFileExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsSyncFileExitFtraceEvent)
}
F2fsSyncFileExitFtraceEvent::F2fsSyncFileExitFtraceEvent(const F2fsSyncFileExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&cp_reason_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(cp_reason_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsSyncFileExitFtraceEvent)
}

inline void F2fsSyncFileExitFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&cp_reason_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(cp_reason_));
}

F2fsSyncFileExitFtraceEvent::~F2fsSyncFileExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsSyncFileExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsSyncFileExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsSyncFileExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsSyncFileExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsSyncFileExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cp_reason_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(cp_reason_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsSyncFileExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 need_cp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_need_cp(&has_bits);
          need_cp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 datasync = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_datasync(&has_bits);
          datasync_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 cp_reason = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_cp_reason(&has_bits);
          cp_reason_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsSyncFileExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsSyncFileExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 need_cp = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_need_cp(), target);
  }

  // optional int32 datasync = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_datasync(), target);
  }

  // optional int32 ret = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_ret(), target);
  }

  // optional int32 cp_reason = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_cp_reason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsSyncFileExitFtraceEvent)
  return target;
}

size_t F2fsSyncFileExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsSyncFileExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 need_cp = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_need_cp());
    }

    // optional int32 datasync = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_datasync());
    }

    // optional int32 ret = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

    // optional int32 cp_reason = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cp_reason());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsSyncFileExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsSyncFileExitFtraceEvent*>(
      &from));
}

void F2fsSyncFileExitFtraceEvent::MergeFrom(const F2fsSyncFileExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsSyncFileExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      need_cp_ = from.need_cp_;
    }
    if (cached_has_bits & 0x00000008u) {
      datasync_ = from.datasync_;
    }
    if (cached_has_bits & 0x00000010u) {
      ret_ = from.ret_;
    }
    if (cached_has_bits & 0x00000020u) {
      cp_reason_ = from.cp_reason_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsSyncFileExitFtraceEvent::CopyFrom(const F2fsSyncFileExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsSyncFileExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsSyncFileExitFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsSyncFileExitFtraceEvent::InternalSwap(F2fsSyncFileExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsSyncFileExitFtraceEvent, cp_reason_)
      + sizeof(F2fsSyncFileExitFtraceEvent::cp_reason_)
      - PROTOBUF_FIELD_OFFSET(F2fsSyncFileExitFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsSyncFileExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsSyncFileExitFtraceEvent";
}


// ===================================================================

class F2fsSyncFsFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsSyncFsFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dirty(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_wait(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

F2fsSyncFsFtraceEvent::F2fsSyncFsFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsSyncFsFtraceEvent)
}
F2fsSyncFsFtraceEvent::F2fsSyncFsFtraceEvent(const F2fsSyncFsFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&wait_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(wait_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsSyncFsFtraceEvent)
}

inline void F2fsSyncFsFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&wait_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(wait_));
}

F2fsSyncFsFtraceEvent::~F2fsSyncFsFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsSyncFsFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsSyncFsFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsSyncFsFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsSyncFsFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsSyncFsFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&wait_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(wait_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsSyncFsFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dirty = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_dirty(&has_bits);
          dirty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 wait = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_wait(&has_bits);
          wait_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsSyncFsFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsSyncFsFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional int32 dirty = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_dirty(), target);
  }

  // optional int32 wait = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_wait(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsSyncFsFtraceEvent)
  return target;
}

size_t F2fsSyncFsFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsSyncFsFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional int32 dirty = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dirty());
    }

    // optional int32 wait = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_wait());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsSyncFsFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsSyncFsFtraceEvent*>(
      &from));
}

void F2fsSyncFsFtraceEvent::MergeFrom(const F2fsSyncFsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsSyncFsFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      dirty_ = from.dirty_;
    }
    if (cached_has_bits & 0x00000004u) {
      wait_ = from.wait_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsSyncFsFtraceEvent::CopyFrom(const F2fsSyncFsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsSyncFsFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsSyncFsFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsSyncFsFtraceEvent::InternalSwap(F2fsSyncFsFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsSyncFsFtraceEvent, wait_)
      + sizeof(F2fsSyncFsFtraceEvent::wait_)
      - PROTOBUF_FIELD_OFFSET(F2fsSyncFsFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsSyncFsFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsSyncFsFtraceEvent";
}


// ===================================================================

class F2fsTruncateFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsTruncateFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pino(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nlink(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_advise(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

F2fsTruncateFtraceEvent::F2fsTruncateFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsTruncateFtraceEvent)
}
F2fsTruncateFtraceEvent::F2fsTruncateFtraceEvent(const F2fsTruncateFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&advise_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(advise_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsTruncateFtraceEvent)
}

inline void F2fsTruncateFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&advise_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(advise_));
}

F2fsTruncateFtraceEvent::~F2fsTruncateFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsTruncateFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsTruncateFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsTruncateFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsTruncateFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsTruncateFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&advise_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(advise_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsTruncateFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pino = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pino(&has_bits);
          pino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_mode(&has_bits);
          mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 nlink = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_nlink(&has_bits);
          nlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blocks = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_blocks(&has_bits);
          blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 advise = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_advise(&has_bits);
          advise_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsTruncateFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsTruncateFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 pino = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_pino(), target);
  }

  // optional uint32 mode = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_mode(), target);
  }

  // optional int64 size = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_size(), target);
  }

  // optional uint32 nlink = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_nlink(), target);
  }

  // optional uint64 blocks = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_blocks(), target);
  }

  // optional uint32 advise = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_advise(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsTruncateFtraceEvent)
  return target;
}

size_t F2fsTruncateFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsTruncateFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 pino = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pino());
    }

    // optional int64 size = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_size());
    }

    // optional uint32 mode = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
    }

    // optional uint32 nlink = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nlink());
    }

    // optional uint64 blocks = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_blocks());
    }

    // optional uint32 advise = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_advise());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsTruncateFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsTruncateFtraceEvent*>(
      &from));
}

void F2fsTruncateFtraceEvent::MergeFrom(const F2fsTruncateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsTruncateFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pino_ = from.pino_;
    }
    if (cached_has_bits & 0x00000008u) {
      size_ = from.size_;
    }
    if (cached_has_bits & 0x00000010u) {
      mode_ = from.mode_;
    }
    if (cached_has_bits & 0x00000020u) {
      nlink_ = from.nlink_;
    }
    if (cached_has_bits & 0x00000040u) {
      blocks_ = from.blocks_;
    }
    if (cached_has_bits & 0x00000080u) {
      advise_ = from.advise_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsTruncateFtraceEvent::CopyFrom(const F2fsTruncateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsTruncateFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsTruncateFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsTruncateFtraceEvent::InternalSwap(F2fsTruncateFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsTruncateFtraceEvent, advise_)
      + sizeof(F2fsTruncateFtraceEvent::advise_)
      - PROTOBUF_FIELD_OFFSET(F2fsTruncateFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsTruncateFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsTruncateFtraceEvent";
}


// ===================================================================

class F2fsTruncateBlocksEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsTruncateBlocksEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_from(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

F2fsTruncateBlocksEnterFtraceEvent::F2fsTruncateBlocksEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsTruncateBlocksEnterFtraceEvent)
}
F2fsTruncateBlocksEnterFtraceEvent::F2fsTruncateBlocksEnterFtraceEvent(const F2fsTruncateBlocksEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&from_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(from_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsTruncateBlocksEnterFtraceEvent)
}

inline void F2fsTruncateBlocksEnterFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&from_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(from_));
}

F2fsTruncateBlocksEnterFtraceEvent::~F2fsTruncateBlocksEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsTruncateBlocksEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsTruncateBlocksEnterFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsTruncateBlocksEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsTruncateBlocksEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsTruncateBlocksEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&from_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(from_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsTruncateBlocksEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_blocks(&has_bits);
          blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 from = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_from(&has_bits);
          from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsTruncateBlocksEnterFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsTruncateBlocksEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 size = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_size(), target);
  }

  // optional uint64 blocks = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_blocks(), target);
  }

  // optional uint64 from = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_from(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsTruncateBlocksEnterFtraceEvent)
  return target;
}

size_t F2fsTruncateBlocksEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsTruncateBlocksEnterFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 size = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_size());
    }

    // optional uint64 blocks = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_blocks());
    }

    // optional uint64 from = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_from());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsTruncateBlocksEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsTruncateBlocksEnterFtraceEvent*>(
      &from));
}

void F2fsTruncateBlocksEnterFtraceEvent::MergeFrom(const F2fsTruncateBlocksEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsTruncateBlocksEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      size_ = from.size_;
    }
    if (cached_has_bits & 0x00000008u) {
      blocks_ = from.blocks_;
    }
    if (cached_has_bits & 0x00000010u) {
      from_ = from.from_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsTruncateBlocksEnterFtraceEvent::CopyFrom(const F2fsTruncateBlocksEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsTruncateBlocksEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsTruncateBlocksEnterFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsTruncateBlocksEnterFtraceEvent::InternalSwap(F2fsTruncateBlocksEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsTruncateBlocksEnterFtraceEvent, from_)
      + sizeof(F2fsTruncateBlocksEnterFtraceEvent::from_)
      - PROTOBUF_FIELD_OFFSET(F2fsTruncateBlocksEnterFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsTruncateBlocksEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsTruncateBlocksEnterFtraceEvent";
}


// ===================================================================

class F2fsTruncateBlocksExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsTruncateBlocksExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

F2fsTruncateBlocksExitFtraceEvent::F2fsTruncateBlocksExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsTruncateBlocksExitFtraceEvent)
}
F2fsTruncateBlocksExitFtraceEvent::F2fsTruncateBlocksExitFtraceEvent(const F2fsTruncateBlocksExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsTruncateBlocksExitFtraceEvent)
}

inline void F2fsTruncateBlocksExitFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
}

F2fsTruncateBlocksExitFtraceEvent::~F2fsTruncateBlocksExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsTruncateBlocksExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsTruncateBlocksExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsTruncateBlocksExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsTruncateBlocksExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsTruncateBlocksExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ret_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsTruncateBlocksExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsTruncateBlocksExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsTruncateBlocksExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 ret = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsTruncateBlocksExitFtraceEvent)
  return target;
}

size_t F2fsTruncateBlocksExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsTruncateBlocksExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 ret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsTruncateBlocksExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsTruncateBlocksExitFtraceEvent*>(
      &from));
}

void F2fsTruncateBlocksExitFtraceEvent::MergeFrom(const F2fsTruncateBlocksExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsTruncateBlocksExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      ret_ = from.ret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsTruncateBlocksExitFtraceEvent::CopyFrom(const F2fsTruncateBlocksExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsTruncateBlocksExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsTruncateBlocksExitFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsTruncateBlocksExitFtraceEvent::InternalSwap(F2fsTruncateBlocksExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsTruncateBlocksExitFtraceEvent, ret_)
      + sizeof(F2fsTruncateBlocksExitFtraceEvent::ret_)
      - PROTOBUF_FIELD_OFFSET(F2fsTruncateBlocksExitFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsTruncateBlocksExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsTruncateBlocksExitFtraceEvent";
}


// ===================================================================

class F2fsTruncateDataBlocksRangeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsTruncateDataBlocksRangeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ofs(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_free(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

F2fsTruncateDataBlocksRangeFtraceEvent::F2fsTruncateDataBlocksRangeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsTruncateDataBlocksRangeFtraceEvent)
}
F2fsTruncateDataBlocksRangeFtraceEvent::F2fsTruncateDataBlocksRangeFtraceEvent(const F2fsTruncateDataBlocksRangeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&free_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(free_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsTruncateDataBlocksRangeFtraceEvent)
}

inline void F2fsTruncateDataBlocksRangeFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&free_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(free_));
}

F2fsTruncateDataBlocksRangeFtraceEvent::~F2fsTruncateDataBlocksRangeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsTruncateDataBlocksRangeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsTruncateDataBlocksRangeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsTruncateDataBlocksRangeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsTruncateDataBlocksRangeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsTruncateDataBlocksRangeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&free_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(free_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsTruncateDataBlocksRangeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 nid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_nid(&has_bits);
          nid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ofs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_ofs(&has_bits);
          ofs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 free = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_free(&has_bits);
          free_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsTruncateDataBlocksRangeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsTruncateDataBlocksRangeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 nid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_nid(), target);
  }

  // optional uint32 ofs = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_ofs(), target);
  }

  // optional int32 free = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_free(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsTruncateDataBlocksRangeFtraceEvent)
  return target;
}

size_t F2fsTruncateDataBlocksRangeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsTruncateDataBlocksRangeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 nid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nid());
    }

    // optional uint32 ofs = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ofs());
    }

    // optional int32 free = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_free());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsTruncateDataBlocksRangeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsTruncateDataBlocksRangeFtraceEvent*>(
      &from));
}

void F2fsTruncateDataBlocksRangeFtraceEvent::MergeFrom(const F2fsTruncateDataBlocksRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsTruncateDataBlocksRangeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      nid_ = from.nid_;
    }
    if (cached_has_bits & 0x00000008u) {
      ofs_ = from.ofs_;
    }
    if (cached_has_bits & 0x00000010u) {
      free_ = from.free_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsTruncateDataBlocksRangeFtraceEvent::CopyFrom(const F2fsTruncateDataBlocksRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsTruncateDataBlocksRangeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsTruncateDataBlocksRangeFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsTruncateDataBlocksRangeFtraceEvent::InternalSwap(F2fsTruncateDataBlocksRangeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsTruncateDataBlocksRangeFtraceEvent, free_)
      + sizeof(F2fsTruncateDataBlocksRangeFtraceEvent::free_)
      - PROTOBUF_FIELD_OFFSET(F2fsTruncateDataBlocksRangeFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsTruncateDataBlocksRangeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsTruncateDataBlocksRangeFtraceEvent";
}


// ===================================================================

class F2fsTruncateInodeBlocksEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsTruncateInodeBlocksEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_from(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

F2fsTruncateInodeBlocksEnterFtraceEvent::F2fsTruncateInodeBlocksEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsTruncateInodeBlocksEnterFtraceEvent)
}
F2fsTruncateInodeBlocksEnterFtraceEvent::F2fsTruncateInodeBlocksEnterFtraceEvent(const F2fsTruncateInodeBlocksEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&from_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(from_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsTruncateInodeBlocksEnterFtraceEvent)
}

inline void F2fsTruncateInodeBlocksEnterFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&from_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(from_));
}

F2fsTruncateInodeBlocksEnterFtraceEvent::~F2fsTruncateInodeBlocksEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsTruncateInodeBlocksEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsTruncateInodeBlocksEnterFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsTruncateInodeBlocksEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsTruncateInodeBlocksEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsTruncateInodeBlocksEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&from_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(from_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsTruncateInodeBlocksEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_blocks(&has_bits);
          blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 from = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_from(&has_bits);
          from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsTruncateInodeBlocksEnterFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsTruncateInodeBlocksEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 size = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_size(), target);
  }

  // optional uint64 blocks = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_blocks(), target);
  }

  // optional uint64 from = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_from(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsTruncateInodeBlocksEnterFtraceEvent)
  return target;
}

size_t F2fsTruncateInodeBlocksEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsTruncateInodeBlocksEnterFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 size = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_size());
    }

    // optional uint64 blocks = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_blocks());
    }

    // optional uint64 from = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_from());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsTruncateInodeBlocksEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsTruncateInodeBlocksEnterFtraceEvent*>(
      &from));
}

void F2fsTruncateInodeBlocksEnterFtraceEvent::MergeFrom(const F2fsTruncateInodeBlocksEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsTruncateInodeBlocksEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      size_ = from.size_;
    }
    if (cached_has_bits & 0x00000008u) {
      blocks_ = from.blocks_;
    }
    if (cached_has_bits & 0x00000010u) {
      from_ = from.from_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsTruncateInodeBlocksEnterFtraceEvent::CopyFrom(const F2fsTruncateInodeBlocksEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsTruncateInodeBlocksEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsTruncateInodeBlocksEnterFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsTruncateInodeBlocksEnterFtraceEvent::InternalSwap(F2fsTruncateInodeBlocksEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsTruncateInodeBlocksEnterFtraceEvent, from_)
      + sizeof(F2fsTruncateInodeBlocksEnterFtraceEvent::from_)
      - PROTOBUF_FIELD_OFFSET(F2fsTruncateInodeBlocksEnterFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsTruncateInodeBlocksEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsTruncateInodeBlocksEnterFtraceEvent";
}


// ===================================================================

class F2fsTruncateInodeBlocksExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsTruncateInodeBlocksExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

F2fsTruncateInodeBlocksExitFtraceEvent::F2fsTruncateInodeBlocksExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsTruncateInodeBlocksExitFtraceEvent)
}
F2fsTruncateInodeBlocksExitFtraceEvent::F2fsTruncateInodeBlocksExitFtraceEvent(const F2fsTruncateInodeBlocksExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsTruncateInodeBlocksExitFtraceEvent)
}

inline void F2fsTruncateInodeBlocksExitFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
}

F2fsTruncateInodeBlocksExitFtraceEvent::~F2fsTruncateInodeBlocksExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsTruncateInodeBlocksExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsTruncateInodeBlocksExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsTruncateInodeBlocksExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsTruncateInodeBlocksExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsTruncateInodeBlocksExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ret_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsTruncateInodeBlocksExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsTruncateInodeBlocksExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsTruncateInodeBlocksExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 ret = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsTruncateInodeBlocksExitFtraceEvent)
  return target;
}

size_t F2fsTruncateInodeBlocksExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsTruncateInodeBlocksExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 ret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsTruncateInodeBlocksExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsTruncateInodeBlocksExitFtraceEvent*>(
      &from));
}

void F2fsTruncateInodeBlocksExitFtraceEvent::MergeFrom(const F2fsTruncateInodeBlocksExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsTruncateInodeBlocksExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      ret_ = from.ret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsTruncateInodeBlocksExitFtraceEvent::CopyFrom(const F2fsTruncateInodeBlocksExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsTruncateInodeBlocksExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsTruncateInodeBlocksExitFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsTruncateInodeBlocksExitFtraceEvent::InternalSwap(F2fsTruncateInodeBlocksExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsTruncateInodeBlocksExitFtraceEvent, ret_)
      + sizeof(F2fsTruncateInodeBlocksExitFtraceEvent::ret_)
      - PROTOBUF_FIELD_OFFSET(F2fsTruncateInodeBlocksExitFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsTruncateInodeBlocksExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsTruncateInodeBlocksExitFtraceEvent";
}


// ===================================================================

class F2fsTruncateNodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsTruncateNodeFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_blk_addr(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

F2fsTruncateNodeFtraceEvent::F2fsTruncateNodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsTruncateNodeFtraceEvent)
}
F2fsTruncateNodeFtraceEvent::F2fsTruncateNodeFtraceEvent(const F2fsTruncateNodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&blk_addr_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(blk_addr_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsTruncateNodeFtraceEvent)
}

inline void F2fsTruncateNodeFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&blk_addr_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(blk_addr_));
}

F2fsTruncateNodeFtraceEvent::~F2fsTruncateNodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsTruncateNodeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsTruncateNodeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsTruncateNodeFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsTruncateNodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsTruncateNodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&blk_addr_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(blk_addr_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsTruncateNodeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 nid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_nid(&has_bits);
          nid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 blk_addr = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_blk_addr(&has_bits);
          blk_addr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsTruncateNodeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsTruncateNodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 nid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_nid(), target);
  }

  // optional uint32 blk_addr = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_blk_addr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsTruncateNodeFtraceEvent)
  return target;
}

size_t F2fsTruncateNodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsTruncateNodeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 nid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nid());
    }

    // optional uint32 blk_addr = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_blk_addr());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsTruncateNodeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsTruncateNodeFtraceEvent*>(
      &from));
}

void F2fsTruncateNodeFtraceEvent::MergeFrom(const F2fsTruncateNodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsTruncateNodeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      nid_ = from.nid_;
    }
    if (cached_has_bits & 0x00000008u) {
      blk_addr_ = from.blk_addr_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsTruncateNodeFtraceEvent::CopyFrom(const F2fsTruncateNodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsTruncateNodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsTruncateNodeFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsTruncateNodeFtraceEvent::InternalSwap(F2fsTruncateNodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsTruncateNodeFtraceEvent, blk_addr_)
      + sizeof(F2fsTruncateNodeFtraceEvent::blk_addr_)
      - PROTOBUF_FIELD_OFFSET(F2fsTruncateNodeFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsTruncateNodeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsTruncateNodeFtraceEvent";
}


// ===================================================================

class F2fsTruncateNodesEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsTruncateNodesEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_blk_addr(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

F2fsTruncateNodesEnterFtraceEvent::F2fsTruncateNodesEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsTruncateNodesEnterFtraceEvent)
}
F2fsTruncateNodesEnterFtraceEvent::F2fsTruncateNodesEnterFtraceEvent(const F2fsTruncateNodesEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&blk_addr_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(blk_addr_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsTruncateNodesEnterFtraceEvent)
}

inline void F2fsTruncateNodesEnterFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&blk_addr_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(blk_addr_));
}

F2fsTruncateNodesEnterFtraceEvent::~F2fsTruncateNodesEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsTruncateNodesEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsTruncateNodesEnterFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsTruncateNodesEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsTruncateNodesEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsTruncateNodesEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&blk_addr_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(blk_addr_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsTruncateNodesEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 nid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_nid(&has_bits);
          nid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 blk_addr = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_blk_addr(&has_bits);
          blk_addr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsTruncateNodesEnterFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsTruncateNodesEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 nid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_nid(), target);
  }

  // optional uint32 blk_addr = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_blk_addr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsTruncateNodesEnterFtraceEvent)
  return target;
}

size_t F2fsTruncateNodesEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsTruncateNodesEnterFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 nid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nid());
    }

    // optional uint32 blk_addr = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_blk_addr());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsTruncateNodesEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsTruncateNodesEnterFtraceEvent*>(
      &from));
}

void F2fsTruncateNodesEnterFtraceEvent::MergeFrom(const F2fsTruncateNodesEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsTruncateNodesEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      nid_ = from.nid_;
    }
    if (cached_has_bits & 0x00000008u) {
      blk_addr_ = from.blk_addr_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsTruncateNodesEnterFtraceEvent::CopyFrom(const F2fsTruncateNodesEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsTruncateNodesEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsTruncateNodesEnterFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsTruncateNodesEnterFtraceEvent::InternalSwap(F2fsTruncateNodesEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsTruncateNodesEnterFtraceEvent, blk_addr_)
      + sizeof(F2fsTruncateNodesEnterFtraceEvent::blk_addr_)
      - PROTOBUF_FIELD_OFFSET(F2fsTruncateNodesEnterFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsTruncateNodesEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsTruncateNodesEnterFtraceEvent";
}


// ===================================================================

class F2fsTruncateNodesExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsTruncateNodesExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

F2fsTruncateNodesExitFtraceEvent::F2fsTruncateNodesExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsTruncateNodesExitFtraceEvent)
}
F2fsTruncateNodesExitFtraceEvent::F2fsTruncateNodesExitFtraceEvent(const F2fsTruncateNodesExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsTruncateNodesExitFtraceEvent)
}

inline void F2fsTruncateNodesExitFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
}

F2fsTruncateNodesExitFtraceEvent::~F2fsTruncateNodesExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsTruncateNodesExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsTruncateNodesExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsTruncateNodesExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsTruncateNodesExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsTruncateNodesExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ret_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsTruncateNodesExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsTruncateNodesExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsTruncateNodesExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 ret = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsTruncateNodesExitFtraceEvent)
  return target;
}

size_t F2fsTruncateNodesExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsTruncateNodesExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 ret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsTruncateNodesExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsTruncateNodesExitFtraceEvent*>(
      &from));
}

void F2fsTruncateNodesExitFtraceEvent::MergeFrom(const F2fsTruncateNodesExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsTruncateNodesExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      ret_ = from.ret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsTruncateNodesExitFtraceEvent::CopyFrom(const F2fsTruncateNodesExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsTruncateNodesExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsTruncateNodesExitFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsTruncateNodesExitFtraceEvent::InternalSwap(F2fsTruncateNodesExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsTruncateNodesExitFtraceEvent, ret_)
      + sizeof(F2fsTruncateNodesExitFtraceEvent::ret_)
      - PROTOBUF_FIELD_OFFSET(F2fsTruncateNodesExitFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsTruncateNodesExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsTruncateNodesExitFtraceEvent";
}


// ===================================================================

class F2fsTruncatePartialNodesFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsTruncatePartialNodesFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_depth(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_err(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

F2fsTruncatePartialNodesFtraceEvent::F2fsTruncatePartialNodesFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsTruncatePartialNodesFtraceEvent)
}
F2fsTruncatePartialNodesFtraceEvent::F2fsTruncatePartialNodesFtraceEvent(const F2fsTruncatePartialNodesFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&err_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(err_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsTruncatePartialNodesFtraceEvent)
}

inline void F2fsTruncatePartialNodesFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&err_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(err_));
}

F2fsTruncatePartialNodesFtraceEvent::~F2fsTruncatePartialNodesFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsTruncatePartialNodesFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsTruncatePartialNodesFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsTruncatePartialNodesFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsTruncatePartialNodesFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsTruncatePartialNodesFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&err_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(err_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsTruncatePartialNodesFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 nid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_nid(&has_bits);
          nid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 depth = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_depth(&has_bits);
          depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 err = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_err(&has_bits);
          err_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsTruncatePartialNodesFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsTruncatePartialNodesFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 nid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_nid(), target);
  }

  // optional int32 depth = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_depth(), target);
  }

  // optional int32 err = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_err(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsTruncatePartialNodesFtraceEvent)
  return target;
}

size_t F2fsTruncatePartialNodesFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsTruncatePartialNodesFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 nid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nid());
    }

    // optional int32 depth = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_depth());
    }

    // optional int32 err = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_err());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsTruncatePartialNodesFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsTruncatePartialNodesFtraceEvent*>(
      &from));
}

void F2fsTruncatePartialNodesFtraceEvent::MergeFrom(const F2fsTruncatePartialNodesFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsTruncatePartialNodesFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      nid_ = from.nid_;
    }
    if (cached_has_bits & 0x00000008u) {
      depth_ = from.depth_;
    }
    if (cached_has_bits & 0x00000010u) {
      err_ = from.err_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsTruncatePartialNodesFtraceEvent::CopyFrom(const F2fsTruncatePartialNodesFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsTruncatePartialNodesFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsTruncatePartialNodesFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsTruncatePartialNodesFtraceEvent::InternalSwap(F2fsTruncatePartialNodesFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsTruncatePartialNodesFtraceEvent, err_)
      + sizeof(F2fsTruncatePartialNodesFtraceEvent::err_)
      - PROTOBUF_FIELD_OFFSET(F2fsTruncatePartialNodesFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsTruncatePartialNodesFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsTruncatePartialNodesFtraceEvent";
}


// ===================================================================

class F2fsUnlinkEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsUnlinkEnterFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

F2fsUnlinkEnterFtraceEvent::F2fsUnlinkEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsUnlinkEnterFtraceEvent)
}
F2fsUnlinkEnterFtraceEvent::F2fsUnlinkEnterFtraceEvent(const F2fsUnlinkEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&blocks_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsUnlinkEnterFtraceEvent)
}

inline void F2fsUnlinkEnterFtraceEvent::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&blocks_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
}

F2fsUnlinkEnterFtraceEvent::~F2fsUnlinkEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsUnlinkEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsUnlinkEnterFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
}

void F2fsUnlinkEnterFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsUnlinkEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsUnlinkEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&blocks_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(blocks_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsUnlinkEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_blocks(&has_bits);
          blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsUnlinkEnterFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsUnlinkEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 size = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_size(), target);
  }

  // optional uint64 blocks = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_blocks(), target);
  }

  // optional string name = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsUnlinkEnterFtraceEvent)
  return target;
}

size_t F2fsUnlinkEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsUnlinkEnterFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string name = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 size = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_size());
    }

    // optional uint64 blocks = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_blocks());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsUnlinkEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsUnlinkEnterFtraceEvent*>(
      &from));
}

void F2fsUnlinkEnterFtraceEvent::MergeFrom(const F2fsUnlinkEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsUnlinkEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000004u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000008u) {
      size_ = from.size_;
    }
    if (cached_has_bits & 0x00000010u) {
      blocks_ = from.blocks_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsUnlinkEnterFtraceEvent::CopyFrom(const F2fsUnlinkEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsUnlinkEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsUnlinkEnterFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsUnlinkEnterFtraceEvent::InternalSwap(F2fsUnlinkEnterFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsUnlinkEnterFtraceEvent, blocks_)
      + sizeof(F2fsUnlinkEnterFtraceEvent::blocks_)
      - PROTOBUF_FIELD_OFFSET(F2fsUnlinkEnterFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsUnlinkEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsUnlinkEnterFtraceEvent";
}


// ===================================================================

class F2fsUnlinkExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsUnlinkExitFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

F2fsUnlinkExitFtraceEvent::F2fsUnlinkExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsUnlinkExitFtraceEvent)
}
F2fsUnlinkExitFtraceEvent::F2fsUnlinkExitFtraceEvent(const F2fsUnlinkExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsUnlinkExitFtraceEvent)
}

inline void F2fsUnlinkExitFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ret_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
}

F2fsUnlinkExitFtraceEvent::~F2fsUnlinkExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsUnlinkExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsUnlinkExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsUnlinkExitFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsUnlinkExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsUnlinkExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ret_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(ret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsUnlinkExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ret(&has_bits);
          ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsUnlinkExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsUnlinkExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 ret = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsUnlinkExitFtraceEvent)
  return target;
}

size_t F2fsUnlinkExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsUnlinkExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 ret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsUnlinkExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsUnlinkExitFtraceEvent*>(
      &from));
}

void F2fsUnlinkExitFtraceEvent::MergeFrom(const F2fsUnlinkExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsUnlinkExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      ret_ = from.ret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsUnlinkExitFtraceEvent::CopyFrom(const F2fsUnlinkExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsUnlinkExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsUnlinkExitFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsUnlinkExitFtraceEvent::InternalSwap(F2fsUnlinkExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsUnlinkExitFtraceEvent, ret_)
      + sizeof(F2fsUnlinkExitFtraceEvent::ret_)
      - PROTOBUF_FIELD_OFFSET(F2fsUnlinkExitFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsUnlinkExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsUnlinkExitFtraceEvent";
}


// ===================================================================

class F2fsVmPageMkwriteFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsVmPageMkwriteFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_dirty(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_uptodate(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

F2fsVmPageMkwriteFtraceEvent::F2fsVmPageMkwriteFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsVmPageMkwriteFtraceEvent)
}
F2fsVmPageMkwriteFtraceEvent::F2fsVmPageMkwriteFtraceEvent(const F2fsVmPageMkwriteFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&uptodate_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(uptodate_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsVmPageMkwriteFtraceEvent)
}

inline void F2fsVmPageMkwriteFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&uptodate_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(uptodate_));
}

F2fsVmPageMkwriteFtraceEvent::~F2fsVmPageMkwriteFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsVmPageMkwriteFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsVmPageMkwriteFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsVmPageMkwriteFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsVmPageMkwriteFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsVmPageMkwriteFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&uptodate_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(uptodate_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsVmPageMkwriteFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dir = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_dir(&has_bits);
          dir_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 index = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dirty = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_dirty(&has_bits);
          dirty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 uptodate = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_uptodate(&has_bits);
          uptodate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsVmPageMkwriteFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsVmPageMkwriteFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_type(), target);
  }

  // optional int32 dir = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_dir(), target);
  }

  // optional uint64 index = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_index(), target);
  }

  // optional int32 dirty = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_dirty(), target);
  }

  // optional int32 uptodate = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_uptodate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsVmPageMkwriteFtraceEvent)
  return target;
}

size_t F2fsVmPageMkwriteFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsVmPageMkwriteFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
    }

    // optional int32 dir = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dir());
    }

    // optional uint64 index = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_index());
    }

    // optional int32 dirty = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dirty());
    }

    // optional int32 uptodate = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_uptodate());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsVmPageMkwriteFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsVmPageMkwriteFtraceEvent*>(
      &from));
}

void F2fsVmPageMkwriteFtraceEvent::MergeFrom(const F2fsVmPageMkwriteFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsVmPageMkwriteFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      dir_ = from.dir_;
    }
    if (cached_has_bits & 0x00000010u) {
      index_ = from.index_;
    }
    if (cached_has_bits & 0x00000020u) {
      dirty_ = from.dirty_;
    }
    if (cached_has_bits & 0x00000040u) {
      uptodate_ = from.uptodate_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsVmPageMkwriteFtraceEvent::CopyFrom(const F2fsVmPageMkwriteFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsVmPageMkwriteFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsVmPageMkwriteFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsVmPageMkwriteFtraceEvent::InternalSwap(F2fsVmPageMkwriteFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsVmPageMkwriteFtraceEvent, uptodate_)
      + sizeof(F2fsVmPageMkwriteFtraceEvent::uptodate_)
      - PROTOBUF_FIELD_OFFSET(F2fsVmPageMkwriteFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsVmPageMkwriteFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsVmPageMkwriteFtraceEvent";
}


// ===================================================================

class F2fsWriteBeginFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsWriteBeginFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

F2fsWriteBeginFtraceEvent::F2fsWriteBeginFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsWriteBeginFtraceEvent)
}
F2fsWriteBeginFtraceEvent::F2fsWriteBeginFtraceEvent(const F2fsWriteBeginFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsWriteBeginFtraceEvent)
}

inline void F2fsWriteBeginFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
}

F2fsWriteBeginFtraceEvent::~F2fsWriteBeginFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsWriteBeginFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsWriteBeginFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsWriteBeginFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsWriteBeginFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsWriteBeginFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flags_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(flags_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsWriteBeginFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsWriteBeginFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsWriteBeginFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_pos(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_len(), target);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsWriteBeginFtraceEvent)
  return target;
}

size_t F2fsWriteBeginFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsWriteBeginFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_pos());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsWriteBeginFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsWriteBeginFtraceEvent*>(
      &from));
}

void F2fsWriteBeginFtraceEvent::MergeFrom(const F2fsWriteBeginFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsWriteBeginFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pos_ = from.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      flags_ = from.flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsWriteBeginFtraceEvent::CopyFrom(const F2fsWriteBeginFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsWriteBeginFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsWriteBeginFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsWriteBeginFtraceEvent::InternalSwap(F2fsWriteBeginFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsWriteBeginFtraceEvent, flags_)
      + sizeof(F2fsWriteBeginFtraceEvent::flags_)
      - PROTOBUF_FIELD_OFFSET(F2fsWriteBeginFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsWriteBeginFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsWriteBeginFtraceEvent";
}


// ===================================================================

class F2fsWriteCheckpointFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsWriteCheckpointFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_umount(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_msg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

F2fsWriteCheckpointFtraceEvent::F2fsWriteCheckpointFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsWriteCheckpointFtraceEvent)
}
F2fsWriteCheckpointFtraceEvent::F2fsWriteCheckpointFtraceEvent(const F2fsWriteCheckpointFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  msg_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    msg_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_msg()) {
    msg_.Set(from._internal_msg(), 
      GetArenaForAllocation());
  }
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&reason_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(reason_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsWriteCheckpointFtraceEvent)
}

inline void F2fsWriteCheckpointFtraceEvent::SharedCtor() {
msg_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  msg_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reason_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(reason_));
}

F2fsWriteCheckpointFtraceEvent::~F2fsWriteCheckpointFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsWriteCheckpointFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsWriteCheckpointFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  msg_.Destroy();
}

void F2fsWriteCheckpointFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsWriteCheckpointFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsWriteCheckpointFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    msg_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&reason_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(reason_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsWriteCheckpointFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 is_umount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_umount(&has_bits);
          is_umount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string msg = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_msg();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 reason = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_reason(&has_bits);
          reason_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsWriteCheckpointFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsWriteCheckpointFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint32 is_umount = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_is_umount(), target);
  }

  // optional string msg = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_msg(), target);
  }

  // optional int32 reason = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_reason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsWriteCheckpointFtraceEvent)
  return target;
}

size_t F2fsWriteCheckpointFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsWriteCheckpointFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string msg = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_msg());
    }

    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint32 is_umount = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_is_umount());
    }

    // optional int32 reason = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_reason());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsWriteCheckpointFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsWriteCheckpointFtraceEvent*>(
      &from));
}

void F2fsWriteCheckpointFtraceEvent::MergeFrom(const F2fsWriteCheckpointFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsWriteCheckpointFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_msg(from._internal_msg());
    }
    if (cached_has_bits & 0x00000002u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000004u) {
      is_umount_ = from.is_umount_;
    }
    if (cached_has_bits & 0x00000008u) {
      reason_ = from.reason_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsWriteCheckpointFtraceEvent::CopyFrom(const F2fsWriteCheckpointFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsWriteCheckpointFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsWriteCheckpointFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsWriteCheckpointFtraceEvent::InternalSwap(F2fsWriteCheckpointFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &msg_, lhs_arena,
      &other->msg_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsWriteCheckpointFtraceEvent, reason_)
      + sizeof(F2fsWriteCheckpointFtraceEvent::reason_)
      - PROTOBUF_FIELD_OFFSET(F2fsWriteCheckpointFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsWriteCheckpointFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsWriteCheckpointFtraceEvent";
}


// ===================================================================

class F2fsWriteEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsWriteEndFtraceEvent>()._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_copied(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

F2fsWriteEndFtraceEvent::F2fsWriteEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsWriteEndFtraceEvent)
}
F2fsWriteEndFtraceEvent::F2fsWriteEndFtraceEvent(const F2fsWriteEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&dev_, &from.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&copied_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(copied_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsWriteEndFtraceEvent)
}

inline void F2fsWriteEndFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&dev_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&copied_) -
    reinterpret_cast<char*>(&dev_)) + sizeof(copied_));
}

F2fsWriteEndFtraceEvent::~F2fsWriteEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsWriteEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsWriteEndFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsWriteEndFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsWriteEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsWriteEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&copied_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(copied_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsWriteEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 copied = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_copied(&has_bits);
          copied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsWriteEndFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsWriteEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_pos(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_len(), target);
  }

  // optional uint32 copied = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_copied(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsWriteEndFtraceEvent)
  return target;
}

size_t F2fsWriteEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsWriteEndFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_pos());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint32 copied = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_copied());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsWriteEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsWriteEndFtraceEvent*>(
      &from));
}

void F2fsWriteEndFtraceEvent::MergeFrom(const F2fsWriteEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsWriteEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      ino_ = from.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      pos_ = from.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      len_ = from.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      copied_ = from.copied_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsWriteEndFtraceEvent::CopyFrom(const F2fsWriteEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsWriteEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsWriteEndFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsWriteEndFtraceEvent::InternalSwap(F2fsWriteEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsWriteEndFtraceEvent, copied_)
      + sizeof(F2fsWriteEndFtraceEvent::copied_)
      - PROTOBUF_FIELD_OFFSET(F2fsWriteEndFtraceEvent, dev_)>(
          reinterpret_cast<char*>(&dev_),
          reinterpret_cast<char*>(&other->dev_));
}

std::string F2fsWriteEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsWriteEndFtraceEvent";
}


// ===================================================================

class F2fsIostatFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsIostatFtraceEvent>()._has_bits_);
  static void set_has_app_bio(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_app_brio(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_app_dio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_app_drio(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_app_mio(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_app_mrio(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_app_rio(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_app_wio(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_fs_cdrio(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_fs_cp_dio(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_fs_cp_mio(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_fs_cp_nio(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_fs_dio(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_fs_discard(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_fs_drio(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_fs_gc_dio(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_fs_gc_nio(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_fs_gdrio(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_fs_mio(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_fs_mrio(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_fs_nio(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_fs_nrio(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
};

F2fsIostatFtraceEvent::F2fsIostatFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsIostatFtraceEvent)
}
F2fsIostatFtraceEvent::F2fsIostatFtraceEvent(const F2fsIostatFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&app_bio_, &from.app_bio_,
    static_cast<size_t>(reinterpret_cast<char*>(&fs_nrio_) -
    reinterpret_cast<char*>(&app_bio_)) + sizeof(fs_nrio_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsIostatFtraceEvent)
}

inline void F2fsIostatFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&app_bio_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&fs_nrio_) -
    reinterpret_cast<char*>(&app_bio_)) + sizeof(fs_nrio_));
}

F2fsIostatFtraceEvent::~F2fsIostatFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsIostatFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsIostatFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsIostatFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsIostatFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsIostatFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&app_bio_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&app_wio_) -
        reinterpret_cast<char*>(&app_bio_)) + sizeof(app_wio_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&fs_drio_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(fs_drio_));
  }
  if (cached_has_bits & 0x007f0000u) {
    ::memset(&fs_gc_dio_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&fs_nrio_) -
        reinterpret_cast<char*>(&fs_gc_dio_)) + sizeof(fs_nrio_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsIostatFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 app_bio = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_app_bio(&has_bits);
          app_bio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 app_brio = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_app_brio(&has_bits);
          app_brio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 app_dio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_app_dio(&has_bits);
          app_dio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 app_drio = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_app_drio(&has_bits);
          app_drio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 app_mio = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_app_mio(&has_bits);
          app_mio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 app_mrio = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_app_mrio(&has_bits);
          app_mrio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 app_rio = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_app_rio(&has_bits);
          app_rio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 app_wio = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_app_wio(&has_bits);
          app_wio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 dev = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_cdrio = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_fs_cdrio(&has_bits);
          fs_cdrio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_cp_dio = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_fs_cp_dio(&has_bits);
          fs_cp_dio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_cp_mio = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_fs_cp_mio(&has_bits);
          fs_cp_mio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_cp_nio = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_fs_cp_nio(&has_bits);
          fs_cp_nio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_dio = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_fs_dio(&has_bits);
          fs_dio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_discard = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_fs_discard(&has_bits);
          fs_discard_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_drio = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_fs_drio(&has_bits);
          fs_drio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_gc_dio = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_fs_gc_dio(&has_bits);
          fs_gc_dio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_gc_nio = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_fs_gc_nio(&has_bits);
          fs_gc_nio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_gdrio = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_fs_gdrio(&has_bits);
          fs_gdrio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_mio = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_fs_mio(&has_bits);
          fs_mio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_mrio = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_fs_mrio(&has_bits);
          fs_mrio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_nio = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_fs_nio(&has_bits);
          fs_nio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_nrio = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_fs_nrio(&has_bits);
          fs_nrio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsIostatFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsIostatFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 app_bio = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_app_bio(), target);
  }

  // optional uint64 app_brio = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_app_brio(), target);
  }

  // optional uint64 app_dio = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_app_dio(), target);
  }

  // optional uint64 app_drio = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_app_drio(), target);
  }

  // optional uint64 app_mio = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_app_mio(), target);
  }

  // optional uint64 app_mrio = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_app_mrio(), target);
  }

  // optional uint64 app_rio = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_app_rio(), target);
  }

  // optional uint64 app_wio = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_app_wio(), target);
  }

  // optional uint64 dev = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_dev(), target);
  }

  // optional uint64 fs_cdrio = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(10, this->_internal_fs_cdrio(), target);
  }

  // optional uint64 fs_cp_dio = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(11, this->_internal_fs_cp_dio(), target);
  }

  // optional uint64 fs_cp_mio = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(12, this->_internal_fs_cp_mio(), target);
  }

  // optional uint64 fs_cp_nio = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(13, this->_internal_fs_cp_nio(), target);
  }

  // optional uint64 fs_dio = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(14, this->_internal_fs_dio(), target);
  }

  // optional uint64 fs_discard = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(15, this->_internal_fs_discard(), target);
  }

  // optional uint64 fs_drio = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(16, this->_internal_fs_drio(), target);
  }

  // optional uint64 fs_gc_dio = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(17, this->_internal_fs_gc_dio(), target);
  }

  // optional uint64 fs_gc_nio = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(18, this->_internal_fs_gc_nio(), target);
  }

  // optional uint64 fs_gdrio = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(19, this->_internal_fs_gdrio(), target);
  }

  // optional uint64 fs_mio = 20;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(20, this->_internal_fs_mio(), target);
  }

  // optional uint64 fs_mrio = 21;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(21, this->_internal_fs_mrio(), target);
  }

  // optional uint64 fs_nio = 22;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(22, this->_internal_fs_nio(), target);
  }

  // optional uint64 fs_nrio = 23;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(23, this->_internal_fs_nrio(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsIostatFtraceEvent)
  return target;
}

size_t F2fsIostatFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsIostatFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 app_bio = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_app_bio());
    }

    // optional uint64 app_brio = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_app_brio());
    }

    // optional uint64 app_dio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_app_dio());
    }

    // optional uint64 app_drio = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_app_drio());
    }

    // optional uint64 app_mio = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_app_mio());
    }

    // optional uint64 app_mrio = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_app_mrio());
    }

    // optional uint64 app_rio = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_app_rio());
    }

    // optional uint64 app_wio = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_app_wio());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint64 dev = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 fs_cdrio = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fs_cdrio());
    }

    // optional uint64 fs_cp_dio = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fs_cp_dio());
    }

    // optional uint64 fs_cp_mio = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fs_cp_mio());
    }

    // optional uint64 fs_cp_nio = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fs_cp_nio());
    }

    // optional uint64 fs_dio = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fs_dio());
    }

    // optional uint64 fs_discard = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fs_discard());
    }

    // optional uint64 fs_drio = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_fs_drio());
    }

  }
  if (cached_has_bits & 0x007f0000u) {
    // optional uint64 fs_gc_dio = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_fs_gc_dio());
    }

    // optional uint64 fs_gc_nio = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_fs_gc_nio());
    }

    // optional uint64 fs_gdrio = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_fs_gdrio());
    }

    // optional uint64 fs_mio = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_fs_mio());
    }

    // optional uint64 fs_mrio = 21;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_fs_mrio());
    }

    // optional uint64 fs_nio = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_fs_nio());
    }

    // optional uint64 fs_nrio = 23;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_fs_nrio());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsIostatFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsIostatFtraceEvent*>(
      &from));
}

void F2fsIostatFtraceEvent::MergeFrom(const F2fsIostatFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsIostatFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      app_bio_ = from.app_bio_;
    }
    if (cached_has_bits & 0x00000002u) {
      app_brio_ = from.app_brio_;
    }
    if (cached_has_bits & 0x00000004u) {
      app_dio_ = from.app_dio_;
    }
    if (cached_has_bits & 0x00000008u) {
      app_drio_ = from.app_drio_;
    }
    if (cached_has_bits & 0x00000010u) {
      app_mio_ = from.app_mio_;
    }
    if (cached_has_bits & 0x00000020u) {
      app_mrio_ = from.app_mrio_;
    }
    if (cached_has_bits & 0x00000040u) {
      app_rio_ = from.app_rio_;
    }
    if (cached_has_bits & 0x00000080u) {
      app_wio_ = from.app_wio_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000200u) {
      fs_cdrio_ = from.fs_cdrio_;
    }
    if (cached_has_bits & 0x00000400u) {
      fs_cp_dio_ = from.fs_cp_dio_;
    }
    if (cached_has_bits & 0x00000800u) {
      fs_cp_mio_ = from.fs_cp_mio_;
    }
    if (cached_has_bits & 0x00001000u) {
      fs_cp_nio_ = from.fs_cp_nio_;
    }
    if (cached_has_bits & 0x00002000u) {
      fs_dio_ = from.fs_dio_;
    }
    if (cached_has_bits & 0x00004000u) {
      fs_discard_ = from.fs_discard_;
    }
    if (cached_has_bits & 0x00008000u) {
      fs_drio_ = from.fs_drio_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x007f0000u) {
    if (cached_has_bits & 0x00010000u) {
      fs_gc_dio_ = from.fs_gc_dio_;
    }
    if (cached_has_bits & 0x00020000u) {
      fs_gc_nio_ = from.fs_gc_nio_;
    }
    if (cached_has_bits & 0x00040000u) {
      fs_gdrio_ = from.fs_gdrio_;
    }
    if (cached_has_bits & 0x00080000u) {
      fs_mio_ = from.fs_mio_;
    }
    if (cached_has_bits & 0x00100000u) {
      fs_mrio_ = from.fs_mrio_;
    }
    if (cached_has_bits & 0x00200000u) {
      fs_nio_ = from.fs_nio_;
    }
    if (cached_has_bits & 0x00400000u) {
      fs_nrio_ = from.fs_nrio_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsIostatFtraceEvent::CopyFrom(const F2fsIostatFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsIostatFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsIostatFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsIostatFtraceEvent::InternalSwap(F2fsIostatFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsIostatFtraceEvent, fs_nrio_)
      + sizeof(F2fsIostatFtraceEvent::fs_nrio_)
      - PROTOBUF_FIELD_OFFSET(F2fsIostatFtraceEvent, app_bio_)>(
          reinterpret_cast<char*>(&app_bio_),
          reinterpret_cast<char*>(&other->app_bio_));
}

std::string F2fsIostatFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsIostatFtraceEvent";
}


// ===================================================================

class F2fsIostatLatencyFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsIostatLatencyFtraceEvent>()._has_bits_);
  static void set_has_d_rd_avg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_d_rd_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_d_rd_peak(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_d_wr_as_avg(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_d_wr_as_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_d_wr_as_peak(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_d_wr_s_avg(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_d_wr_s_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_d_wr_s_peak(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_m_rd_avg(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_m_rd_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_m_rd_peak(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_m_wr_as_avg(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_m_wr_as_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_m_wr_as_peak(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_m_wr_s_avg(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_m_wr_s_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_m_wr_s_peak(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_n_rd_avg(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_n_rd_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_n_rd_peak(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_n_wr_as_avg(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_n_wr_as_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_n_wr_as_peak(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_n_wr_s_avg(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_n_wr_s_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_n_wr_s_peak(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
};

F2fsIostatLatencyFtraceEvent::F2fsIostatLatencyFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsIostatLatencyFtraceEvent)
}
F2fsIostatLatencyFtraceEvent::F2fsIostatLatencyFtraceEvent(const F2fsIostatLatencyFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&d_rd_avg_, &from.d_rd_avg_,
    static_cast<size_t>(reinterpret_cast<char*>(&n_wr_s_peak_) -
    reinterpret_cast<char*>(&d_rd_avg_)) + sizeof(n_wr_s_peak_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsIostatLatencyFtraceEvent)
}

inline void F2fsIostatLatencyFtraceEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&d_rd_avg_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&n_wr_s_peak_) -
    reinterpret_cast<char*>(&d_rd_avg_)) + sizeof(n_wr_s_peak_));
}

F2fsIostatLatencyFtraceEvent::~F2fsIostatLatencyFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsIostatLatencyFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsIostatLatencyFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsIostatLatencyFtraceEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void F2fsIostatLatencyFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsIostatLatencyFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&d_rd_avg_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&d_wr_s_cnt_) -
        reinterpret_cast<char*>(&d_rd_avg_)) + sizeof(d_wr_s_cnt_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&m_wr_as_peak_) -
        reinterpret_cast<char*>(&dev_)) + sizeof(m_wr_as_peak_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&m_wr_s_avg_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&n_wr_as_cnt_) -
        reinterpret_cast<char*>(&m_wr_s_avg_)) + sizeof(n_wr_as_cnt_));
  }
  if (cached_has_bits & 0x0f000000u) {
    ::memset(&n_wr_as_peak_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&n_wr_s_peak_) -
        reinterpret_cast<char*>(&n_wr_as_peak_)) + sizeof(n_wr_s_peak_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsIostatLatencyFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 d_rd_avg = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_d_rd_avg(&has_bits);
          d_rd_avg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 d_rd_cnt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_d_rd_cnt(&has_bits);
          d_rd_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 d_rd_peak = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_d_rd_peak(&has_bits);
          d_rd_peak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 d_wr_as_avg = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_d_wr_as_avg(&has_bits);
          d_wr_as_avg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 d_wr_as_cnt = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_d_wr_as_cnt(&has_bits);
          d_wr_as_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 d_wr_as_peak = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_d_wr_as_peak(&has_bits);
          d_wr_as_peak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 d_wr_s_avg = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_d_wr_s_avg(&has_bits);
          d_wr_s_avg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 d_wr_s_cnt = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_d_wr_s_cnt(&has_bits);
          d_wr_s_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 d_wr_s_peak = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_d_wr_s_peak(&has_bits);
          d_wr_s_peak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 dev = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_dev(&has_bits);
          dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 m_rd_avg = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_m_rd_avg(&has_bits);
          m_rd_avg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 m_rd_cnt = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_m_rd_cnt(&has_bits);
          m_rd_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 m_rd_peak = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_m_rd_peak(&has_bits);
          m_rd_peak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 m_wr_as_avg = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_m_wr_as_avg(&has_bits);
          m_wr_as_avg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 m_wr_as_cnt = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_m_wr_as_cnt(&has_bits);
          m_wr_as_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 m_wr_as_peak = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_m_wr_as_peak(&has_bits);
          m_wr_as_peak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 m_wr_s_avg = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_m_wr_s_avg(&has_bits);
          m_wr_s_avg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 m_wr_s_cnt = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_m_wr_s_cnt(&has_bits);
          m_wr_s_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 m_wr_s_peak = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_m_wr_s_peak(&has_bits);
          m_wr_s_peak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 n_rd_avg = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_n_rd_avg(&has_bits);
          n_rd_avg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 n_rd_cnt = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_n_rd_cnt(&has_bits);
          n_rd_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 n_rd_peak = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_n_rd_peak(&has_bits);
          n_rd_peak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 n_wr_as_avg = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_n_wr_as_avg(&has_bits);
          n_wr_as_avg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 n_wr_as_cnt = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_n_wr_as_cnt(&has_bits);
          n_wr_as_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 n_wr_as_peak = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_n_wr_as_peak(&has_bits);
          n_wr_as_peak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 n_wr_s_avg = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_n_wr_s_avg(&has_bits);
          n_wr_s_avg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 n_wr_s_cnt = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_n_wr_s_cnt(&has_bits);
          n_wr_s_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 n_wr_s_peak = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_n_wr_s_peak(&has_bits);
          n_wr_s_peak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsIostatLatencyFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsIostatLatencyFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 d_rd_avg = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_d_rd_avg(), target);
  }

  // optional uint32 d_rd_cnt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_d_rd_cnt(), target);
  }

  // optional uint32 d_rd_peak = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_d_rd_peak(), target);
  }

  // optional uint32 d_wr_as_avg = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_d_wr_as_avg(), target);
  }

  // optional uint32 d_wr_as_cnt = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_d_wr_as_cnt(), target);
  }

  // optional uint32 d_wr_as_peak = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_d_wr_as_peak(), target);
  }

  // optional uint32 d_wr_s_avg = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_d_wr_s_avg(), target);
  }

  // optional uint32 d_wr_s_cnt = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_d_wr_s_cnt(), target);
  }

  // optional uint32 d_wr_s_peak = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_d_wr_s_peak(), target);
  }

  // optional uint64 dev = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(10, this->_internal_dev(), target);
  }

  // optional uint32 m_rd_avg = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_m_rd_avg(), target);
  }

  // optional uint32 m_rd_cnt = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_m_rd_cnt(), target);
  }

  // optional uint32 m_rd_peak = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_m_rd_peak(), target);
  }

  // optional uint32 m_wr_as_avg = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_m_wr_as_avg(), target);
  }

  // optional uint32 m_wr_as_cnt = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_m_wr_as_cnt(), target);
  }

  // optional uint32 m_wr_as_peak = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_m_wr_as_peak(), target);
  }

  // optional uint32 m_wr_s_avg = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_m_wr_s_avg(), target);
  }

  // optional uint32 m_wr_s_cnt = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_m_wr_s_cnt(), target);
  }

  // optional uint32 m_wr_s_peak = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_m_wr_s_peak(), target);
  }

  // optional uint32 n_rd_avg = 20;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_n_rd_avg(), target);
  }

  // optional uint32 n_rd_cnt = 21;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_n_rd_cnt(), target);
  }

  // optional uint32 n_rd_peak = 22;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(22, this->_internal_n_rd_peak(), target);
  }

  // optional uint32 n_wr_as_avg = 23;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(23, this->_internal_n_wr_as_avg(), target);
  }

  // optional uint32 n_wr_as_cnt = 24;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(24, this->_internal_n_wr_as_cnt(), target);
  }

  // optional uint32 n_wr_as_peak = 25;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(25, this->_internal_n_wr_as_peak(), target);
  }

  // optional uint32 n_wr_s_avg = 26;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(26, this->_internal_n_wr_s_avg(), target);
  }

  // optional uint32 n_wr_s_cnt = 27;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(27, this->_internal_n_wr_s_cnt(), target);
  }

  // optional uint32 n_wr_s_peak = 28;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(28, this->_internal_n_wr_s_peak(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsIostatLatencyFtraceEvent)
  return target;
}

size_t F2fsIostatLatencyFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsIostatLatencyFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 d_rd_avg = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_d_rd_avg());
    }

    // optional uint32 d_rd_cnt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_d_rd_cnt());
    }

    // optional uint32 d_rd_peak = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_d_rd_peak());
    }

    // optional uint32 d_wr_as_avg = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_d_wr_as_avg());
    }

    // optional uint32 d_wr_as_cnt = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_d_wr_as_cnt());
    }

    // optional uint32 d_wr_as_peak = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_d_wr_as_peak());
    }

    // optional uint32 d_wr_s_avg = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_d_wr_s_avg());
    }

    // optional uint32 d_wr_s_cnt = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_d_wr_s_cnt());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint64 dev = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint32 d_wr_s_peak = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_d_wr_s_peak());
    }

    // optional uint32 m_rd_avg = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_m_rd_avg());
    }

    // optional uint32 m_rd_cnt = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_m_rd_cnt());
    }

    // optional uint32 m_rd_peak = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_m_rd_peak());
    }

    // optional uint32 m_wr_as_avg = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_m_wr_as_avg());
    }

    // optional uint32 m_wr_as_cnt = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_m_wr_as_cnt());
    }

    // optional uint32 m_wr_as_peak = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_m_wr_as_peak());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional uint32 m_wr_s_avg = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_m_wr_s_avg());
    }

    // optional uint32 m_wr_s_cnt = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_m_wr_s_cnt());
    }

    // optional uint32 m_wr_s_peak = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_m_wr_s_peak());
    }

    // optional uint32 n_rd_avg = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_n_rd_avg());
    }

    // optional uint32 n_rd_cnt = 21;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_n_rd_cnt());
    }

    // optional uint32 n_rd_peak = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_n_rd_peak());
    }

    // optional uint32 n_wr_as_avg = 23;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_n_wr_as_avg());
    }

    // optional uint32 n_wr_as_cnt = 24;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_n_wr_as_cnt());
    }

  }
  if (cached_has_bits & 0x0f000000u) {
    // optional uint32 n_wr_as_peak = 25;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_n_wr_as_peak());
    }

    // optional uint32 n_wr_s_avg = 26;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_n_wr_s_avg());
    }

    // optional uint32 n_wr_s_cnt = 27;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_n_wr_s_cnt());
    }

    // optional uint32 n_wr_s_peak = 28;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_n_wr_s_peak());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsIostatLatencyFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsIostatLatencyFtraceEvent*>(
      &from));
}

void F2fsIostatLatencyFtraceEvent::MergeFrom(const F2fsIostatLatencyFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsIostatLatencyFtraceEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      d_rd_avg_ = from.d_rd_avg_;
    }
    if (cached_has_bits & 0x00000002u) {
      d_rd_cnt_ = from.d_rd_cnt_;
    }
    if (cached_has_bits & 0x00000004u) {
      d_rd_peak_ = from.d_rd_peak_;
    }
    if (cached_has_bits & 0x00000008u) {
      d_wr_as_avg_ = from.d_wr_as_avg_;
    }
    if (cached_has_bits & 0x00000010u) {
      d_wr_as_cnt_ = from.d_wr_as_cnt_;
    }
    if (cached_has_bits & 0x00000020u) {
      d_wr_as_peak_ = from.d_wr_as_peak_;
    }
    if (cached_has_bits & 0x00000040u) {
      d_wr_s_avg_ = from.d_wr_s_avg_;
    }
    if (cached_has_bits & 0x00000080u) {
      d_wr_s_cnt_ = from.d_wr_s_cnt_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      dev_ = from.dev_;
    }
    if (cached_has_bits & 0x00000200u) {
      d_wr_s_peak_ = from.d_wr_s_peak_;
    }
    if (cached_has_bits & 0x00000400u) {
      m_rd_avg_ = from.m_rd_avg_;
    }
    if (cached_has_bits & 0x00000800u) {
      m_rd_cnt_ = from.m_rd_cnt_;
    }
    if (cached_has_bits & 0x00001000u) {
      m_rd_peak_ = from.m_rd_peak_;
    }
    if (cached_has_bits & 0x00002000u) {
      m_wr_as_avg_ = from.m_wr_as_avg_;
    }
    if (cached_has_bits & 0x00004000u) {
      m_wr_as_cnt_ = from.m_wr_as_cnt_;
    }
    if (cached_has_bits & 0x00008000u) {
      m_wr_as_peak_ = from.m_wr_as_peak_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      m_wr_s_avg_ = from.m_wr_s_avg_;
    }
    if (cached_has_bits & 0x00020000u) {
      m_wr_s_cnt_ = from.m_wr_s_cnt_;
    }
    if (cached_has_bits & 0x00040000u) {
      m_wr_s_peak_ = from.m_wr_s_peak_;
    }
    if (cached_has_bits & 0x00080000u) {
      n_rd_avg_ = from.n_rd_avg_;
    }
    if (cached_has_bits & 0x00100000u) {
      n_rd_cnt_ = from.n_rd_cnt_;
    }
    if (cached_has_bits & 0x00200000u) {
      n_rd_peak_ = from.n_rd_peak_;
    }
    if (cached_has_bits & 0x00400000u) {
      n_wr_as_avg_ = from.n_wr_as_avg_;
    }
    if (cached_has_bits & 0x00800000u) {
      n_wr_as_cnt_ = from.n_wr_as_cnt_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0f000000u) {
    if (cached_has_bits & 0x01000000u) {
      n_wr_as_peak_ = from.n_wr_as_peak_;
    }
    if (cached_has_bits & 0x02000000u) {
      n_wr_s_avg_ = from.n_wr_s_avg_;
    }
    if (cached_has_bits & 0x04000000u) {
      n_wr_s_cnt_ = from.n_wr_s_cnt_;
    }
    if (cached_has_bits & 0x08000000u) {
      n_wr_s_peak_ = from.n_wr_s_peak_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsIostatLatencyFtraceEvent::CopyFrom(const F2fsIostatLatencyFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsIostatLatencyFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsIostatLatencyFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsIostatLatencyFtraceEvent::InternalSwap(F2fsIostatLatencyFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsIostatLatencyFtraceEvent, n_wr_s_peak_)
      + sizeof(F2fsIostatLatencyFtraceEvent::n_wr_s_peak_)
      - PROTOBUF_FIELD_OFFSET(F2fsIostatLatencyFtraceEvent, d_rd_avg_)>(
          reinterpret_cast<char*>(&d_rd_avg_),
          reinterpret_cast<char*>(&other->d_rd_avg_));
}

std::string F2fsIostatLatencyFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsIostatLatencyFtraceEvent";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsDoSubmitBioFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsDoSubmitBioFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsDoSubmitBioFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsEvictInodeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsEvictInodeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsEvictInodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsFallocateFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsFallocateFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsFallocateFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsGetDataBlockFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsGetDataBlockFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsGetDataBlockFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsGetVictimFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsGetVictimFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsGetVictimFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsIgetFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsIgetFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsIgetFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsIgetExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsIgetExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsIgetExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsNewInodeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsNewInodeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsNewInodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsReadpageFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsReadpageFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsReadpageFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsReserveNewBlockFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsReserveNewBlockFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsReserveNewBlockFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsSetPageDirtyFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsSetPageDirtyFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsSetPageDirtyFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsSubmitWritePageFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsSubmitWritePageFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsSubmitWritePageFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsSyncFileEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsSyncFileEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsSyncFileEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsSyncFileExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsSyncFileExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsSyncFileExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsSyncFsFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsSyncFsFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsSyncFsFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsTruncateFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsTruncateFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsTruncateFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsTruncateBlocksEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsTruncateBlocksEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsTruncateBlocksEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsTruncateBlocksExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsTruncateBlocksExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsTruncateBlocksExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsTruncateDataBlocksRangeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsTruncateDataBlocksRangeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsTruncateDataBlocksRangeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsTruncateInodeBlocksEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsTruncateInodeBlocksEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsTruncateInodeBlocksEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsTruncateInodeBlocksExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsTruncateInodeBlocksExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsTruncateInodeBlocksExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsTruncateNodeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsTruncateNodeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsTruncateNodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsTruncateNodesEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsTruncateNodesEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsTruncateNodesEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsTruncateNodesExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsTruncateNodesExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsTruncateNodesExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsTruncatePartialNodesFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsTruncatePartialNodesFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsTruncatePartialNodesFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsUnlinkEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsUnlinkEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsUnlinkEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsUnlinkExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsUnlinkExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsUnlinkExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsVmPageMkwriteFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsVmPageMkwriteFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsVmPageMkwriteFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsWriteBeginFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsWriteBeginFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsWriteBeginFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsWriteCheckpointFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsWriteCheckpointFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsWriteCheckpointFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsWriteEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsWriteEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsWriteEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsIostatFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsIostatFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsIostatFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsIostatLatencyFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsIostatLatencyFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsIostatLatencyFtraceEvent >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
